
main.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002600  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000030  00800060  00002600  000026b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000001a2  00800090  00800090  000026e4  2**0
                  ALLOC
  3 .eeprom       00000001  00810000  00810000  000026e4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .comment      00000012  00000000  00000000  000026e5  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000026f8  2**2
                  CONTENTS, READONLY, OCTETS
  6 .debug_aranges 00000168  00000000  00000000  00002738  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_info   000048b4  00000000  00000000  000028a0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_abbrev 00001352  00000000  00000000  00007154  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_line   00005831  00000000  00000000  000084a6  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_frame  00000924  00000000  00000000  0000dcd8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_str    00000fff  00000000  00000000  0000e5fc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_line_str 00000324  00000000  00000000  0000f5fb  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_loclists 00002158  00000000  00000000  0000f91f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_rnglists 000000ab  00000000  00000000  00011a77  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ce 00 	jmp	0x19c	; 0x19c <__ctors_end>
       4:	0c 94 ed 00 	jmp	0x1da	; 0x1da <__vector_1>
       8:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
       c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      10:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      14:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      18:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      1c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      20:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      24:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      28:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      2c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      30:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      34:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      38:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      3c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      40:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      44:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      48:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      4c:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>
      50:	0c 94 eb 00 	jmp	0x1d6	; 0x1d6 <__bad_interrupt>

00000054 <sck_lookup>:
	...
      5c:	02 00 06 00 0e 00 12 00 14 00 15 00 17 00 18 00     ................
      6c:	1a 00 1b 00 1d 00 1e 00 20 00 21 00 24 00 26 00     ........ .!.$.&.
      7c:	27 00 29 00 2c 00 2d 00 30 00 32 00 35 00 38 00     '.).,.-.0.2.5.8.
      8c:	3b 00 3e 00 41 00 44 00 47 00 4b 00 4e 00 53 00     ;.>.A.D.G.K.N.S.
      9c:	57 00 5c 00 60 00 65 00 69 00 6f 00 74 00 7a 00     W.\.`.e.i.o.t.z.
      ac:	80 00 87 00 8d 00 95 00 9c 00 a4 00 ab 00 b4 00     ................
      bc:	bd 00 c6 00 d1 00 da 00 e6 00 f0 00 fc 00 08 01     ................
      cc:	16 01 23 01 32 01 41 01 52 01 62 01 73 01 86 01     ..#.2.A.R.b.s...
      dc:	98 01 ad 01 c2 01 d9 01 ef 01 09 02 22 02 3d 02     ............".=.
      ec:	5a 02 76 02 96 02 b7 02 d9 02 fb 02 23 03 4a 03     Z.v.........#.J.
      fc:	74 03 9f 03 cc 03 fc 03 2d 04 62 04 99 04 d4 04     t.......-.b.....
     10c:	11 05 50 05 94 05 da 05 23 06 70 06 c1 06 16 07     ..P.....#.p.....
     11c:	70 07 ce 07 30 08 96 08 03 09 73 09 eb 09 68 0a     p...0.....s...h.
     12c:	eb 0a 72 0b 02 0c 9d 0c 3b 0d de 0d 91 0e 47 0f     ..r.....;.....G.
     13c:	08 10 cb 10 a0 11 81 12 6d 13 56 14 56 15 60 16     ........m.V.V.`.
     14c:	86 17 a3 18 dc 19 1e 1b 81 1c ec 1d 5e 1f d1 20     ............^.. 
     15c:	8f 22 29 24 ea 25 da 27 c5 29 e1 2b f2 2d 37 30     .")$.%.'.).+.-70
     16c:	b9 32 23 35 cb 37 4b 3a 07 3d 07 40 57 43 60 46     .2#5.7K:.=.@WC`F
     17c:	65 4a 1e 4e e2 51 f0 55 34 5a 93 5e 42 63 28 68     eJ.N.Q.U4Z.^Bc(h
     18c:	42 6d 8b 72 2f 78 34 7e 68 84 c1 8a bf 91 e0 98     Bm.r/x4~h.......

0000019c <__ctors_end>:
     19c:	11 24       	eor	r1, r1
     19e:	1f be       	out	0x3f, r1	; 63
     1a0:	cf e5       	ldi	r28, 0x5F	; 95
     1a2:	d8 e0       	ldi	r29, 0x08	; 8
     1a4:	de bf       	out	0x3e, r29	; 62
     1a6:	cd bf       	out	0x3d, r28	; 61

000001a8 <__do_copy_data>:
     1a8:	10 e0       	ldi	r17, 0x00	; 0

000001aa <.Loc.1>:
     1aa:	a0 e6       	ldi	r26, 0x60	; 96

000001ac <.Loc.2>:
     1ac:	b0 e0       	ldi	r27, 0x00	; 0

000001ae <.Loc.3>:
     1ae:	e0 e0       	ldi	r30, 0x00	; 0

000001b0 <.Loc.4>:
     1b0:	f6 e2       	ldi	r31, 0x26	; 38

000001b2 <.Loc.5>:
     1b2:	02 c0       	rjmp	.+4      	; 0x1b8 <.L__do_copy_data_start>

000001b4 <.L__do_copy_data_loop>:
     1b4:	05 90       	lpm	r0, Z+

000001b6 <.Loc.7>:
     1b6:	0d 92       	st	X+, r0

000001b8 <.L__do_copy_data_start>:
     1b8:	a0 39       	cpi	r26, 0x90	; 144

000001ba <.Loc.9>:
     1ba:	b1 07       	cpc	r27, r17

000001bc <.Loc.10>:
     1bc:	d9 f7       	brne	.-10     	; 0x1b4 <.L__do_copy_data_loop>

000001be <__do_clear_bss>:
     1be:	22 e0       	ldi	r18, 0x02	; 2

000001c0 <.Loc.1>:
     1c0:	a0 e9       	ldi	r26, 0x90	; 144

000001c2 <.Loc.2>:
     1c2:	b0 e0       	ldi	r27, 0x00	; 0

000001c4 <.Loc.3>:
     1c4:	01 c0       	rjmp	.+2      	; 0x1c8 <.Loc.5>

000001c6 <.Loc.4>:
     1c6:	1d 92       	st	X+, r1

000001c8 <.Loc.5>:
     1c8:	a2 33       	cpi	r26, 0x32	; 50

000001ca <.Loc.6>:
     1ca:	b2 07       	cpc	r27, r18

000001cc <.Loc.7>:
     1cc:	e1 f7       	brne	.-8      	; 0x1c6 <.Loc.4>

000001ce <L0^A>:
     1ce:	0e 94 00 11 	call	0x2200	; 0x2200 <main>
     1d2:	0c 94 ce 12 	jmp	0x259c	; 0x259c <_exit>

000001d6 <__bad_interrupt>:
     1d6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001da <__vector_1>:
#define MAX_SCK_DURATION ((sizeof(sck_lookup)/sizeof(unsigned short))-1)



ISR(INT0_vect)
{
     1da:	1f 92       	push	r1
     1dc:	0f 92       	push	r0
     1de:	0f b6       	in	r0, 0x3f	; 63
     1e0:	0f 92       	push	r0
     1e2:	11 24       	eor	r1, r1
     1e4:	2f 93       	push	r18
     1e6:	3f 93       	push	r19
     1e8:	4f 93       	push	r20
     1ea:	5f 93       	push	r21
     1ec:	6f 93       	push	r22
     1ee:	7f 93       	push	r23
     1f0:	8f 93       	push	r24
     1f2:	9f 93       	push	r25
     1f4:	af 93       	push	r26
     1f6:	bf 93       	push	r27
     1f8:	ef 93       	push	r30
     1fa:	ff 93       	push	r31

000001fc <.Loc.1>:
  USBNInterrupt();
     1fc:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <USBNInterrupt>

00000200 <.LVL0>:
}
     200:	ff 91       	pop	r31
     202:	ef 91       	pop	r30
     204:	bf 91       	pop	r27
     206:	af 91       	pop	r26
     208:	9f 91       	pop	r25
     20a:	8f 91       	pop	r24
     20c:	7f 91       	pop	r23
     20e:	6f 91       	pop	r22
     210:	5f 91       	pop	r21
     212:	4f 91       	pop	r20
     214:	3f 91       	pop	r19
     216:	2f 91       	pop	r18
     218:	0f 90       	pop	r0
     21a:	0f be       	out	0x3f, r0	; 63
     21c:	0f 90       	pop	r0
     21e:	1f 90       	pop	r1
     220:	18 95       	reti

00000222 <USBNDecodeVendorRequest>:

/* id need for live update of firmware */
void USBNDecodeVendorRequest(DeviceRequest *req)
{
  if(req->bRequest == STARTAVRUPDATE)
     222:	fc 01       	movw	r30, r24
     224:	81 81       	ldd	r24, Z+1	; 0x01

00000226 <.Loc.6>:
     226:	81 30       	cpi	r24, 0x01	; 1
     228:	11 f4       	brne	.+4      	; 0x22e <.L2>

0000022a <.Loc.7>:
    avrupdate_start();
     22a:	0c 94 ea 10 	jmp	0x21d4	; 0x21d4 <avrupdate_start>

0000022e <.L2>:
}
     22e:	08 95       	ret

00000230 <spi_init>:



void spi_init(void)
{
  usbprog.sck_duration = eeprom_read_byte(&ee_sck_duration);
     230:	80 e0       	ldi	r24, 0x00	; 0
     232:	90 e0       	ldi	r25, 0x00	; 0
     234:	0e 94 b9 12 	call	0x2572	; 0x2572 <eeprom_read_byte>

00000238 <.LVL4>:
     238:	90 e0       	ldi	r25, 0x00	; 0

0000023a <.Loc.13>:
     23a:	90 93 db 01 	sts	0x01DB, r25	; 0x8001db <usbprog+0x8>
     23e:	80 93 da 01 	sts	0x01DA, r24	; 0x8001da <usbprog+0x7>

00000242 <.Loc.14>:
  if(usbprog.sck_duration > MAX_SCK_DURATION)  // prevent error when EEPROM is erased
     242:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <usbprog+0x7>
     246:	90 91 db 01 	lds	r25, 0x01DB	; 0x8001db <usbprog+0x8>

0000024a <.Loc.16>:
     24a:	84 3a       	cpi	r24, 0xA4	; 164
     24c:	91 05       	cpc	r25, r1
     24e:	30 f0       	brcs	.+12     	; 0x25c <.L5>

00000250 <.Loc.17>:
    usbprog.sck_duration = 0x03;  //  1MHz as default
     250:	83 e0       	ldi	r24, 0x03	; 3
     252:	90 e0       	ldi	r25, 0x00	; 0
     254:	90 93 db 01 	sts	0x01DB, r25	; 0x8001db <usbprog+0x8>
     258:	80 93 da 01 	sts	0x01DA, r24	; 0x8001da <usbprog+0x7>

0000025c <.L5>:

  PORTB   &=  ~((1 << SCK)|(1<<MISO)|(1<<MOSI)/*|(1<<RESET_PIN)*/);  // SCK have to be low in IDLE
     25c:	88 b3       	in	r24, 0x18	; 24
     25e:	8f 71       	andi	r24, 0x1F	; 31
     260:	88 bb       	out	0x18, r24	; 24

00000262 <.Loc.21>:
  DDR_SPI &=~(1 << MISO);
     262:	be 98       	cbi	0x17, 6	; 23

00000264 <.Loc.23>:
  DDR_SPI = (1 << MOSI)|(1 << SCK)|(1 << RESET_PIN);
     264:	81 ea       	ldi	r24, 0xA1	; 161
     266:	87 bb       	out	0x17, r24	; 23

00000268 <.Loc.25>:
  // switches back to slave mode !
  DDR_SPI |= (1<<SS); // make SS an output for SPI master.
     268:	bc 9a       	sbi	0x17, 4	; 23

0000026a <.Loc.27>:

  SPCR = 0;
     26a:	1d b8       	out	0x0d, r1	; 13

0000026c <.Loc.29>:
  SPSR = 0;
     26c:	1e b8       	out	0x0e, r1	; 14

0000026e <.LBB131>:

  //This delay value is also required in hardware SPI mode in spi_pulseclockonce
  sck_delay_value=pgm_read_word(&(sck_lookup[usbprog.sck_duration]));
     26e:	e0 91 da 01 	lds	r30, 0x01DA	; 0x8001da <usbprog+0x7>
     272:	f0 91 db 01 	lds	r31, 0x01DB	; 0x8001db <usbprog+0x8>
     276:	ee 0f       	add	r30, r30
     278:	ff 1f       	adc	r31, r31
     27a:	ec 5a       	subi	r30, 0xAC	; 172
     27c:	ff 4f       	sbci	r31, 0xFF	; 255

0000027e <.LVL5>:
     27e:	25 91       	lpm	r18, Z+
     280:	35 91       	lpm	r19, Z+

00000282 <.LBE131>:
     282:	30 93 e3 01 	sts	0x01E3, r19	; 0x8001e3 <sck_delay_value+0x1>
     286:	20 93 e2 01 	sts	0x01E2, r18	; 0x8001e2 <sck_delay_value>

0000028a <.Loc.37>:

    switch(usbprog.sck_duration)
     28a:	e0 91 da 01 	lds	r30, 0x01DA	; 0x8001da <usbprog+0x7>
     28e:	f0 91 db 01 	lds	r31, 0x01DB	; 0x8001db <usbprog+0x8>

00000292 <.Loc.39>:
     292:	e7 30       	cpi	r30, 0x07	; 7
     294:	f1 05       	cpc	r31, r1
     296:	b8 f4       	brcc	.+46     	; 0x2c6 <.L6>
     298:	e0 53       	subi	r30, 0x30	; 48
     29a:	fd 4e       	sbci	r31, 0xED	; 237
     29c:	0c 94 83 11 	jmp	0x2306	; 0x2306 <__tablejump2__>

000002a0 <.L14>:
    {
       case 0x00:  //08MHz
        SPCR = (1<<SPE)|(1<<MSTR);
     2a0:	80 e5       	ldi	r24, 0x50	; 80

000002a2 <.L16>:
        SPSR = (1<<SPI2X);
        break;

      case 0x01:  //04MHz
        SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
     2a2:	8d b9       	out	0x0d, r24	; 13

000002a4 <.Loc.43>:
        SPSR = (1<<SPI2X);
     2a4:	81 e0       	ldi	r24, 0x01	; 1
     2a6:	8e b9       	out	0x0e, r24	; 14

000002a8 <.Loc.45>:
        break;
     2a8:	08 95       	ret

000002aa <.L13>:
        SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
     2aa:	83 e5       	ldi	r24, 0x53	; 83
     2ac:	fa cf       	rjmp	.-12     	; 0x2a2 <.L16>

000002ae <.L12>:

      case 0x02:  //02MHz
        SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
     2ae:	81 e5       	ldi	r24, 0x51	; 81
     2b0:	f8 cf       	rjmp	.-16     	; 0x2a2 <.L16>

000002b2 <.L11>:
        SPSR = (1<<SPI2X);
        break;

      case 0x03:	//01MHz
        SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);
     2b2:	81 e5       	ldi	r24, 0x51	; 81

000002b4 <.L17>:
        SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1);
        SPSR = 0x00;
        break;

      case 0x06:  //125kHz
        SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
     2b4:	8d b9       	out	0x0d, r24	; 13

000002b6 <.Loc.53>:
        SPSR = 0x00;
     2b6:	1e b8       	out	0x0e, r1	; 14

000002b8 <.Loc.55>:
        break;
     2b8:	08 95       	ret

000002ba <.L10>:
        SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1);
     2ba:	82 e5       	ldi	r24, 0x52	; 82
     2bc:	f2 cf       	rjmp	.-28     	; 0x2a2 <.L16>

000002be <.L9>:
        SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR1);
     2be:	82 e5       	ldi	r24, 0x52	; 82
     2c0:	f9 cf       	rjmp	.-14     	; 0x2b4 <.L17>

000002c2 <.L7>:
        SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0)|(1<<SPR1);
     2c2:	83 e5       	ldi	r24, 0x53	; 83
     2c4:	f7 cf       	rjmp	.-18     	; 0x2b4 <.L17>

000002c6 <.L6>:

	  default:
        PORTB   &=  ~(1 << SCK);
     2c6:	c7 98       	cbi	0x18, 7	; 24

000002c8 <.Loc.64>:
        DDR_SPI &=~(1 << MISO);
     2c8:	be 98       	cbi	0x17, 6	; 23

000002ca <.Loc.66>:
        DDR_SPI = (1 << MOSI)|(1 << SCK)|(1 << RESET_PIN);
     2ca:	87 bb       	out	0x17, r24	; 23

000002cc <.Loc.68>:
		break;
    }
}
     2cc:	08 95       	ret

000002ce <spi_idle>:


void spi_idle(void)
{
  //DDR_SPI = 0x00;
  DDR_SPI &= ~( (1<<MOSI) | (1<<SCK) | (1<<RESET_PIN) ); // don't make SS an input !
     2ce:	87 b3       	in	r24, 0x17	; 23
     2d0:	8e 75       	andi	r24, 0x5E	; 94
     2d2:	87 bb       	out	0x17, r24	; 23

000002d4 <.Loc.73>:
  //PORTB = 0xFF;	// only temp for jar
  PORTB = 0x00; // holger klabunde: tri state without pullups
     2d4:	18 ba       	out	0x18, r1	; 24

000002d6 <.Loc.75>:
}
     2d6:	08 95       	ret

000002d8 <spi_active>:

void spi_active(void)
{
  PORTB   &=  ~((1<<MISO)|(1 << MOSI)|(1 << SCK)|(1 << RESET_PIN));  // switch off unused Pullup resistors
     2d8:	88 b3       	in	r24, 0x18	; 24
     2da:	8e 71       	andi	r24, 0x1E	; 30
     2dc:	88 bb       	out	0x18, r24	; 24

000002de <.Loc.79>:
  DDR_SPI &=~(1 << MISO);
     2de:	be 98       	cbi	0x17, 6	; 23

000002e0 <.Loc.81>:
  DDR_SPI |= (1 << MOSI)|(1 << SCK)|(1 << RESET_PIN);
     2e0:	87 b3       	in	r24, 0x17	; 23

000002e2 <.Loc.82>:
     2e2:	81 6a       	ori	r24, 0xA1	; 161
     2e4:	87 bb       	out	0x17, r24	; 23

000002e6 <.Loc.83>:
}
     2e6:	08 95       	ret

000002e8 <spi_inout>:
 * This guarantees compatibility with both AVR and AT89 controllers, when
 * soft SPI mode is used.
 */

unsigned char spi_inout(unsigned char data)
{
     2e8:	48 2f       	mov	r20, r24

000002ea <.Loc.86>:
  unsigned char bitvalue,din=0;

  if(usbprog.sck_duration <= 6)
     2ea:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <usbprog+0x7>
     2ee:	90 91 db 01 	lds	r25, 0x01DB	; 0x8001db <usbprog+0x8>

000002f2 <.Loc.89>:
     2f2:	07 97       	sbiw	r24, 0x07	; 7
     2f4:	28 f4       	brcc	.+10     	; 0x300 <.L27>

000002f6 <.Loc.90>:
  {
    SPDR = data;
     2f6:	4f b9       	out	0x0f, r20	; 15

000002f8 <.L22>:
    while ( !(SPSR & (1 << SPIF)) ) ;
     2f8:	77 9b       	sbis	0x0e, 7	; 14
     2fa:	fe cf       	rjmp	.-4      	; 0x2f8 <.L22>

000002fc <.Loc.94>:
    return SPDR;
     2fc:	8f b1       	in	r24, 0x0f	; 15
     2fe:	08 95       	ret

00000300 <.L27>:
     300:	28 e0       	ldi	r18, 0x08	; 8
     302:	30 e0       	ldi	r19, 0x00	; 0

00000304 <.LBB142>:
  unsigned char bitvalue,din=0;
     304:	80 e0       	ldi	r24, 0x00	; 0

00000306 <.Loc.98>:
  }
  else    // software SPI with delay
  {
    for (bitvalue=128;bitvalue;bitvalue>>=1)
     306:	90 e8       	ldi	r25, 0x80	; 128

00000308 <.L21>:
    {
      //set new data
      if(data & bitvalue)
     308:	59 2f       	mov	r21, r25
     30a:	54 23       	and	r21, r20

0000030c <.Loc.101>:
     30c:	51 15       	cp	r21, r1
     30e:	29 f1       	breq	.+74     	; 0x35a <.L24>

00000310 <.Loc.102>:
        PORTB   |=  (1 << MOSI);
     310:	c5 9a       	sbi	0x18, 5	; 24

00000312 <.L25>:
      else
        PORTB   &=  ~(1 << MOSI);

      //wait 1/4 period
      _delay_loop_2(sck_delay_value>>1);
     312:	e0 91 e2 01 	lds	r30, 0x01E2	; 0x8001e2 <sck_delay_value>
     316:	f0 91 e3 01 	lds	r31, 0x01E3	; 0x8001e3 <sck_delay_value+0x1>
     31a:	f6 95       	lsr	r31
     31c:	e7 95       	ror	r30

0000031e <.L1^B1>:
		"   sbci %B0,0" "\n\t"
		"brne 1b"
		: "+d" (__count)
	);
#else
	__asm__ volatile (
     31e:	31 97       	sbiw	r30, 0x01	; 1
     320:	f1 f7       	brne	.-4      	; 0x31e <.L1^B1>

00000322 <.Loc.109>:

      //set clock high
      PORTB   |=  (1 << SCK);
     322:	c7 9a       	sbi	0x18, 7	; 24

00000324 <.Loc.112>:

      //wait another 1/4 period
      _delay_loop_2(sck_delay_value>>1);
     324:	e0 91 e2 01 	lds	r30, 0x01E2	; 0x8001e2 <sck_delay_value>
     328:	f0 91 e3 01 	lds	r31, 0x01E3	; 0x8001e3 <sck_delay_value+0x1>
     32c:	f6 95       	lsr	r31
     32e:	e7 95       	ror	r30

00000330 <.LBB148>:
     330:	df 01       	movw	r26, r30

00000332 <.L1^B2>:
     332:	11 97       	sbiw	r26, 0x01	; 1
     334:	f1 f7       	brne	.-4      	; 0x332 <.L1^B2>

00000336 <.LBE148>:

      //read in bit
      if( PINB & (1<<MISO)) {
     336:	b6 99       	sbic	0x16, 6	; 22

00000338 <.Loc.118>:
        din|=bitvalue;
     338:	89 2b       	or	r24, r25

0000033a <.L1^B3>:
     33a:	31 97       	sbiw	r30, 0x01	; 1
     33c:	f1 f7       	brne	.-4      	; 0x33a <.L1^B3>

0000033e <.LBE150>:

      //wait another 1/4 period
      _delay_loop_2(sck_delay_value>>1);

      //clear clock
      PORTB   &=  ~(1 << SCK);
     33e:	c7 98       	cbi	0x18, 7	; 24

00000340 <.LBB152>:

      //wait another 1/4 period
      _delay_loop_2(sck_delay_value>>1);
     340:	e0 91 e2 01 	lds	r30, 0x01E2	; 0x8001e2 <sck_delay_value>
     344:	f0 91 e3 01 	lds	r31, 0x01E3	; 0x8001e3 <sck_delay_value+0x1>
     348:	f6 95       	lsr	r31
     34a:	e7 95       	ror	r30

0000034c <.L1^B4>:
     34c:	31 97       	sbiw	r30, 0x01	; 1
     34e:	f1 f7       	brne	.-4      	; 0x34c <.L1^B4>

00000350 <.Loc.131>:
    for (bitvalue=128;bitvalue;bitvalue>>=1)
     350:	96 95       	lsr	r25

00000352 <.Loc.133>:
     352:	21 50       	subi	r18, 0x01	; 1
     354:	30 40       	sbci	r19, 0x00	; 0
     356:	c1 f6       	brne	.-80     	; 0x308 <.L21>

00000358 <.Loc.134>:

    }
    return din;
  }
}
     358:	08 95       	ret

0000035a <.L24>:
        PORTB   &=  ~(1 << MOSI);
     35a:	c5 98       	cbi	0x18, 5	; 24
     35c:	da cf       	rjmp	.-76     	; 0x312 <.L25>

0000035e <spi_pulseclockonce>:
 * hardware spi mode, so switch to software temporarily
 */

void spi_pulseclockonce(void) {
  unsigned char spcr_save,spsr_save;
  spcr_save=SPCR;
     35e:	3d b1       	in	r19, 0x0d	; 13

00000360 <.LVL22>:
  spsr_save=SPSR;
     360:	2e b1       	in	r18, 0x0e	; 14

00000362 <.LVL23>:
  SPCR = 0;
     362:	1d b8       	out	0x0d, r1	; 13

00000364 <.Loc.145>:
  SPSR = 0;
     364:	1e b8       	out	0x0e, r1	; 14

00000366 <.LBB158>:
     366:	80 91 e2 01 	lds	r24, 0x01E2	; 0x8001e2 <sck_delay_value>
     36a:	90 91 e3 01 	lds	r25, 0x01E3	; 0x8001e3 <sck_delay_value+0x1>

0000036e <.L1^B5>:
     36e:	01 97       	sbiw	r24, 0x01	; 1
     370:	f1 f7       	brne	.-4      	; 0x36e <.L1^B5>

00000372 <.LBE158>:
  //pulse
  _delay_loop_2(sck_delay_value);
  PORTB   |=  (1 << SCK);
     372:	c7 9a       	sbi	0x18, 7	; 24

00000374 <.LBB160>:
     374:	80 91 e2 01 	lds	r24, 0x01E2	; 0x8001e2 <sck_delay_value>
     378:	90 91 e3 01 	lds	r25, 0x01E3	; 0x8001e3 <sck_delay_value+0x1>

0000037c <.L1^B6>:
     37c:	01 97       	sbiw	r24, 0x01	; 1
     37e:	f1 f7       	brne	.-4      	; 0x37c <.L1^B6>

00000380 <.LBE160>:
  _delay_loop_2(sck_delay_value);
  PORTB   &=  ~(1 << SCK);
     380:	c7 98       	cbi	0x18, 7	; 24

00000382 <.Loc.159>:

  SPCR=spcr_save;
     382:	3d b9       	out	0x0d, r19	; 13

00000384 <.Loc.161>:
  SPSR=spsr_save;
     384:	2e b9       	out	0x0e, r18	; 14

00000386 <.Loc.163>:
}
     386:	08 95       	ret

00000388 <spi_cmd>:

uint8_t spi_cmd(uint8_t cmd, uint16_t address, uint8_t data)
{
     388:	1f 93       	push	r17
     38a:	cf 93       	push	r28
     38c:	df 93       	push	r29
     38e:	d6 2f       	mov	r29, r22
     390:	17 2f       	mov	r17, r23
     392:	c4 2f       	mov	r28, r20

00000394 <.Loc.166>:
    spi_inout(cmd);
     394:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000398 <.LVL29>:
    spi_inout(address>>8);
     398:	81 2f       	mov	r24, r17
     39a:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

0000039e <.LVL30>:
    spi_inout(address);
     39e:	8d 2f       	mov	r24, r29
     3a0:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

000003a4 <.LVL31>:
    return spi_inout(data);
     3a4:	8c 2f       	mov	r24, r28

000003a6 <.Loc.171>:
}
     3a6:	df 91       	pop	r29
     3a8:	cf 91       	pop	r28

000003aa <.Loc.172>:
     3aa:	1f 91       	pop	r17

000003ac <.Loc.173>:
    return spi_inout(data);
     3ac:	0c 94 74 01 	jmp	0x2e8	; 0x2e8 <spi_inout>

000003b0 <spi_out>:

void spi_out(char data) {
  spi_inout(data);
     3b0:	0c 94 74 01 	jmp	0x2e8	; 0x2e8 <spi_inout>

000003b4 <spi_in>:
}
char spi_in(void) {
  return spi_inout(0);;
     3b4:	80 e0       	ldi	r24, 0x00	; 0
     3b6:	0c 94 74 01 	jmp	0x2e8	; 0x2e8 <spi_inout>

000003ba <USBToglAndSend>:
    }
  }
}

void USBToglAndSend(void)
{
     3ba:	cf 93       	push	r28

000003bc <.Loc.182>:
  uint8_t sreg = SREG;
     3bc:	cf b7       	in	r28, 0x3f	; 63

000003be <.LVL37>:
  cli();
     3be:	f8 94       	cli

000003c0 <.Loc.185>:
  if(usbprog.datatogl == 1) {
     3c0:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <usbprog+0x5>
     3c4:	90 91 d9 01 	lds	r25, 0x01D9	; 0x8001d9 <usbprog+0x6>

000003c8 <.Loc.187>:
     3c8:	01 97       	sbiw	r24, 0x01	; 1
     3ca:	59 f4       	brne	.+22     	; 0x3e2 <.L38>

000003cc <.Loc.188>:
    USBNWrite(TXC1, TX_LAST+TX_EN+TX_TOGL);
     3cc:	67 e0       	ldi	r22, 0x07	; 7
     3ce:	8b e2       	ldi	r24, 0x2B	; 43
     3d0:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000003d4 <.LVL38>:
    usbprog.datatogl = 0;
     3d4:	10 92 d9 01 	sts	0x01D9, r1	; 0x8001d9 <usbprog+0x6>
     3d8:	10 92 d8 01 	sts	0x01D8, r1	; 0x8001d8 <usbprog+0x5>

000003dc <.L39>:
  } else {
    USBNWrite(TXC1, TX_LAST+TX_EN);
    usbprog.datatogl = 1;
  }
  SREG = sreg;
     3dc:	cf bf       	out	0x3f, r28	; 63

000003de <.Loc.193>:
}
     3de:	cf 91       	pop	r28

000003e0 <.Loc.194>:
     3e0:	08 95       	ret

000003e2 <.L38>:
    USBNWrite(TXC1, TX_LAST+TX_EN);
     3e2:	63 e0       	ldi	r22, 0x03	; 3
     3e4:	8b e2       	ldi	r24, 0x2B	; 43
     3e6:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000003ea <.LVL41>:
    usbprog.datatogl = 1;
     3ea:	81 e0       	ldi	r24, 0x01	; 1
     3ec:	90 e0       	ldi	r25, 0x00	; 0
     3ee:	90 93 d9 01 	sts	0x01D9, r25	; 0x8001d9 <usbprog+0x6>
     3f2:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <usbprog+0x5>
     3f6:	f2 cf       	rjmp	.-28     	; 0x3dc <.L39>

000003f8 <SendCompleteAnswer>:

void SendCompleteAnswer(void)
{
     3f8:	cf 93       	push	r28
     3fa:	df 93       	push	r29

000003fc <.Loc.199>:
  if(pgmmode.numbytes == 0)
     3fc:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <pgmmode>
     400:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <pgmmode+0x1>
     404:	89 2b       	or	r24, r25
     406:	09 f4       	brne	.+2      	; 0x40a <.LBB164>

00000408 <L0^A>:
     408:	5b c0       	rjmp	.+182    	; 0x4c0 <.L40>

0000040a <.LBB164>:
    return;

  USBNWrite(TXC1, FLUSH);
     40a:	68 e0       	ldi	r22, 0x08	; 8
     40c:	8b e2       	ldi	r24, 0x2B	; 43
     40e:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00000412 <.LVL42>:

  int i;
  if(pgmmode.numbytes > 64){
     412:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <pgmmode>
     416:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <pgmmode+0x1>

0000041a <.Loc.206>:
    for(i = 0; i < 64; i++)
     41a:	c0 e0       	ldi	r28, 0x00	; 0
     41c:	d0 e0       	ldi	r29, 0x00	; 0

0000041e <.Loc.207>:
  if(pgmmode.numbytes > 64){
     41e:	81 34       	cpi	r24, 0x41	; 65
     420:	91 05       	cpc	r25, r1
     422:	f0 f1       	brcs	.+124    	; 0x4a0 <.L42>

00000424 <.L43>:
      USBNWrite(TXD1, answer[usbprog.fragmentnumber * 64 + i]);
     424:	e0 91 dc 01 	lds	r30, 0x01DC	; 0x8001dc <usbprog+0x9>
     428:	f0 91 dd 01 	lds	r31, 0x01DD	; 0x8001dd <usbprog+0xa>

0000042c <.Loc.210>:
     42c:	96 e0       	ldi	r25, 0x06	; 6

0000042e <.L1^B7>:
     42e:	ee 0f       	add	r30, r30
     430:	ff 1f       	adc	r31, r31
     432:	9a 95       	dec	r25
     434:	e1 f7       	brne	.-8      	; 0x42e <.L1^B7>

00000436 <.Loc.211>:
     436:	ec 0f       	add	r30, r28
     438:	fd 1f       	adc	r31, r29

0000043a <.Loc.212>:
     43a:	e9 55       	subi	r30, 0x59	; 89
     43c:	ff 4f       	sbci	r31, 0xFF	; 255
     43e:	60 81       	ld	r22, Z

00000440 <.Loc.213>:
     440:	89 e2       	ldi	r24, 0x29	; 41
     442:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00000446 <.LVL44>:
    for(i = 0; i < 64; i++)
     446:	21 96       	adiw	r28, 0x01	; 1

00000448 <.Loc.215>:
     448:	c0 34       	cpi	r28, 0x40	; 64
     44a:	d1 05       	cpc	r29, r1
     44c:	59 f7       	brne	.-42     	; 0x424 <.L43>

0000044e <.Loc.216>:

    usbprog.fragmentnumber++;
     44e:	80 91 dc 01 	lds	r24, 0x01DC	; 0x8001dc <usbprog+0x9>
     452:	90 91 dd 01 	lds	r25, 0x01DD	; 0x8001dd <usbprog+0xa>

00000456 <.Loc.218>:
     456:	01 96       	adiw	r24, 0x01	; 1
     458:	90 93 dd 01 	sts	0x01DD, r25	; 0x8001dd <usbprog+0xa>
     45c:	80 93 dc 01 	sts	0x01DC, r24	; 0x8001dc <usbprog+0x9>

00000460 <.Loc.219>:
    pgmmode.numbytes = pgmmode.numbytes - 64;
     460:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <pgmmode>
     464:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <pgmmode+0x1>
     468:	80 54       	subi	r24, 0x40	; 64
     46a:	91 09       	sbc	r25, r1

0000046c <.Loc.221>:
     46c:	90 93 91 00 	sts	0x0091, r25	; 0x800091 <pgmmode+0x1>
     470:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <pgmmode>

00000474 <.L47>:

    usbprog.fragmentnumber = 0;
    pgmmode.numbytes = 0;
    USBToglAndSend();
  }
}
     474:	df 91       	pop	r29
     476:	cf 91       	pop	r28

00000478 <.Loc.225>:
    USBToglAndSend();
     478:	0c 94 dd 01 	jmp	0x3ba	; 0x3ba <USBToglAndSend>

0000047c <.L44>:
      USBNWrite(TXD1, answer[usbprog.fragmentnumber * 64 + i]);
     47c:	e0 91 dc 01 	lds	r30, 0x01DC	; 0x8001dc <usbprog+0x9>
     480:	f0 91 dd 01 	lds	r31, 0x01DD	; 0x8001dd <usbprog+0xa>

00000484 <.Loc.228>:
     484:	86 e0       	ldi	r24, 0x06	; 6

00000486 <.L1^B8>:
     486:	ee 0f       	add	r30, r30
     488:	ff 1f       	adc	r31, r31
     48a:	8a 95       	dec	r24
     48c:	e1 f7       	brne	.-8      	; 0x486 <.L1^B8>

0000048e <.Loc.229>:
     48e:	ec 0f       	add	r30, r28
     490:	fd 1f       	adc	r31, r29

00000492 <.Loc.230>:
     492:	e9 55       	subi	r30, 0x59	; 89
     494:	ff 4f       	sbci	r31, 0xFF	; 255
     496:	60 81       	ld	r22, Z

00000498 <.Loc.231>:
     498:	89 e2       	ldi	r24, 0x29	; 41
     49a:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

0000049e <.LVL48>:
    for(i = 0; i<pgmmode.numbytes; i++)
     49e:	21 96       	adiw	r28, 0x01	; 1

000004a0 <.L42>:
     4a0:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <pgmmode>
     4a4:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <pgmmode+0x1>
     4a8:	c8 17       	cp	r28, r24
     4aa:	d9 07       	cpc	r29, r25
     4ac:	38 f3       	brcs	.-50     	; 0x47c <.L44>

000004ae <.Loc.234>:
    usbprog.fragmentnumber = 0;
     4ae:	10 92 dd 01 	sts	0x01DD, r1	; 0x8001dd <usbprog+0xa>
     4b2:	10 92 dc 01 	sts	0x01DC, r1	; 0x8001dc <usbprog+0x9>

000004b6 <.Loc.236>:
    pgmmode.numbytes = 0;
     4b6:	10 92 91 00 	sts	0x0091, r1	; 0x800091 <pgmmode+0x1>
     4ba:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <pgmmode>
     4be:	da cf       	rjmp	.-76     	; 0x474 <.L47>

000004c0 <.L40>:
}
     4c0:	df 91       	pop	r29
     4c2:	cf 91       	pop	r28
     4c4:	08 95       	ret

000004c6 <CommandAnswer>:
}
#endif


void CommandAnswer(uint8_t length)
{
     4c6:	ff 92       	push	r15
     4c8:	0f 93       	push	r16
     4ca:	1f 93       	push	r17
     4cc:	cf 93       	push	r28
     4ce:	df 93       	push	r29
     4d0:	c8 2f       	mov	r28, r24

000004d2 <.Loc.242>:
  uint8_t i;
  uint8_t sreg = SREG;
     4d2:	ff b6       	in	r15, 0x3f	; 63

000004d4 <.LVL52>:
  cli();
     4d4:	f8 94       	cli

000004d6 <.Loc.246>:
  USBNWrite(TXC1, FLUSH);
     4d6:	68 e0       	ldi	r22, 0x08	; 8
     4d8:	8b e2       	ldi	r24, 0x2B	; 43

000004da <.Loc.247>:
     4da:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000004de <.LVL54>:
  for(i = 0; i < length; i++)
     4de:	d0 e0       	ldi	r29, 0x00	; 0
     4e0:	00 e0       	ldi	r16, 0x00	; 0
     4e2:	10 e0       	ldi	r17, 0x00	; 0

000004e4 <.L49>:
     4e4:	0c 17       	cp	r16, r28
     4e6:	1d 07       	cpc	r17, r29
     4e8:	49 f4       	brne	.+18     	; 0x4fc <.L50>

000004ea <.Loc.251>:
    USBNWrite(TXD1, answer[i]);

  /* control togl bit */
  USBToglAndSend();
     4ea:	0e 94 dd 01 	call	0x3ba	; 0x3ba <USBToglAndSend>

000004ee <.LVL56>:
  SREG = sreg;
     4ee:	ff be       	out	0x3f, r15	; 63

000004f0 <.Loc.254>:
}
     4f0:	df 91       	pop	r29
     4f2:	cf 91       	pop	r28

000004f4 <.Loc.255>:
     4f4:	1f 91       	pop	r17
     4f6:	0f 91       	pop	r16

000004f8 <.Loc.256>:
     4f8:	ff 90       	pop	r15

000004fa <.Loc.257>:
     4fa:	08 95       	ret

000004fc <.L50>:
    USBNWrite(TXD1, answer[i]);
     4fc:	f8 01       	movw	r30, r16
     4fe:	e9 55       	subi	r30, 0x59	; 89
     500:	ff 4f       	sbci	r31, 0xFF	; 255
     502:	60 81       	ld	r22, Z

00000504 <.Loc.260>:
     504:	89 e2       	ldi	r24, 0x29	; 41
     506:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

0000050a <.LVL61>:
  for(i = 0; i < length; i++)
     50a:	0f 5f       	subi	r16, 0xFF	; 255
     50c:	1f 4f       	sbci	r17, 0xFF	; 255

0000050e <.Loc.263>:
     50e:	ea cf       	rjmp	.-44     	; 0x4e4 <.L49>

00000510 <program_fsm>:
{
     510:	af 92       	push	r10
     512:	bf 92       	push	r11
     514:	cf 92       	push	r12
     516:	df 92       	push	r13
     518:	ef 92       	push	r14
     51a:	ff 92       	push	r15
     51c:	0f 93       	push	r16
     51e:	1f 93       	push	r17
     520:	cf 93       	push	r28
     522:	df 93       	push	r29
     524:	8c 01       	movw	r16, r24
     526:	d6 2f       	mov	r29, r22

00000528 <.LVL64>:
  if (usbprog.cmdpackage) {
     528:	20 91 d6 01 	lds	r18, 0x01D6	; 0x8001d6 <usbprog+0x3>
     52c:	30 91 d7 01 	lds	r19, 0x01D7	; 0x8001d7 <usbprog+0x4>

00000530 <.Loc.270>:
      if (pgmmode.numbytes > sizeof(answer) - _TMP_OFFSET) {
     530:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <pgmmode>
     534:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <pgmmode+0x1>

00000538 <.Loc.271>:
  if (usbprog.cmdpackage) {
     538:	23 2b       	or	r18, r19
     53a:	09 f4       	brne	.+2      	; 0x53e <.Loc.272>

0000053c <L0^A>:
     53c:	69 c0       	rjmp	.+210    	; 0x610 <.L93>

0000053e <.Loc.272>:
    buffer += 10;
     53e:	06 5f       	subi	r16, 0xF6	; 246
     540:	1f 4f       	sbci	r17, 0xFF	; 255

00000542 <.Loc.274>:
    if (eeprom) {
     542:	61 15       	cp	r22, r1
     544:	09 f4       	brne	.+2      	; 0x548 <.Loc.277>

00000546 <L0^A>:
     546:	5b c0       	rjmp	.+182    	; 0x5fe <.L53>

00000548 <.Loc.277>:
      answer[0] = CMD_PROGRAM_EEPROM_ISP;
     548:	25 e1       	ldi	r18, 0x15	; 21
     54a:	20 93 a7 00 	sts	0x00A7, r18	; 0x8000a7 <answer>

0000054e <.Loc.279>:
      ptr = (uint8_t*)answer +_TMP_OFFSET;  // reserve some space at beginning of the buffer to handle
     54e:	27 ec       	ldi	r18, 0xC7	; 199
     550:	30 e0       	ldi	r19, 0x00	; 0
     552:	30 93 e5 01 	sts	0x01E5, r19	; 0x8001e5 <ptr.0+0x1>
     556:	20 93 e4 01 	sts	0x01E4, r18	; 0x8001e4 <ptr.0>

0000055a <.Loc.281>:
      if (pgmmode.numbytes > sizeof(answer) - _TMP_OFFSET) {
     55a:	8d 30       	cpi	r24, 0x0D	; 13
     55c:	21 e0       	ldi	r18, 0x01	; 1
     55e:	92 07       	cpc	r25, r18
     560:	08 f4       	brcc	.+2      	; 0x564 <.Loc.283>

00000562 <L0^A>:
     562:	4b c0       	rjmp	.+150    	; 0x5fa <.L54>

00000564 <.Loc.283>:
        answer[1] = STATUS_CMD_FAILED;      // we are not able to program more than this
     564:	20 ec       	ldi	r18, 0xC0	; 192
     566:	20 93 a8 00 	sts	0x00A8, r18	; 0x8000a8 <answer+0x1>

0000056a <.Loc.285>:
    databytes -= 10;
     56a:	c6 e3       	ldi	r28, 0x36	; 54

0000056c <.Loc.288>:
  if (pgmmode.numbytes>databytes) {
     56c:	26 e3       	ldi	r18, 0x36	; 54
     56e:	30 e0       	ldi	r19, 0x00	; 0

00000570 <.L55>:
    pgmmode.numbytes-=databytes;
     570:	82 1b       	sub	r24, r18
     572:	93 0b       	sbc	r25, r19
     574:	90 93 91 00 	sts	0x0091, r25	; 0x800091 <pgmmode+0x1>
     578:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <pgmmode>

0000057c <.Loc.291>:
    usbprog.longpackage=1;        //Expect more data
     57c:	81 e0       	ldi	r24, 0x01	; 1
     57e:	90 e0       	ldi	r25, 0x00	; 0
     580:	90 93 d5 01 	sts	0x01D5, r25	; 0x8001d5 <usbprog+0x2>
     584:	80 93 d4 01 	sts	0x01D4, r24	; 0x8001d4 <usbprog+0x1>

00000588 <.L58>:
      poll = pgmmode.poll1;
     588:	f0 90 97 00 	lds	r15, 0x0097	; 0x800097 <pgmmode+0x7>

0000058c <.Loc.295>:
  if (eeprom && answer[1] == STATUS_CMD_OK) {
     58c:	d1 15       	cp	r29, r1
     58e:	09 f4       	brne	.+2      	; 0x592 <.Loc.296>

00000590 <L0^A>:
     590:	5a c0       	rjmp	.+180    	; 0x646 <.L60>

00000592 <.Loc.296>:
     592:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <answer+0x1>

00000596 <.Loc.297>:
     596:	81 11       	cpse	r24, r1
     598:	11 c0       	rjmp	.+34     	; 0x5bc <.L61>

0000059a <.Loc.298>:
    memcpy(ptr, buffer, databytes);
     59a:	cc 2e       	mov	r12, r28
     59c:	d1 2c       	mov	r13, r1
     59e:	e0 90 e4 01 	lds	r14, 0x01E4	; 0x8001e4 <ptr.0>
     5a2:	f0 90 e5 01 	lds	r15, 0x01E5	; 0x8001e5 <ptr.0+0x1>
     5a6:	a6 01       	movw	r20, r12
     5a8:	b8 01       	movw	r22, r16

000005aa <.Loc.299>:
     5aa:	c7 01       	movw	r24, r14
     5ac:	0e 94 b0 12 	call	0x2560	; 0x2560 <memcpy>

000005b0 <.LVL70>:
    ptr += databytes;
     5b0:	ec 0c       	add	r14, r12
     5b2:	fd 1c       	adc	r15, r13
     5b4:	f0 92 e5 01 	sts	0x01E5, r15	; 0x8001e5 <ptr.0+0x1>
     5b8:	e0 92 e4 01 	sts	0x01E4, r14	; 0x8001e4 <ptr.0>

000005bc <.L61>:
  if (!eeprom || pgmmode.numbytes == 0)
     5bc:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <pgmmode>
     5c0:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <pgmmode+0x1>
     5c4:	89 2b       	or	r24, r25
     5c6:	09 f0       	breq	.+2      	; 0x5ca <.Loc.304>

000005c8 <L0^A>:
     5c8:	5e c1       	rjmp	.+700    	; 0x886 <.L51>

000005ca <.Loc.304>:
      if (answer[1] != STATUS_CMD_OK) {
     5ca:	80 91 a8 00 	lds	r24, 0x00A8	; 0x8000a8 <answer+0x1>

000005ce <.Loc.311>:
     5ce:	81 15       	cp	r24, r1
     5d0:	79 f1       	breq	.+94     	; 0x630 <.L64>

000005d2 <.L130>:
      pgmmode.status = STATUS_CMD_OK;
     5d2:	10 92 a1 00 	sts	0x00A1, r1	; 0x8000a1 <pgmmode+0x11>

000005d6 <.Loc.314>:
      pgmmode.poll_address_valid = 0;
     5d6:	80 91 a4 00 	lds	r24, 0x00A4	; 0x8000a4 <pgmmode+0x14>
     5da:	8e 7f       	andi	r24, 0xFE	; 254
     5dc:	80 93 a4 00 	sts	0x00A4, r24	; 0x8000a4 <pgmmode+0x14>

000005e0 <.Loc.316>:
      CommandAnswer(2);
     5e0:	82 e0       	ldi	r24, 0x02	; 2

000005e2 <.Loc.317>:
}
     5e2:	df 91       	pop	r29

000005e4 <.Loc.318>:
     5e4:	cf 91       	pop	r28
     5e6:	1f 91       	pop	r17
     5e8:	0f 91       	pop	r16

000005ea <.Loc.319>:
     5ea:	ff 90       	pop	r15
     5ec:	ef 90       	pop	r14
     5ee:	df 90       	pop	r13
     5f0:	cf 90       	pop	r12
     5f2:	bf 90       	pop	r11
     5f4:	af 90       	pop	r10

000005f6 <.Loc.320>:
      CommandAnswer(2);
     5f6:	0c 94 63 02 	jmp	0x4c6	; 0x4c6 <CommandAnswer>

000005fa <.L54>:
        answer[1] = STATUS_CMD_OK;
     5fa:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

000005fe <.L53>:
    databytes -= 10;
     5fe:	c6 e3       	ldi	r28, 0x36	; 54

00000600 <.L52>:
  if (pgmmode.numbytes==64)
     600:	2c 2f       	mov	r18, r28
     602:	30 e0       	ldi	r19, 0x00	; 0

00000604 <.Loc.326>:
     604:	80 34       	cpi	r24, 0x40	; 64
     606:	91 05       	cpc	r25, r1
     608:	29 f4       	brne	.+10     	; 0x614 <.L56>

0000060a <.Loc.327>:
  if (pgmmode.numbytes>databytes) {
     60a:	81 e4       	ldi	r24, 0x41	; 65
     60c:	90 e0       	ldi	r25, 0x00	; 0
     60e:	b0 cf       	rjmp	.-160    	; 0x570 <.L55>

00000610 <.L93>:
  uint8_t databytes = 64;
     610:	c0 e4       	ldi	r28, 0x40	; 64
     612:	f6 cf       	rjmp	.-20     	; 0x600 <.L52>

00000614 <.L56>:
  if (pgmmode.numbytes>databytes) {
     614:	28 17       	cp	r18, r24
     616:	39 07       	cpc	r19, r25
     618:	08 f4       	brcc	.+2      	; 0x61c <.Loc.332>

0000061a <L0^A>:
     61a:	aa cf       	rjmp	.-172    	; 0x570 <.L55>

0000061c <.Loc.332>:
    databytes=pgmmode.numbytes;   //The number of valid bytes in this packet
     61c:	c8 2f       	mov	r28, r24

0000061e <.Loc.334>:
    pgmmode.numbytes=0;           //No more data left
     61e:	10 92 91 00 	sts	0x0091, r1	; 0x800091 <pgmmode+0x1>
     622:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <pgmmode>

00000626 <.Loc.336>:
    usbprog.longpackage=0;        //Expect no more data
     626:	10 92 d5 01 	sts	0x01D5, r1	; 0x8001d5 <usbprog+0x2>
     62a:	10 92 d4 01 	sts	0x01D4, r1	; 0x8001d4 <usbprog+0x1>
     62e:	ac cf       	rjmp	.-168    	; 0x588 <.L58>

00000630 <.L64>:
      databytes = ptr - buffer; 
     630:	80 91 e4 01 	lds	r24, 0x01E4	; 0x8001e4 <ptr.0>
     634:	90 91 e5 01 	lds	r25, 0x01E5	; 0x8001e5 <ptr.0+0x1>
     638:	87 5c       	subi	r24, 0xC7	; 199
     63a:	90 40       	sbci	r25, 0x00	; 0

0000063c <.Loc.341>:
     63c:	c8 2f       	mov	r28, r24

0000063e <.Loc.342>:
      poll = pgmmode.poll2;
     63e:	f0 90 98 00 	lds	r15, 0x0098	; 0x800098 <pgmmode+0x8>

00000642 <.LVL81>:
      buffer = (uint8_t*)answer + _TMP_OFFSET;
     642:	07 ec       	ldi	r16, 0xC7	; 199
     644:	10 e0       	ldi	r17, 0x00	; 0

00000646 <.L60>:
    for (i = 0; i < databytes; i++, buffer++) {
     646:	e1 2c       	mov	r14, r1

00000648 <.L65>:
     648:	ce 11       	cpse	r28, r14
     64a:	2d c0       	rjmp	.+90     	; 0x6a6 <.L80>

0000064c <.Loc.348>:
    if (pgmmode.numbytes==0) {
     64c:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <pgmmode>
     650:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <pgmmode+0x1>
     654:	89 2b       	or	r24, r25
     656:	09 f0       	breq	.+2      	; 0x65a <.Loc.350>

00000658 <L0^A>:
     658:	16 c1       	rjmp	.+556    	; 0x886 <.L51>

0000065a <.Loc.350>:
      if ((pgmmode.mode & 0x81) == 0x81) {
     65a:	80 91 92 00 	lds	r24, 0x0092	; 0x800092 <pgmmode+0x2>
     65e:	81 78       	andi	r24, 0x81	; 129
     660:	81 38       	cpi	r24, 0x81	; 129
     662:	09 f0       	breq	.+2      	; 0x666 <.LVL84>

00000664 <L0^A>:
     664:	05 c1       	rjmp	.+522    	; 0x870 <.L83>

00000666 <.LVL84>:
        spi_cmd(pgmmode.cmd2, pgmmode.pageaddress, 0);
     666:	60 91 9d 00 	lds	r22, 0x009D	; 0x80009d <pgmmode+0xd>
     66a:	70 91 9e 00 	lds	r23, 0x009E	; 0x80009e <pgmmode+0xe>
     66e:	40 e0       	ldi	r20, 0x00	; 0
     670:	80 91 95 00 	lds	r24, 0x0095	; 0x800095 <pgmmode+0x5>
     674:	0e 94 c4 01 	call	0x388	; 0x388 <spi_cmd>

00000678 <.LVL85>:
        if (pgmmode.mode & 0x40){
     678:	80 91 92 00 	lds	r24, 0x0092	; 0x800092 <pgmmode+0x2>

0000067c <.Loc.356>:
     67c:	86 ff       	sbrs	r24, 6
     67e:	ca c0       	rjmp	.+404    	; 0x814 <.L84>
     680:	c8 ec       	ldi	r28, 0xC8	; 200

00000682 <.L86>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(__builtin_ceil(__builtin_fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     682:	87 ee       	ldi	r24, 0xE7	; 231
     684:	93 e0       	ldi	r25, 0x03	; 3

00000686 <.L1^B9>:
     686:	01 97       	sbiw	r24, 0x01	; 1
     688:	f1 f7       	brne	.-4      	; 0x686 <.L1^B9>
     68a:	00 c0       	rjmp	.+0      	; 0x68c <L0^A>

0000068c <L0^A>:
	...

0000068e <.LBE169>:
            tmp = spi_cmd(0xf0, 0, 0);
     68e:	40 e0       	ldi	r20, 0x00	; 0
     690:	60 e0       	ldi	r22, 0x00	; 0
     692:	70 e0       	ldi	r23, 0x00	; 0
     694:	80 ef       	ldi	r24, 0xF0	; 240
     696:	0e 94 c4 01 	call	0x388	; 0x388 <spi_cmd>

0000069a <.LVL88>:
          while ((tmp & 1) && --loop);
     69a:	80 ff       	sbrs	r24, 0
     69c:	e9 c0       	rjmp	.+466    	; 0x870 <.L83>

0000069e <.Loc.370>:
     69e:	ca 95       	dec	r28

000006a0 <.Loc.371>:
     6a0:	81 f7       	brne	.-32     	; 0x682 <.L86>

000006a2 <.Loc.372>:
            pgmmode.status = STATUS_RDY_BSY_TOUT;
     6a2:	81 e8       	ldi	r24, 0x81	; 129

000006a4 <.Loc.375>:
     6a4:	db c0       	rjmp	.+438    	; 0x85c <.L129>

000006a6 <.L80>:
      if (pgmmode.large_flash && (pgmmode.address >> 16) != pgmmode.ext_address){
     6a6:	80 91 a4 00 	lds	r24, 0x00A4	; 0x8000a4 <pgmmode+0x14>

000006aa <.Loc.378>:
     6aa:	82 ff       	sbrs	r24, 2
     6ac:	1c c0       	rjmp	.+56     	; 0x6e6 <.L66>

000006ae <.Loc.379>:
     6ae:	60 91 99 00 	lds	r22, 0x0099	; 0x800099 <pgmmode+0x9>
     6b2:	70 91 9a 00 	lds	r23, 0x009A	; 0x80009a <pgmmode+0xa>
     6b6:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <pgmmode+0xb>
     6ba:	90 91 9c 00 	lds	r25, 0x009C	; 0x80009c <pgmmode+0xc>
     6be:	bc 01       	movw	r22, r24
     6c0:	88 27       	eor	r24, r24
     6c2:	99 27       	eor	r25, r25

000006c4 <.Loc.380>:
     6c4:	20 91 a5 00 	lds	r18, 0x00A5	; 0x8000a5 <pgmmode+0x15>
     6c8:	30 91 a6 00 	lds	r19, 0x00A6	; 0x8000a6 <pgmmode+0x16>

000006cc <.Loc.381>:
     6cc:	26 17       	cp	r18, r22
     6ce:	37 07       	cpc	r19, r23
     6d0:	18 06       	cpc	r1, r24
     6d2:	19 06       	cpc	r1, r25
     6d4:	41 f0       	breq	.+16     	; 0x6e6 <.L66>

000006d6 <.Loc.382>:
        pgmmode.ext_address = pgmmode.address >> 16;
     6d6:	70 93 a6 00 	sts	0x00A6, r23	; 0x8000a6 <pgmmode+0x16>
     6da:	60 93 a5 00 	sts	0x00A5, r22	; 0x8000a5 <pgmmode+0x15>

000006de <.Loc.384>:
        spi_cmd(0x4d, pgmmode.ext_address, 0x00);
     6de:	40 e0       	ldi	r20, 0x00	; 0
     6e0:	8d e4       	ldi	r24, 0x4D	; 77
     6e2:	0e 94 c4 01 	call	0x388	; 0x388 <spi_cmd>

000006e6 <.L66>:
      if (!eeprom) {
     6e6:	8e 2d       	mov	r24, r14
     6e8:	81 70       	andi	r24, 0x01	; 1
     6ea:	b8 2e       	mov	r11, r24

000006ec <.Loc.386>:
     6ec:	d1 11       	cpse	r29, r1
     6ee:	07 c0       	rjmp	.+14     	; 0x6fe <.L67>

000006f0 <.Loc.387>:
          pgmmode.cmd1 |= 8;
     6f0:	80 91 94 00 	lds	r24, 0x0094	; 0x800094 <pgmmode+0x4>

000006f4 <.Loc.388>:
        if (i&1){
     6f4:	b1 14       	cp	r11, r1
     6f6:	41 f1       	breq	.+80     	; 0x748 <.L68>

000006f8 <.Loc.390>:
          pgmmode.cmd1 |= 8;
     6f8:	88 60       	ori	r24, 0x08	; 8

000006fa <.L125>:
          pgmmode.cmd1 &= ~8;
     6fa:	80 93 94 00 	sts	0x0094, r24	; 0x800094 <pgmmode+0x4>

000006fe <.L67>:
      spi_cmd(pgmmode.cmd1, pgmmode.address, *buffer);
     6fe:	f8 01       	movw	r30, r16
     700:	41 91       	ld	r20, Z+
     702:	8f 01       	movw	r16, r30

00000704 <.Loc.394>:
     704:	60 91 99 00 	lds	r22, 0x0099	; 0x800099 <pgmmode+0x9>
     708:	70 91 9a 00 	lds	r23, 0x009A	; 0x80009a <pgmmode+0xa>
     70c:	80 91 94 00 	lds	r24, 0x0094	; 0x800094 <pgmmode+0x4>
     710:	0e 94 c4 01 	call	0x388	; 0x388 <spi_cmd>

00000714 <.LVL95>:
      if (!(pgmmode.mode & 1)) {
     714:	80 91 92 00 	lds	r24, 0x0092	; 0x800092 <pgmmode+0x2>

00000718 <.Loc.397>:
     718:	80 fd       	sbrc	r24, 0
     71a:	63 c0       	rjmp	.+198    	; 0x7e2 <.L69>

0000071c <.Loc.398>:
        if (pgmmode.mode & 8) {
     71c:	83 ff       	sbrs	r24, 3
     71e:	16 c0       	rjmp	.+44     	; 0x74c <.L70>
     720:	98 ec       	ldi	r25, 0xC8	; 200
     722:	d9 2e       	mov	r13, r25

00000724 <.L72>:
     724:	87 ee       	ldi	r24, 0xE7	; 231
     726:	93 e0       	ldi	r25, 0x03	; 3

00000728 <.L1^B10>:
     728:	01 97       	sbiw	r24, 0x01	; 1
     72a:	f1 f7       	brne	.-4      	; 0x728 <.L1^B10>
     72c:	00 c0       	rjmp	.+0      	; 0x72e <L0^A>

0000072e <L0^A>:
	...

00000730 <.LBE171>:
            tmp = spi_cmd(0xf0, 0, 0);
     730:	40 e0       	ldi	r20, 0x00	; 0
     732:	60 e0       	ldi	r22, 0x00	; 0
     734:	70 e0       	ldi	r23, 0x00	; 0
     736:	80 ef       	ldi	r24, 0xF0	; 240
     738:	0e 94 c4 01 	call	0x388	; 0x388 <spi_cmd>

0000073c <.LVL99>:
          while ((tmp & 1) && --loop);
     73c:	80 ff       	sbrs	r24, 0
     73e:	38 c0       	rjmp	.+112    	; 0x7b0 <.L74>

00000740 <.Loc.414>:
     740:	da 94       	dec	r13

00000742 <.Loc.415>:
     742:	81 f7       	brne	.-32     	; 0x724 <.L72>

00000744 <.Loc.416>:
            pgmmode.status = STATUS_RDY_BSY_TOUT;
     744:	81 e8       	ldi	r24, 0x81	; 129

00000746 <.Loc.419>:
     746:	2a c0       	rjmp	.+84     	; 0x79c <.L127>

00000748 <.L68>:
          pgmmode.cmd1 &= ~8;
     748:	87 7f       	andi	r24, 0xF7	; 247
     74a:	d7 cf       	rjmp	.-82     	; 0x6fa <.L125>

0000074c <.L70>:
        }else if ((pgmmode.mode & 4) && *buffer != poll) {
     74c:	82 ff       	sbrs	r24, 2
     74e:	2b c0       	rjmp	.+86     	; 0x7a6 <.L75>

00000750 <.Loc.424>:
     750:	f8 01       	movw	r30, r16
     752:	82 91       	ld	r24, -Z
     754:	6f 01       	movw	r12, r30
     756:	8f 15       	cp	r24, r15
     758:	31 f1       	breq	.+76     	; 0x7a6 <.L75>

0000075a <.Loc.425>:
          if (!eeprom) {
     75a:	d1 11       	cpse	r29, r1
     75c:	07 c0       	rjmp	.+14     	; 0x76c <.L76>

0000075e <.Loc.427>:
              pgmmode.cmd3 |= 8;
     75e:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <pgmmode+0x6>

00000762 <.Loc.429>:
            if (i&1){
     762:	b1 14       	cp	r11, r1
     764:	f1 f0       	breq	.+60     	; 0x7a2 <.L77>

00000766 <.Loc.430>:
              pgmmode.cmd3 |= 8;
     766:	88 60       	ori	r24, 0x08	; 8

00000768 <.L126>:
              pgmmode.cmd3 &= ~8;
     768:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <pgmmode+0x6>

0000076c <.L76>:
     76c:	88 ec       	ldi	r24, 0xC8	; 200
     76e:	a8 2e       	mov	r10, r24

00000770 <.L78>:
     770:	87 ee       	ldi	r24, 0xE7	; 231
     772:	93 e0       	ldi	r25, 0x03	; 3

00000774 <.L1^B11>:
     774:	01 97       	sbiw	r24, 0x01	; 1
     776:	f1 f7       	brne	.-4      	; 0x774 <.L1^B11>
     778:	00 c0       	rjmp	.+0      	; 0x77a <L0^A>

0000077a <L0^A>:
	...

0000077c <.LBE173>:
            tmp = spi_cmd(pgmmode.cmd3, pgmmode.address, 0);
     77c:	60 91 99 00 	lds	r22, 0x0099	; 0x800099 <pgmmode+0x9>
     780:	70 91 9a 00 	lds	r23, 0x009A	; 0x80009a <pgmmode+0xa>
     784:	40 e0       	ldi	r20, 0x00	; 0
     786:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <pgmmode+0x6>
     78a:	0e 94 c4 01 	call	0x388	; 0x388 <spi_cmd>

0000078e <.LVL107>:
          }while(tmp != *buffer && --loop);
     78e:	f6 01       	movw	r30, r12
     790:	90 81       	ld	r25, Z
     792:	98 17       	cp	r25, r24
     794:	69 f0       	breq	.+26     	; 0x7b0 <.L74>

00000796 <.Loc.446>:
     796:	aa 94       	dec	r10

00000798 <.Loc.447>:
     798:	59 f7       	brne	.-42     	; 0x770 <.L78>

0000079a <.Loc.448>:
            pgmmode.status = STATUS_CMD_TOUT;
     79a:	80 e8       	ldi	r24, 0x80	; 128

0000079c <.L127>:
            pgmmode.status = STATUS_RDY_BSY_TOUT;
     79c:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <pgmmode+0x11>
     7a0:	07 c0       	rjmp	.+14     	; 0x7b0 <.L74>

000007a2 <.L77>:
              pgmmode.cmd3 &= ~8;
     7a2:	87 7f       	andi	r24, 0xF7	; 247
     7a4:	e1 cf       	rjmp	.-62     	; 0x768 <.L126>

000007a6 <.L75>:
          wait_ms(pgmmode.delay);
     7a6:	80 91 93 00 	lds	r24, 0x0093	; 0x800093 <pgmmode+0x3>
     7aa:	90 e0       	ldi	r25, 0x00	; 0
     7ac:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

000007b0 <.L74>:
      if (eeprom || (i&1)) {
     7b0:	8d 2f       	mov	r24, r29
     7b2:	8b 29       	or	r24, r11
     7b4:	81 15       	cp	r24, r1
     7b6:	99 f0       	breq	.+38     	; 0x7de <.L79>

000007b8 <.Loc.457>:
        pgmmode.address++;
     7b8:	80 91 99 00 	lds	r24, 0x0099	; 0x800099 <pgmmode+0x9>
     7bc:	90 91 9a 00 	lds	r25, 0x009A	; 0x80009a <pgmmode+0xa>
     7c0:	a0 91 9b 00 	lds	r26, 0x009B	; 0x80009b <pgmmode+0xb>
     7c4:	b0 91 9c 00 	lds	r27, 0x009C	; 0x80009c <pgmmode+0xc>
     7c8:	01 96       	adiw	r24, 0x01	; 1
     7ca:	a1 1d       	adc	r26, r1
     7cc:	b1 1d       	adc	r27, r1
     7ce:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <pgmmode+0x9>
     7d2:	90 93 9a 00 	sts	0x009A, r25	; 0x80009a <pgmmode+0xa>
     7d6:	a0 93 9b 00 	sts	0x009B, r26	; 0x80009b <pgmmode+0xb>
     7da:	b0 93 9c 00 	sts	0x009C, r27	; 0x80009c <pgmmode+0xc>

000007de <.L79>:
    for (i = 0; i < databytes; i++, buffer++) {
     7de:	e3 94       	inc	r14

000007e0 <.Loc.461>:
     7e0:	33 cf       	rjmp	.-410    	; 0x648 <.L65>

000007e2 <.L69>:
        if (*buffer != poll && !pgmmode.poll_address_valid) {
     7e2:	f8 01       	movw	r30, r16

000007e4 <.Loc.464>:
     7e4:	82 91       	ld	r24, -Z
     7e6:	8f 15       	cp	r24, r15
     7e8:	19 f3       	breq	.-58     	; 0x7b0 <.L74>

000007ea <.Loc.465>:
     7ea:	90 91 a4 00 	lds	r25, 0x00A4	; 0x8000a4 <pgmmode+0x14>

000007ee <.Loc.466>:
     7ee:	90 fd       	sbrc	r25, 0
     7f0:	df cf       	rjmp	.-66     	; 0x7b0 <.L74>

000007f2 <.Loc.467>:
          pgmmode.poll_address = pgmmode.address;
     7f2:	20 91 99 00 	lds	r18, 0x0099	; 0x800099 <pgmmode+0x9>
     7f6:	30 91 9a 00 	lds	r19, 0x009A	; 0x80009a <pgmmode+0xa>
     7fa:	30 93 a3 00 	sts	0x00A3, r19	; 0x8000a3 <pgmmode+0x13>
     7fe:	20 93 a2 00 	sts	0x00A2, r18	; 0x8000a2 <pgmmode+0x12>

00000802 <.Loc.469>:
          pgmmode.poll_address_valid = 1;
     802:	e0 fa       	bst	r14, 0
     804:	88 27       	eor	r24, r24
     806:	81 f9       	bld	r24, 1
     808:	81 60       	ori	r24, 0x01	; 1
     80a:	9c 7f       	andi	r25, 0xFC	; 252
     80c:	89 2b       	or	r24, r25
     80e:	80 93 a4 00 	sts	0x00A4, r24	; 0x8000a4 <pgmmode+0x14>
     812:	ce cf       	rjmp	.-100    	; 0x7b0 <.L74>

00000814 <.L84>:
        }else if ((pgmmode.mode & 0x20) && pgmmode.poll_address_valid) {
     814:	85 ff       	sbrs	r24, 5
     816:	27 c0       	rjmp	.+78     	; 0x866 <.L88>

00000818 <.Loc.474>:
     818:	90 91 a4 00 	lds	r25, 0x00A4	; 0x8000a4 <pgmmode+0x14>
     81c:	90 ff       	sbrs	r25, 0
     81e:	23 c0       	rjmp	.+70     	; 0x866 <.L88>

00000820 <.Loc.475>:
          if (!eeprom) {
     820:	d1 11       	cpse	r29, r1
     822:	07 c0       	rjmp	.+14     	; 0x832 <.L89>

00000824 <.Loc.477>:
              pgmmode.cmd3 |= 8;
     824:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <pgmmode+0x6>

00000828 <.Loc.479>:
            if (pgmmode.poll_address_odd) {
     828:	91 ff       	sbrs	r25, 1
     82a:	1b c0       	rjmp	.+54     	; 0x862 <.L90>

0000082c <.Loc.480>:
              pgmmode.cmd3 |= 8;
     82c:	88 60       	ori	r24, 0x08	; 8

0000082e <.L128>:
              pgmmode.cmd3 &= ~8;
     82e:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <pgmmode+0x6>

00000832 <.L89>:
     832:	c8 ec       	ldi	r28, 0xC8	; 200

00000834 <.L91>:
     834:	e7 ee       	ldi	r30, 0xE7	; 231
     836:	f3 e0       	ldi	r31, 0x03	; 3

00000838 <.L1^B12>:
     838:	31 97       	sbiw	r30, 0x01	; 1
     83a:	f1 f7       	brne	.-4      	; 0x838 <.L1^B12>
     83c:	00 c0       	rjmp	.+0      	; 0x83e <L0^A>

0000083e <L0^A>:
	...

00000840 <.LBE175>:
            tmp = spi_cmd(pgmmode.cmd3, pgmmode.poll_address, 0);
     840:	60 91 a2 00 	lds	r22, 0x00A2	; 0x8000a2 <pgmmode+0x12>
     844:	70 91 a3 00 	lds	r23, 0x00A3	; 0x8000a3 <pgmmode+0x13>
     848:	40 e0       	ldi	r20, 0x00	; 0
     84a:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <pgmmode+0x6>
     84e:	0e 94 c4 01 	call	0x388	; 0x388 <spi_cmd>

00000852 <.LVL118>:
          }while(tmp == poll && --loop);
     852:	f8 12       	cpse	r15, r24
     854:	0d c0       	rjmp	.+26     	; 0x870 <.L83>

00000856 <.Loc.496>:
     856:	ca 95       	dec	r28

00000858 <.Loc.497>:
     858:	69 f7       	brne	.-38     	; 0x834 <.L91>

0000085a <.Loc.498>:
            pgmmode.status = STATUS_CMD_TOUT;
     85a:	80 e8       	ldi	r24, 0x80	; 128

0000085c <.L129>:
            pgmmode.status = STATUS_RDY_BSY_TOUT;
     85c:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <pgmmode+0x11>
     860:	07 c0       	rjmp	.+14     	; 0x870 <.L83>

00000862 <.L90>:
              pgmmode.cmd3 &= ~8;
     862:	87 7f       	andi	r24, 0xF7	; 247
     864:	e4 cf       	rjmp	.-56     	; 0x82e <.L128>

00000866 <.L88>:
          wait_ms(pgmmode.delay);
     866:	80 91 93 00 	lds	r24, 0x0093	; 0x800093 <pgmmode+0x3>
     86a:	90 e0       	ldi	r25, 0x00	; 0
     86c:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

00000870 <.L83>:
      answer[0] = eeprom ? CMD_PROGRAM_EEPROM_ISP : CMD_PROGRAM_FLASH_ISP;
     870:	85 e1       	ldi	r24, 0x15	; 21

00000872 <.Loc.507>:
     872:	d1 11       	cpse	r29, r1
     874:	01 c0       	rjmp	.+2      	; 0x878 <.L92>

00000876 <.Loc.508>:
     876:	83 e1       	ldi	r24, 0x13	; 19

00000878 <.L92>:
     878:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

0000087c <.Loc.510>:
      answer[1] = pgmmode.status;
     87c:	80 91 a1 00 	lds	r24, 0x00A1	; 0x8000a1 <pgmmode+0x11>

00000880 <.Loc.512>:
     880:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <answer+0x1>
     884:	a6 ce       	rjmp	.-692    	; 0x5d2 <.L130>

00000886 <.L51>:
}
     886:	df 91       	pop	r29

00000888 <.Loc.515>:
     888:	cf 91       	pop	r28

0000088a <.Loc.516>:
     88a:	1f 91       	pop	r17
     88c:	0f 91       	pop	r16

0000088e <.Loc.517>:
     88e:	ff 90       	pop	r15
     890:	ef 90       	pop	r14
     892:	df 90       	pop	r13
     894:	cf 90       	pop	r12
     896:	bf 90       	pop	r11
     898:	af 90       	pop	r10
     89a:	08 95       	ret

0000089c <cmd_enter_progmode>:

/** Enter ISP programming mode
 */
void cmd_enter_progmode(struct cmd_enter_progmode_s *cmd) {
     89c:	ef 92       	push	r14
     89e:	ff 92       	push	r15
     8a0:	0f 93       	push	r16
     8a2:	1f 93       	push	r17
     8a4:	cf 93       	push	r28
     8a6:	df 93       	push	r29
     8a8:	ec 01       	movw	r28, r24

000008aa <.Loc.520>:
    SendHex(*((char *)cmd+i));
    UARTPutChar(' ');
  }
  SendHex(cmd->cmd1);
  #endif
  pgmmode.address = 0;
     8aa:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <pgmmode+0x9>
     8ae:	10 92 9a 00 	sts	0x009A, r1	; 0x80009a <pgmmode+0xa>
     8b2:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <pgmmode+0xb>
     8b6:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <pgmmode+0xc>

000008ba <.Loc.522>:
  pgmmode.status = STATUS_CMD_OK;
     8ba:	10 92 a1 00 	sts	0x00A1, r1	; 0x8000a1 <pgmmode+0x11>

000008be <.Loc.524>:
  pgmmode.ext_address = 0xffff;
  pgmmode.large_flash = 0;
  pgmmode.poll_address_valid = 0;
     8be:	80 91 a4 00 	lds	r24, 0x00A4	; 0x8000a4 <pgmmode+0x14>

000008c2 <.Loc.528>:
     8c2:	8a 7f       	andi	r24, 0xFA	; 250
     8c4:	80 93 a4 00 	sts	0x00A4, r24	; 0x8000a4 <pgmmode+0x14>

000008c8 <.Loc.529>:
  pgmmode.ext_address = 0xffff;
     8c8:	8f ef       	ldi	r24, 0xFF	; 255
     8ca:	9f ef       	ldi	r25, 0xFF	; 255
     8cc:	90 93 a6 00 	sts	0x00A6, r25	; 0x8000a6 <pgmmode+0x16>
     8d0:	80 93 a5 00 	sts	0x00A5, r24	; 0x8000a5 <pgmmode+0x15>

000008d4 <.Loc.530>:
  spi_active();
     8d4:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <spi_active>

000008d8 <.LVL130>:
  LED_on;
     8d8:	dc 9a       	sbi	0x1b, 4	; 27

000008da <.Loc.532>:

  PORTB &= ~(1<<SCK);
     8da:	c7 98       	cbi	0x18, 7	; 24

000008dc <.Loc.534>:

  if(usbprog.reset_pol==1)
     8dc:	80 91 e0 01 	lds	r24, 0x01E0	; 0x8001e0 <usbprog+0xd>
     8e0:	90 91 e1 01 	lds	r25, 0x01E1	; 0x8001e1 <usbprog+0xe>

000008e4 <.Loc.536>:
     8e4:	01 97       	sbiw	r24, 0x01	; 1
     8e6:	f9 f4       	brne	.+62     	; 0x926 <.L132>

000008e8 <.Loc.537>:
  {
    PORTB &= ~(1<<RESET_PIN);
     8e8:	c0 98       	cbi	0x18, 0	; 24

000008ea <.Loc.539>:
    wait_ms(10);
     8ea:	8a e0       	ldi	r24, 0x0A	; 10
     8ec:	90 e0       	ldi	r25, 0x00	; 0
     8ee:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

000008f2 <.LVL131>:
    PORTB |= (1<<RESET_PIN);  // give reset a positive pulse
     8f2:	c0 9a       	sbi	0x18, 0	; 24

000008f4 <.Loc.542>:
    wait_ms(10);
     8f4:	8a e0       	ldi	r24, 0x0A	; 10
     8f6:	90 e0       	ldi	r25, 0x00	; 0
     8f8:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

000008fc <.LVL132>:
    PORTB &= ~(1<<RESET_PIN);
     8fc:	c0 98       	cbi	0x18, 0	; 24

000008fe <.L140>:
    PORTB |= (1<<RESET_PIN);  // give reset a positive pulse
    wait_ms(10);
    PORTB &= ~(1<<RESET_PIN);
    wait_ms(10);
    PORTB |= (1<<RESET_PIN);  // give reset a positive pulse
    wait_ms(10);
     8fe:	8a e0       	ldi	r24, 0x0A	; 10
     900:	90 e0       	ldi	r25, 0x00	; 0
     902:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

00000906 <.LVL133>:
  }

  answer[0] = CMD_ENTER_PROGMODE_ISP;
     906:	80 e1       	ldi	r24, 0x10	; 16
     908:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

0000090c <.Loc.549>:

  wait_ms(cmd->cmdexedelay);
     90c:	8b 81       	ldd	r24, Y+3	; 0x03
     90e:	90 e0       	ldi	r25, 0x00	; 0
     910:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

00000914 <.LVL134>:

  int syncloops = cmd->synchloops;
     914:	0c 81       	ldd	r16, Y+4	; 0x04
     916:	10 e0       	ldi	r17, 0x00	; 0

00000918 <.L134>:
  unsigned char result3,result4;
  for (;syncloops > 0; syncloops--) {
     918:	01 15       	cp	r16, r1
     91a:	11 05       	cpc	r17, r1
     91c:	81 f4       	brne	.+32     	; 0x93e <.L139>

0000091e <.Loc.555>:
    UARTPutChar('#');
    #endif
    spi_pulseclockonce();
  };

  answer[1] = STATUS_CMD_FAILED;
     91e:	80 ec       	ldi	r24, 0xC0	; 192
     920:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <answer+0x1>
     924:	2f c0       	rjmp	.+94     	; 0x984 <.L143>

00000926 <.L132>:
    PORTB |= (1<<RESET_PIN);  // give reset a positive pulse
     926:	c0 9a       	sbi	0x18, 0	; 24

00000928 <.Loc.560>:
    wait_ms(10);
     928:	8a e0       	ldi	r24, 0x0A	; 10
     92a:	90 e0       	ldi	r25, 0x00	; 0
     92c:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

00000930 <.LVL137>:
    PORTB &= ~(1<<RESET_PIN);
     930:	c0 98       	cbi	0x18, 0	; 24

00000932 <.Loc.563>:
    wait_ms(10);
     932:	8a e0       	ldi	r24, 0x0A	; 10
     934:	90 e0       	ldi	r25, 0x00	; 0
     936:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

0000093a <.LVL138>:
    PORTB |= (1<<RESET_PIN);  // give reset a positive pulse
     93a:	c0 9a       	sbi	0x18, 0	; 24
     93c:	e0 cf       	rjmp	.-64     	; 0x8fe <.L140>

0000093e <.L139>:
  spi_inout(data);
     93e:	88 85       	ldd	r24, Y+8	; 0x08
     940:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000944 <.LBE180>:
    wait_ms(cmd->bytedelay);
     944:	8d 81       	ldd	r24, Y+5	; 0x05
     946:	90 e0       	ldi	r25, 0x00	; 0
     948:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

0000094c <.LBB182>:
  spi_inout(data);
     94c:	89 85       	ldd	r24, Y+9	; 0x09
     94e:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000952 <.LBE182>:
    wait_ms(cmd->bytedelay);
     952:	8d 81       	ldd	r24, Y+5	; 0x05
     954:	90 e0       	ldi	r25, 0x00	; 0
     956:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

0000095a <.LVL143>:
    result3 = spi_inout(cmd->cmd3);
     95a:	8a 85       	ldd	r24, Y+10	; 0x0a
     95c:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000960 <.LVL144>:
     960:	e8 2e       	mov	r14, r24

00000962 <.LVL145>:
    wait_ms(cmd->bytedelay);
     962:	8d 81       	ldd	r24, Y+5	; 0x05
     964:	90 e0       	ldi	r25, 0x00	; 0
     966:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

0000096a <.LVL146>:
    result4 = spi_inout(cmd->cmd4);
     96a:	8b 85       	ldd	r24, Y+11	; 0x0b
     96c:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000970 <.LVL147>:
     970:	f8 2e       	mov	r15, r24

00000972 <.LVL148>:
    wait_ms(cmd->bytedelay);
     972:	8d 81       	ldd	r24, Y+5	; 0x05
     974:	90 e0       	ldi	r25, 0x00	; 0
     976:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

0000097a <.LVL149>:
    if ((cmd->pollindex==0) ||
     97a:	9f 81       	ldd	r25, Y+7	; 0x07

0000097c <.Loc.584>:
     97c:	91 11       	cpse	r25, r1
     97e:	0b c0       	rjmp	.+22     	; 0x996 <.L135>

00000980 <.L137>:
      answer[1] = STATUS_CMD_OK;
     980:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

00000984 <.L143>:
  CommandAnswer(2);
     984:	82 e0       	ldi	r24, 0x02	; 2

00000986 <.Loc.589>:
  return;
}
     986:	df 91       	pop	r29
     988:	cf 91       	pop	r28

0000098a <.Loc.590>:
     98a:	1f 91       	pop	r17
     98c:	0f 91       	pop	r16

0000098e <.Loc.591>:
     98e:	ff 90       	pop	r15
     990:	ef 90       	pop	r14

00000992 <.Loc.592>:
  CommandAnswer(2);
     992:	0c 94 63 02 	jmp	0x4c6	; 0x4c6 <CommandAnswer>

00000996 <.L135>:
    if ((cmd->pollindex==0) ||
     996:	93 30       	cpi	r25, 0x03	; 3
     998:	41 f4       	brne	.+16     	; 0x9aa <.L136>

0000099a <.Loc.594>:
        ((cmd->pollindex==3) && (result3==cmd->pollvalue)) ||
     99a:	8e 81       	ldd	r24, Y+6	; 0x06
     99c:	8e 15       	cp	r24, r14

0000099e <.L142>:
        ((cmd->pollindex==4) && (result4==cmd->pollvalue))) {
     99e:	81 f3       	breq	.-32     	; 0x980 <.L137>

000009a0 <.L138>:
    spi_pulseclockonce();
     9a0:	0e 94 af 01 	call	0x35e	; 0x35e <spi_pulseclockonce>

000009a4 <.LVL154>:
  for (;syncloops > 0; syncloops--) {
     9a4:	01 50       	subi	r16, 0x01	; 1
     9a6:	11 09       	sbc	r17, r1

000009a8 <.Loc.598>:
     9a8:	b7 cf       	rjmp	.-146    	; 0x918 <.L134>

000009aa <.L136>:
        ((cmd->pollindex==3) && (result3==cmd->pollvalue)) ||
     9aa:	94 30       	cpi	r25, 0x04	; 4
     9ac:	c9 f7       	brne	.-14     	; 0x9a0 <.L138>

000009ae <.Loc.600>:
        ((cmd->pollindex==4) && (result4==cmd->pollvalue))) {
     9ae:	8e 81       	ldd	r24, Y+6	; 0x06
     9b0:	8f 15       	cp	r24, r15
     9b2:	f5 cf       	rjmp	.-22     	; 0x99e <.L142>

000009b4 <cmd_spi_multi>:

/** Send/receive multiple spi bytes
 */
void cmd_spi_multi(struct cmd_spi_multi_s *cmd) {
     9b4:	cf 92       	push	r12
     9b6:	df 92       	push	r13
     9b8:	ef 92       	push	r14
     9ba:	ff 92       	push	r15
     9bc:	0f 93       	push	r16
     9be:	1f 93       	push	r17
     9c0:	cf 93       	push	r28
     9c2:	df 93       	push	r29
     9c4:	ec 01       	movw	r28, r24

000009c6 <.Loc.603>:
  char send,receive;
  /*numsent *must* be int because char may overflow if numRx+rxStart
    becomes too large to fit in char */

  int numsent=0,numrecv=0;
  if (cmd->numTx>60||cmd->numRx>60) {
     9c6:	89 81       	ldd	r24, Y+1	; 0x01

000009c8 <.Loc.607>:
     9c8:	8d 33       	cpi	r24, 0x3D	; 61
     9ca:	40 f4       	brcc	.+16     	; 0x9dc <.L145>

000009cc <.Loc.608>:
     9cc:	8a 81       	ldd	r24, Y+2	; 0x02
     9ce:	6e 01       	movw	r12, r28

000009d0 <.LBB186>:
  int numsent=0,numrecv=0;
     9d0:	00 e0       	ldi	r16, 0x00	; 0
     9d2:	10 e0       	ldi	r17, 0x00	; 0

000009d4 <.Loc.610>:
    //Not implemented
    answer[0] = CMD_SPI_MULTI;
    answer[1] = STATUS_CMD_UNKNOWN;
    CommandAnswer(2);
  } else {
    for(numsent=0;(numsent<cmd->numTx)||(numrecv<cmd->numRx);numsent++) {
     9d4:	e1 2c       	mov	r14, r1
     9d6:	f1 2c       	mov	r15, r1

000009d8 <.Loc.611>:
  if (cmd->numTx>60||cmd->numRx>60) {
     9d8:	8d 33       	cpi	r24, 0x3D	; 61
     9da:	28 f1       	brcs	.+74     	; 0xa26 <.L146>

000009dc <.L145>:
    answer[0] = CMD_SPI_MULTI;
     9dc:	8d e1       	ldi	r24, 0x1D	; 29
     9de:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

000009e2 <.Loc.614>:
    answer[1] = STATUS_CMD_UNKNOWN;
     9e2:	89 ec       	ldi	r24, 0xC9	; 201
     9e4:	80 93 a8 00 	sts	0x00A8, r24	; 0x8000a8 <answer+0x1>

000009e8 <.Loc.616>:
    CommandAnswer(2);
     9e8:	82 e0       	ldi	r24, 0x02	; 2

000009ea <.L151>:

    answer[numrecv+2] = STATUS_CMD_OK;
    CommandAnswer(numrecv+3);
  }

}
     9ea:	df 91       	pop	r29
     9ec:	cf 91       	pop	r28

000009ee <.Loc.618>:
     9ee:	1f 91       	pop	r17
     9f0:	0f 91       	pop	r16
     9f2:	ff 90       	pop	r15
     9f4:	ef 90       	pop	r14
     9f6:	df 90       	pop	r13
     9f8:	cf 90       	pop	r12

000009fa <.Loc.619>:
    CommandAnswer(numrecv+3);
     9fa:	0c 94 63 02 	jmp	0x4c6	; 0x4c6 <CommandAnswer>

000009fe <.L148>:
      if (numsent<cmd->numTx) send=cmd->txData[numsent]; else send=0;
     9fe:	f6 01       	movw	r30, r12
     a00:	84 81       	ldd	r24, Z+4	; 0x04

00000a02 <.L149>:
      receive=spi_inout(send);
     a02:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000a06 <.LVL163>:
      if (numsent>=cmd->rxStart) {
     a06:	9b 81       	ldd	r25, Y+3	; 0x03

00000a08 <.Loc.626>:
     a08:	e9 16       	cp	r14, r25
     a0a:	f1 04       	cpc	r15, r1
     a0c:	34 f0       	brlt	.+12     	; 0xa1a <.L147>

00000a0e <.Loc.627>:
        answer[numrecv+2]=receive;
     a0e:	f8 01       	movw	r30, r16
     a10:	e7 55       	subi	r30, 0x57	; 87
     a12:	ff 4f       	sbci	r31, 0xFF	; 255
     a14:	80 83       	st	Z, r24

00000a16 <.Loc.629>:
        numrecv++;
     a16:	0f 5f       	subi	r16, 0xFF	; 255
     a18:	1f 4f       	sbci	r17, 0xFF	; 255

00000a1a <.L147>:
    for(numsent=0;(numsent<cmd->numTx)||(numrecv<cmd->numRx);numsent++) {
     a1a:	ff ef       	ldi	r31, 0xFF	; 255
     a1c:	ef 1a       	sub	r14, r31
     a1e:	ff 0a       	sbc	r15, r31

00000a20 <.Loc.632>:
     a20:	8f ef       	ldi	r24, 0xFF	; 255
     a22:	c8 1a       	sub	r12, r24
     a24:	d8 0a       	sbc	r13, r24

00000a26 <.L146>:
     a26:	89 81       	ldd	r24, Y+1	; 0x01

00000a28 <.Loc.635>:
     a28:	e8 16       	cp	r14, r24
     a2a:	f1 04       	cpc	r15, r1
     a2c:	44 f3       	brlt	.-48     	; 0x9fe <.L148>

00000a2e <.Loc.636>:
     a2e:	8a 81       	ldd	r24, Y+2	; 0x02

00000a30 <.Loc.637>:
     a30:	08 17       	cp	r16, r24
     a32:	11 05       	cpc	r17, r1
     a34:	64 f0       	brlt	.+24     	; 0xa4e <.L150>

00000a36 <.Loc.638>:
    answer[0] = CMD_SPI_MULTI;
     a36:	8d e1       	ldi	r24, 0x1D	; 29
     a38:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

00000a3c <.Loc.640>:
    answer[1] = STATUS_CMD_OK;
     a3c:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

00000a40 <.Loc.642>:
    answer[numrecv+2] = STATUS_CMD_OK;
     a40:	f8 01       	movw	r30, r16
     a42:	e7 55       	subi	r30, 0x57	; 87
     a44:	ff 4f       	sbci	r31, 0xFF	; 255
     a46:	10 82       	st	Z, r1

00000a48 <.Loc.644>:
    CommandAnswer(numrecv+3);
     a48:	83 e0       	ldi	r24, 0x03	; 3
     a4a:	80 0f       	add	r24, r16
     a4c:	ce cf       	rjmp	.-100    	; 0x9ea <.L151>

00000a4e <.L150>:
      if (numsent<cmd->numTx) send=cmd->txData[numsent]; else send=0;
     a4e:	80 e0       	ldi	r24, 0x00	; 0
     a50:	d8 cf       	rjmp	.-80     	; 0xa02 <.L149>

00000a52 <USBFlash>:


/* central command parser */
void USBFlash(char *buf)
{
     a52:	ef 92       	push	r14
     a54:	ff 92       	push	r15
     a56:	0f 93       	push	r16
     a58:	1f 93       	push	r17
     a5a:	cf 93       	push	r28
     a5c:	df 93       	push	r29
     a5e:	ec 01       	movw	r28, r24

00000a60 <.Loc.648>:
  char result = 0;
  int numbytes;
  uint8_t *ptr;
  int i;
  
  USBNWrite(TXC1, 0x00);
     a60:	60 e0       	ldi	r22, 0x00	; 0
     a62:	8b e2       	ldi	r24, 0x2B	; 43

00000a64 <.Loc.653>:
     a64:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00000a68 <.LVL170>:
  
  USBNWrite(TXC1, FLUSH);
     a68:	68 e0       	ldi	r22, 0x08	; 8
     a6a:	8b e2       	ldi	r24, 0x2B	; 43
     a6c:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00000a70 <.LVL171>:
  // first see if this packet is expected by Flash or EEPROM programming
  if(usbprog.longpackage) {
     a70:	80 91 d4 01 	lds	r24, 0x01D4	; 0x8001d4 <usbprog+0x1>
     a74:	90 91 d5 01 	lds	r25, 0x01D5	; 0x8001d5 <usbprog+0x2>

00000a78 <.Loc.657>:
     a78:	89 2b       	or	r24, r25
     a7a:	b9 f0       	breq	.+46     	; 0xaaa <.L153>

00000a7c <.Loc.658>:
    #if DEBUG_ON
    UARTWrite("USBFlash longpackage\r\n ");
    #endif

    if(usbprog.lastcmd == CMD_PROGRAM_FLASH_ISP) {// last operation was flash programming
     a7c:	80 91 d3 01 	lds	r24, 0x01D3	; 0x8001d3 <usbprog>

00000a80 <.Loc.660>:
     a80:	83 31       	cpi	r24, 0x13	; 19
     a82:	21 f4       	brne	.+8      	; 0xa8c <.L154>

00000a84 <.Loc.661>:
       program_fsm((uint8_t*)buf, 0);
     a84:	60 e0       	ldi	r22, 0x00	; 0
     a86:	ce 01       	movw	r24, r28
     a88:	0e 94 88 02 	call	0x510	; 0x510 <program_fsm>

00000a8c <.L154>:
    }

    if(usbprog.lastcmd == CMD_PROGRAM_EEPROM_ISP) {// last operation was eeprom programming
     a8c:	80 91 d3 01 	lds	r24, 0x01D3	; 0x8001d3 <usbprog>

00000a90 <.Loc.664>:
     a90:	85 31       	cpi	r24, 0x15	; 21
     a92:	09 f0       	breq	.+2      	; 0xa96 <.Loc.665>

00000a94 <L0^A>:
     a94:	02 c1       	rjmp	.+516    	; 0xc9a <.L152>

00000a96 <.Loc.665>:
       program_fsm((uint8_t*)buf, 1);
     a96:	61 e0       	ldi	r22, 0x01	; 1
     a98:	ce 01       	movw	r24, r28

00000a9a <.Loc.666>:
      cmd_spi_multi((struct cmd_spi_multi_s *)buf);
      return;
    break;
    }
  }
}
     a9a:	df 91       	pop	r29
     a9c:	cf 91       	pop	r28

00000a9e <.Loc.667>:
     a9e:	1f 91       	pop	r17
     aa0:	0f 91       	pop	r16
     aa2:	ff 90       	pop	r15
     aa4:	ef 90       	pop	r14

00000aa6 <.Loc.668>:
       program_fsm((uint8_t*)buf, 1);
     aa6:	0c 94 88 02 	jmp	0x510	; 0x510 <program_fsm>

00000aaa <.L153>:
    usbprog.lastcmd = buf[0]; // store current command for later use
     aaa:	e8 81       	ld	r30, Y

00000aac <.Loc.672>:
     aac:	e0 93 d3 01 	sts	0x01D3, r30	; 0x8001d3 <usbprog>

00000ab0 <.Loc.673>:
    switch(buf[0]) {
     ab0:	e1 50       	subi	r30, 0x01	; 1
     ab2:	ed 31       	cpi	r30, 0x1D	; 29
     ab4:	08 f0       	brcs	.+2      	; 0xab8 <L0^A+0x2>

00000ab6 <L0^A>:
     ab6:	f1 c0       	rjmp	.+482    	; 0xc9a <.L152>
     ab8:	f0 e0       	ldi	r31, 0x00	; 0
     aba:	e9 52       	subi	r30, 0x29	; 41
     abc:	fd 4e       	sbci	r31, 0xED	; 237
     abe:	0c 94 83 11 	jmp	0x2306	; 0x2306 <__tablejump2__>

00000ac2 <.L178>:
      answer[0] = CMD_SIGN_ON;
     ac2:	81 e0       	ldi	r24, 0x01	; 1
     ac4:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

00000ac8 <.Loc.676>:
      answer[1] = STATUS_CMD_OK;
     ac8:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

00000acc <.Loc.678>:
      answer[2] = 10; // fixed length
     acc:	8a e0       	ldi	r24, 0x0A	; 10
     ace:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <answer+0x2>

00000ad2 <.Loc.680>:
      answer[3] = 'A';
     ad2:	81 e4       	ldi	r24, 0x41	; 65
     ad4:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <answer+0x3>

00000ad8 <.Loc.682>:
      answer[4] = 'V';
     ad8:	86 e5       	ldi	r24, 0x56	; 86
     ada:	80 93 ab 00 	sts	0x00AB, r24	; 0x8000ab <answer+0x4>

00000ade <.Loc.684>:
      answer[5] = 'R';
     ade:	82 e5       	ldi	r24, 0x52	; 82
     ae0:	80 93 ac 00 	sts	0x00AC, r24	; 0x8000ac <answer+0x5>

00000ae4 <.Loc.686>:
      answer[6] = 'I';
     ae4:	89 e4       	ldi	r24, 0x49	; 73
     ae6:	80 93 ad 00 	sts	0x00AD, r24	; 0x8000ad <answer+0x6>

00000aea <.Loc.688>:
      answer[7] = 'S';
     aea:	83 e5       	ldi	r24, 0x53	; 83
     aec:	80 93 ae 00 	sts	0x00AE, r24	; 0x8000ae <answer+0x7>

00000af0 <.Loc.690>:
      answer[8] = 'P';
     af0:	80 e5       	ldi	r24, 0x50	; 80
     af2:	80 93 af 00 	sts	0x00AF, r24	; 0x8000af <answer+0x8>

00000af6 <.Loc.692>:
      answer[9] = '_';
     af6:	8f e5       	ldi	r24, 0x5F	; 95
     af8:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <answer+0x9>

00000afc <.Loc.694>:
      answer[10] = 'M';
     afc:	8d e4       	ldi	r24, 0x4D	; 77
     afe:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <answer+0xa>

00000b02 <.Loc.696>:
      answer[11] = 'K';
     b02:	8b e4       	ldi	r24, 0x4B	; 75
     b04:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <answer+0xb>

00000b08 <.Loc.698>:
      answer[12] = '2';
     b08:	82 e3       	ldi	r24, 0x32	; 50
     b0a:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <answer+0xc>

00000b0e <.Loc.700>:
      CommandAnswer(13);
     b0e:	8d e0       	ldi	r24, 0x0D	; 13

00000b10 <.L210>:
}
     b10:	df 91       	pop	r29
     b12:	cf 91       	pop	r28

00000b14 <.Loc.703>:
     b14:	1f 91       	pop	r17
     b16:	0f 91       	pop	r16
     b18:	ff 90       	pop	r15
     b1a:	ef 90       	pop	r14

00000b1c <.Loc.704>:
      CommandAnswer(2);
     b1c:	0c 94 63 02 	jmp	0x4c6	; 0x4c6 <CommandAnswer>

00000b20 <.L177>:
      answer[0] = CMD_SET_PARAMETER;
     b20:	82 e0       	ldi	r24, 0x02	; 2
     b22:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

00000b26 <.Loc.708>:
      answer[1] = STATUS_CMD_OK;
     b26:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

00000b2a <.Loc.710>:
      switch(buf[1]){
     b2a:	89 81       	ldd	r24, Y+1	; 0x01

00000b2c <.Loc.712>:
     b2c:	88 39       	cpi	r24, 0x98	; 152
     b2e:	91 f0       	breq	.+36     	; 0xb54 <.L179>
     b30:	8e 39       	cpi	r24, 0x9E	; 158
     b32:	39 f4       	brne	.+14     	; 0xb42 <.L180>

00000b34 <.Loc.713>:
          if(buf[2]==0x00)
     b34:	8a 81       	ldd	r24, Y+2	; 0x02
     b36:	81 11       	cpse	r24, r1
     b38:	06 c0       	rjmp	.+12     	; 0xb46 <.L181>

00000b3a <.Loc.715>:
            usbprog.reset_pol=0;
     b3a:	10 92 e1 01 	sts	0x01E1, r1	; 0x8001e1 <usbprog+0xe>
     b3e:	10 92 e0 01 	sts	0x01E0, r1	; 0x8001e0 <usbprog+0xd>

00000b42 <.L180>:
      CommandAnswer(2);
     b42:	82 e0       	ldi	r24, 0x02	; 2
     b44:	e5 cf       	rjmp	.-54     	; 0xb10 <.L210>

00000b46 <.L181>:
            usbprog.reset_pol=1;
     b46:	81 e0       	ldi	r24, 0x01	; 1
     b48:	90 e0       	ldi	r25, 0x00	; 0
     b4a:	90 93 e1 01 	sts	0x01E1, r25	; 0x8001e1 <usbprog+0xe>
     b4e:	80 93 e0 01 	sts	0x01E0, r24	; 0x8001e0 <usbprog+0xd>
     b52:	f7 cf       	rjmp	.-18     	; 0xb42 <.L180>

00000b54 <.L179>:
          if (buf[2]>MAX_SCK_DURATION) buf[2]=MAX_SCK_DURATION;
     b54:	8a 81       	ldd	r24, Y+2	; 0x02

00000b56 <.Loc.722>:
     b56:	84 3a       	cpi	r24, 0xA4	; 164
     b58:	10 f0       	brcs	.+4      	; 0xb5e <.L182>

00000b5a <.Loc.723>:
     b5a:	83 ea       	ldi	r24, 0xA3	; 163
     b5c:	8a 83       	std	Y+2, r24	; 0x02

00000b5e <.L182>:
          if (buf[2] != usbprog.sck_duration)
     b5e:	28 2f       	mov	r18, r24
     b60:	30 e0       	ldi	r19, 0x00	; 0

00000b62 <.Loc.727>:
     b62:	40 91 da 01 	lds	r20, 0x01DA	; 0x8001da <usbprog+0x7>
     b66:	50 91 db 01 	lds	r21, 0x01DB	; 0x8001db <usbprog+0x8>

00000b6a <.Loc.728>:
     b6a:	84 17       	cp	r24, r20
     b6c:	15 06       	cpc	r1, r21
     b6e:	61 f0       	breq	.+24     	; 0xb88 <.L183>

00000b70 <.Loc.729>:
            usbprog.sck_duration = buf[2];
     b70:	30 93 db 01 	sts	0x01DB, r19	; 0x8001db <usbprog+0x8>
     b74:	20 93 da 01 	sts	0x01DA, r18	; 0x8001da <usbprog+0x7>

00000b78 <.Loc.731>:
            eeprom_write_byte(&ee_sck_duration, usbprog.sck_duration);
     b78:	60 91 da 01 	lds	r22, 0x01DA	; 0x8001da <usbprog+0x7>
     b7c:	70 91 db 01 	lds	r23, 0x01DB	; 0x8001db <usbprog+0x8>

00000b80 <.Loc.733>:
     b80:	80 e0       	ldi	r24, 0x00	; 0
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	0e 94 c1 12 	call	0x2582	; 0x2582 <eeprom_write_byte>

00000b88 <.L183>:
          spi_init();
     b88:	0e 94 18 01 	call	0x230	; 0x230 <spi_init>

00000b8c <.LVL178>:
          break;
     b8c:	da cf       	rjmp	.-76     	; 0xb42 <.L180>

00000b8e <.L176>:
      answer[0] = CMD_GET_PARAMETER;
     b8e:	83 e0       	ldi	r24, 0x03	; 3
     b90:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

00000b94 <.Loc.739>:
      answer[1] = STATUS_CMD_OK;
     b94:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

00000b98 <.Loc.741>:
      switch(buf[1]){
     b98:	89 81       	ldd	r24, Y+1	; 0x01

00000b9a <.Loc.743>:
     b9a:	84 39       	cpi	r24, 0x94	; 148
     b9c:	a1 f0       	breq	.+40     	; 0xbc6 <.L184>
     b9e:	38 f4       	brcc	.+14     	; 0xbae <.L185>
     ba0:	81 39       	cpi	r24, 0x91	; 145
     ba2:	61 f0       	breq	.+24     	; 0xbbc <.L187>
     ba4:	82 39       	cpi	r24, 0x92	; 146
     ba6:	51 f0       	breq	.+20     	; 0xbbc <.L187>

00000ba8 <.L189>:
          answer[2] = 0x00; // FIXME all is not perfect!
     ba8:	10 92 a9 00 	sts	0x00A9, r1	; 0x8000a9 <answer+0x2>
     bac:	0a c0       	rjmp	.+20     	; 0xbc2 <.L191>

00000bae <.L185>:
      switch(buf[1]){
     bae:	88 39       	cpi	r24, 0x98	; 152
     bb0:	d9 f7       	brne	.-10     	; 0xba8 <.L189>

00000bb2 <.Loc.747>:
          answer[2] = usbprog.sck_duration;
     bb2:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <usbprog+0x7>
     bb6:	90 91 db 01 	lds	r25, 0x01DB	; 0x8001db <usbprog+0x8>
     bba:	01 c0       	rjmp	.+2      	; 0xbbe <.L206>

00000bbc <.L187>:
          answer[2] = 9;
     bbc:	89 e0       	ldi	r24, 0x09	; 9

00000bbe <.L206>:
          answer[2] = usbprog.sck_duration;
     bbe:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <answer+0x2>

00000bc2 <.L191>:
      CommandAnswer(3);
     bc2:	83 e0       	ldi	r24, 0x03	; 3
     bc4:	a5 cf       	rjmp	.-182    	; 0xb10 <.L210>

00000bc6 <.L184>:
          answer[2] = 50;
     bc6:	82 e3       	ldi	r24, 0x32	; 50
     bc8:	fa cf       	rjmp	.-12     	; 0xbbe <.L206>

00000bca <.L175>:
      answer[0] = CMD_OSCCAL;
     bca:	85 e0       	ldi	r24, 0x05	; 5

00000bcc <.L211>:
      answer[0] = CMD_CHIP_ERASE_ISP;
     bcc:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

00000bd0 <.Loc.760>:
      answer[1] = STATUS_CMD_OK;
     bd0:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

00000bd4 <.Loc.762>:
      CommandAnswer(2);
     bd4:	b6 cf       	rjmp	.-148    	; 0xb42 <.L180>

00000bd6 <.L159>:
  spi_inout(data);
     bd6:	8a 81       	ldd	r24, Y+2	; 0x02
     bd8:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000bdc <.LBB244>:
     bdc:	8b 81       	ldd	r24, Y+3	; 0x03
     bde:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000be2 <.LBB246>:
     be2:	8c 81       	ldd	r24, Y+4	; 0x04
     be4:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000be8 <.LBE246>:
      result = spi_in();
     be8:	0e 94 da 01 	call	0x3b4	; 0x3b4 <spi_in>

00000bec <.LVL183>:
      answer[0] = CMD_READ_OSCCAL_ISP;
     bec:	9c e1       	ldi	r25, 0x1C	; 28

00000bee <.L212>:
      answer[0] = CMD_READ_SIGNATURE_ISP;
     bee:	90 93 a7 00 	sts	0x00A7, r25	; 0x8000a7 <answer>

00000bf2 <.Loc.781>:
      answer[1] = STATUS_CMD_OK;
     bf2:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

00000bf6 <.Loc.783>:
      answer[2] = result;
     bf6:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <answer+0x2>

00000bfa <.Loc.785>:
      answer[3] = STATUS_CMD_OK;
     bfa:	10 92 aa 00 	sts	0x00AA, r1	; 0x8000aa <answer+0x3>

00000bfe <.Loc.787>:
      CommandAnswer(4);
     bfe:	84 e0       	ldi	r24, 0x04	; 4

00000c00 <.Loc.788>:
     c00:	87 cf       	rjmp	.-242    	; 0xb10 <.L210>

00000c02 <.L174>:
      pgmmode.address = buf[1];
     c02:	89 81       	ldd	r24, Y+1	; 0x01
     c04:	90 e0       	ldi	r25, 0x00	; 0
     c06:	a0 e0       	ldi	r26, 0x00	; 0
     c08:	b0 e0       	ldi	r27, 0x00	; 0

00000c0a <.Loc.792>:
     c0a:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <pgmmode+0x9>
     c0e:	90 93 9a 00 	sts	0x009A, r25	; 0x80009a <pgmmode+0xa>
     c12:	a0 93 9b 00 	sts	0x009B, r26	; 0x80009b <pgmmode+0xb>
     c16:	b0 93 9c 00 	sts	0x009C, r27	; 0x80009c <pgmmode+0xc>

00000c1a <.Loc.793>:
      pgmmode.address = (pgmmode.address << 8) | buf[2];
     c1a:	ba 2f       	mov	r27, r26
     c1c:	a9 2f       	mov	r26, r25
     c1e:	98 2f       	mov	r25, r24
     c20:	88 27       	eor	r24, r24

00000c22 <.Loc.795>:
     c22:	2a 81       	ldd	r18, Y+2	; 0x02

00000c24 <.Loc.796>:
     c24:	82 2b       	or	r24, r18

00000c26 <.Loc.797>:
     c26:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <pgmmode+0x9>
     c2a:	90 93 9a 00 	sts	0x009A, r25	; 0x80009a <pgmmode+0xa>
     c2e:	a0 93 9b 00 	sts	0x009B, r26	; 0x80009b <pgmmode+0xb>
     c32:	b0 93 9c 00 	sts	0x009C, r27	; 0x80009c <pgmmode+0xc>

00000c36 <.Loc.798>:
      pgmmode.address = (pgmmode.address << 8) | buf[3];
     c36:	ba 2f       	mov	r27, r26
     c38:	a9 2f       	mov	r26, r25
     c3a:	98 2f       	mov	r25, r24
     c3c:	88 27       	eor	r24, r24

00000c3e <.Loc.800>:
     c3e:	2b 81       	ldd	r18, Y+3	; 0x03

00000c40 <.Loc.801>:
     c40:	82 2b       	or	r24, r18

00000c42 <.Loc.802>:
     c42:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <pgmmode+0x9>
     c46:	90 93 9a 00 	sts	0x009A, r25	; 0x80009a <pgmmode+0xa>
     c4a:	a0 93 9b 00 	sts	0x009B, r26	; 0x80009b <pgmmode+0xb>
     c4e:	b0 93 9c 00 	sts	0x009C, r27	; 0x80009c <pgmmode+0xc>

00000c52 <.Loc.803>:
      pgmmode.address = (pgmmode.address << 8) | buf[4];
     c52:	ba 2f       	mov	r27, r26
     c54:	a9 2f       	mov	r26, r25
     c56:	98 2f       	mov	r25, r24
     c58:	88 27       	eor	r24, r24

00000c5a <.Loc.805>:
     c5a:	2c 81       	ldd	r18, Y+4	; 0x04

00000c5c <.Loc.806>:
     c5c:	82 2b       	or	r24, r18

00000c5e <.Loc.807>:
     c5e:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <pgmmode+0x9>
     c62:	90 93 9a 00 	sts	0x009A, r25	; 0x80009a <pgmmode+0xa>
     c66:	a0 93 9b 00 	sts	0x009B, r26	; 0x80009b <pgmmode+0xb>
     c6a:	b0 93 9c 00 	sts	0x009C, r27	; 0x80009c <pgmmode+0xc>

00000c6e <.Loc.808>:
      pgmmode.large_flash = buf[1] & 0x80 ? 1 : 0;
     c6e:	99 81       	ldd	r25, Y+1	; 0x01

00000c70 <.Loc.810>:
     c70:	80 91 a4 00 	lds	r24, 0x00A4	; 0x8000a4 <pgmmode+0x14>
     c74:	97 fb       	bst	r25, 7
     c76:	82 f9       	bld	r24, 2
     c78:	80 93 a4 00 	sts	0x00A4, r24	; 0x8000a4 <pgmmode+0x14>

00000c7c <.Loc.811>:
      answer[0] = CMD_LOAD_ADDRESS;
     c7c:	86 e0       	ldi	r24, 0x06	; 6
     c7e:	a6 cf       	rjmp	.-180    	; 0xbcc <.L211>

00000c80 <.L173>:
}
     c80:	df 91       	pop	r29
     c82:	cf 91       	pop	r28

00000c84 <.Loc.816>:
     c84:	1f 91       	pop	r17
     c86:	0f 91       	pop	r16
     c88:	ff 90       	pop	r15
     c8a:	ef 90       	pop	r14

00000c8c <.Loc.817>:
      avrupdate_start();
     c8c:	0c 94 ea 10 	jmp	0x21d4	; 0x21d4 <avrupdate_start>

00000c90 <.L172>:
      answer[0] = CMD_RESET_PROTECTION;
     c90:	8a e0       	ldi	r24, 0x0A	; 10
     c92:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

00000c96 <.Loc.821>:
      answer[1] = STATUS_CMD_OK;  // this command returns always ok!
     c96:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

00000c9a <.L152>:
}
     c9a:	df 91       	pop	r29
     c9c:	cf 91       	pop	r28
     c9e:	1f 91       	pop	r17
     ca0:	0f 91       	pop	r16
     ca2:	ff 90       	pop	r15
     ca4:	ef 90       	pop	r14
     ca6:	08 95       	ret

00000ca8 <.L171>:
      cmd_enter_progmode((struct cmd_enter_progmode_s *)buf);
     ca8:	ce 01       	movw	r24, r28
     caa:	0e 94 4e 04 	call	0x89c	; 0x89c <cmd_enter_progmode>

00000cae <.LVL190>:
      pgmmode.poll_address_valid = 0;
     cae:	80 91 a4 00 	lds	r24, 0x00A4	; 0x8000a4 <pgmmode+0x14>
     cb2:	8e 7f       	andi	r24, 0xFE	; 254
     cb4:	80 93 a4 00 	sts	0x00A4, r24	; 0x8000a4 <pgmmode+0x14>

00000cb8 <.Loc.830>:
      pgmmode.status = STATUS_CMD_OK;
     cb8:	10 92 a1 00 	sts	0x00A1, r1	; 0x8000a1 <pgmmode+0x11>

00000cbc <.Loc.832>:
      return;
     cbc:	ee cf       	rjmp	.-36     	; 0xc9a <.L152>

00000cbe <.L170>:
      spi_cmd(0x4d, 0x0000, 0);
     cbe:	40 e0       	ldi	r20, 0x00	; 0
     cc0:	60 e0       	ldi	r22, 0x00	; 0
     cc2:	70 e0       	ldi	r23, 0x00	; 0
     cc4:	8d e4       	ldi	r24, 0x4D	; 77
     cc6:	0e 94 c4 01 	call	0x388	; 0x388 <spi_cmd>

00000cca <.LVL191>:
      LED_off;
     cca:	dc 98       	cbi	0x1b, 4	; 27

00000ccc <.Loc.836>:
      RESET_high;
     ccc:	c0 9a       	sbi	0x18, 0	; 24

00000cce <.Loc.837>:
      spi_idle();
     cce:	0e 94 67 01 	call	0x2ce	; 0x2ce <spi_idle>

00000cd2 <.LVL192>:
      answer[0] = CMD_LEAVE_PROGMODE_ISP;
     cd2:	81 e1       	ldi	r24, 0x11	; 17
     cd4:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

00000cd8 <.Loc.840>:
      answer[1] = STATUS_CMD_OK;
     cd8:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

00000cdc <.Loc.842>:
      CommandAnswer(2);
     cdc:	82 e0       	ldi	r24, 0x02	; 2
     cde:	0e 94 63 02 	call	0x4c6	; 0x4c6 <CommandAnswer>

00000ce2 <.LVL193>:
      if(usbprog.avrstudio==0)
     ce2:	80 91 de 01 	lds	r24, 0x01DE	; 0x8001de <usbprog+0xb>
     ce6:	90 91 df 01 	lds	r25, 0x01DF	; 0x8001df <usbprog+0xc>

00000cea <.Loc.845>:
     cea:	89 2b       	or	r24, r25
     cec:	b1 f6       	brne	.-84     	; 0xc9a <.L152>

00000cee <.L207>:
	usbprog.datatogl = 0;
     cee:	10 92 d9 01 	sts	0x01D9, r1	; 0x8001d9 <usbprog+0x6>
     cf2:	10 92 d8 01 	sts	0x01D8, r1	; 0x8001d8 <usbprog+0x5>
     cf6:	d1 cf       	rjmp	.-94     	; 0xc9a <.L152>

00000cf8 <.L169>:
  spi_inout(data);
     cf8:	8b 81       	ldd	r24, Y+3	; 0x03
     cfa:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000cfe <.LBB250>:
     cfe:	8c 81       	ldd	r24, Y+4	; 0x04
     d00:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000d04 <.LBB252>:
     d04:	80 e0       	ldi	r24, 0x00	; 0
     d06:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000d0a <.LBB254>:
     d0a:	80 e0       	ldi	r24, 0x00	; 0
     d0c:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000d10 <.LBE254>:
      wait_ms(buf[1]);
     d10:	89 81       	ldd	r24, Y+1	; 0x01
     d12:	90 e0       	ldi	r25, 0x00	; 0
     d14:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <wait_ms>

00000d18 <.LVL200>:
      answer[0] = CMD_CHIP_ERASE_ISP;
     d18:	82 e1       	ldi	r24, 0x12	; 18
     d1a:	58 cf       	rjmp	.-336    	; 0xbcc <.L211>

00000d1c <.L168>:
      pgmmode.numbytes = (buf[1] << 8) | (buf[2]);
     d1c:	89 81       	ldd	r24, Y+1	; 0x01
     d1e:	9a 81       	ldd	r25, Y+2	; 0x02
     d20:	98 27       	eor	r25, r24
     d22:	89 27       	eor	r24, r25
     d24:	98 27       	eor	r25, r24
     d26:	90 93 91 00 	sts	0x0091, r25	; 0x800091 <pgmmode+0x1>
     d2a:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <pgmmode>

00000d2e <.Loc.871>:
      pgmmode.mode = buf[3];
     d2e:	8b 81       	ldd	r24, Y+3	; 0x03
     d30:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <pgmmode+0x2>

00000d34 <.Loc.873>:
      pgmmode.delay = buf[4];
     d34:	8c 81       	ldd	r24, Y+4	; 0x04
     d36:	80 93 93 00 	sts	0x0093, r24	; 0x800093 <pgmmode+0x3>

00000d3a <.Loc.875>:
      pgmmode.cmd1 = buf[5];
     d3a:	8d 81       	ldd	r24, Y+5	; 0x05
     d3c:	80 93 94 00 	sts	0x0094, r24	; 0x800094 <pgmmode+0x4>

00000d40 <.Loc.877>:
      pgmmode.cmd2 = buf[6];
     d40:	8e 81       	ldd	r24, Y+6	; 0x06
     d42:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <pgmmode+0x5>

00000d46 <.Loc.879>:
      pgmmode.cmd3 = buf[7];
     d46:	8f 81       	ldd	r24, Y+7	; 0x07
     d48:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <pgmmode+0x6>

00000d4c <.Loc.881>:
      pgmmode.poll1 = buf[8];
     d4c:	88 85       	ldd	r24, Y+8	; 0x08
     d4e:	80 93 97 00 	sts	0x0097, r24	; 0x800097 <pgmmode+0x7>

00000d52 <.Loc.883>:
      pgmmode.poll2 = buf[9];
     d52:	89 85       	ldd	r24, Y+9	; 0x09
     d54:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <pgmmode+0x8>

00000d58 <.Loc.885>:
      pgmmode.pageaddress = pgmmode.address;
     d58:	80 91 99 00 	lds	r24, 0x0099	; 0x800099 <pgmmode+0x9>
     d5c:	90 91 9a 00 	lds	r25, 0x009A	; 0x80009a <pgmmode+0xa>
     d60:	a0 91 9b 00 	lds	r26, 0x009B	; 0x80009b <pgmmode+0xb>
     d64:	b0 91 9c 00 	lds	r27, 0x009C	; 0x80009c <pgmmode+0xc>
     d68:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <pgmmode+0xd>
     d6c:	90 93 9e 00 	sts	0x009E, r25	; 0x80009e <pgmmode+0xe>
     d70:	a0 93 9f 00 	sts	0x009F, r26	; 0x80009f <pgmmode+0xf>
     d74:	b0 93 a0 00 	sts	0x00A0, r27	; 0x8000a0 <pgmmode+0x10>

00000d78 <.Loc.887>:
      usbprog.cmdpackage = 1;
     d78:	81 e0       	ldi	r24, 0x01	; 1
     d7a:	90 e0       	ldi	r25, 0x00	; 0
     d7c:	90 93 d7 01 	sts	0x01D7, r25	; 0x8001d7 <usbprog+0x4>
     d80:	80 93 d6 01 	sts	0x01D6, r24	; 0x8001d6 <usbprog+0x3>

00000d84 <.Loc.889>:
      program_fsm((uint8_t*)buf, 0);
     d84:	60 e0       	ldi	r22, 0x00	; 0

00000d86 <.L208>:
      program_fsm((uint8_t*)buf, 1);
     d86:	ce 01       	movw	r24, r28
     d88:	0e 94 88 02 	call	0x510	; 0x510 <program_fsm>

00000d8c <.LVL201>:
      usbprog.cmdpackage = 0;
     d8c:	10 92 d7 01 	sts	0x01D7, r1	; 0x8001d7 <usbprog+0x4>
     d90:	10 92 d6 01 	sts	0x01D6, r1	; 0x8001d6 <usbprog+0x3>

00000d94 <.Loc.893>:
      return;
     d94:	82 cf       	rjmp	.-252    	; 0xc9a <.L152>

00000d96 <.L167>:
      pgmmode.numbytes = ((buf[1] << 8) | (buf[2])) + 1; // number of bytes
     d96:	89 81       	ldd	r24, Y+1	; 0x01
     d98:	9a 81       	ldd	r25, Y+2	; 0x02
     d9a:	98 27       	eor	r25, r24
     d9c:	89 27       	eor	r24, r25
     d9e:	98 27       	eor	r25, r24

00000da0 <.Loc.896>:
     da0:	9c 01       	movw	r18, r24
     da2:	2f 5f       	subi	r18, 0xFF	; 255
     da4:	3f 4f       	sbci	r19, 0xFF	; 255

00000da6 <.Loc.897>:
     da6:	30 93 91 00 	sts	0x0091, r19	; 0x800091 <pgmmode+0x1>
     daa:	20 93 90 00 	sts	0x0090, r18	; 0x800090 <pgmmode>

00000dae <.Loc.898>:
      pgmmode.cmd3 = buf[3];  // read command
     dae:	2b 81       	ldd	r18, Y+3	; 0x03

00000db0 <.Loc.900>:
     db0:	20 93 96 00 	sts	0x0096, r18	; 0x800096 <pgmmode+0x6>

00000db4 <.Loc.901>:
      while (numbytes--) {
     db4:	07 ea       	ldi	r16, 0xA7	; 167
     db6:	10 e0       	ldi	r17, 0x00	; 0
     db8:	ec 01       	movw	r28, r24

00000dba <.Loc.903>:
     dba:	c9 55       	subi	r28, 0x59	; 89
     dbc:	df 4f       	sbci	r29, 0xFF	; 255

00000dbe <.Loc.904>:
          pgmmode.cmd3 = 0x20;
     dbe:	30 e2       	ldi	r19, 0x20	; 32
     dc0:	f3 2e       	mov	r15, r19

00000dc2 <.Loc.905>:
          pgmmode.cmd3 = 0x28;
     dc2:	48 e2       	ldi	r20, 0x28	; 40
     dc4:	e4 2e       	mov	r14, r20

00000dc6 <.L193>:
      while (numbytes--) {
     dc6:	c0 17       	cp	r28, r16
     dc8:	d1 07       	cpc	r29, r17
     dca:	21 f5       	brne	.+72     	; 0xe14 <.L197>

00000dcc <.Loc.908>:
      answer[0] = CMD_READ_FLASH_ISP;
     dcc:	84 e1       	ldi	r24, 0x14	; 20
     dce:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

00000dd2 <.Loc.910>:
      answer[1] = STATUS_CMD_OK;
     dd2:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

00000dd6 <.Loc.912>:
      answer[pgmmode.numbytes + 1] = STATUS_CMD_OK;
     dd6:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <pgmmode>
     dda:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <pgmmode+0x1>

00000dde <.Loc.914>:
     dde:	fc 01       	movw	r30, r24
     de0:	e8 55       	subi	r30, 0x58	; 88
     de2:	ff 4f       	sbci	r31, 0xFF	; 255
     de4:	10 82       	st	Z, r1

00000de6 <.Loc.915>:
      if(pgmmode.numbytes > 62){
     de6:	8f 33       	cpi	r24, 0x3F	; 63
     de8:	91 05       	cpc	r25, r1
     dea:	08 f4       	brcc	.+2      	; 0xdee <.L209>

00000dec <L0^A>:
     dec:	5d c0       	rjmp	.+186    	; 0xea8 <.L198>

00000dee <.L209>:
        CommandAnswer(64);
     dee:	80 e4       	ldi	r24, 0x40	; 64
     df0:	0e 94 63 02 	call	0x4c6	; 0x4c6 <CommandAnswer>

00000df4 <.LVL207>:
        pgmmode.numbytes = pgmmode.numbytes - 62;
     df4:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <pgmmode>
     df8:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <pgmmode+0x1>
     dfc:	ce 97       	sbiw	r24, 0x3e	; 62

00000dfe <.Loc.920>:
     dfe:	90 93 91 00 	sts	0x0091, r25	; 0x800091 <pgmmode+0x1>
     e02:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <pgmmode>

00000e06 <.Loc.921>:
        usbprog.fragmentnumber = 1;
     e06:	81 e0       	ldi	r24, 0x01	; 1
     e08:	90 e0       	ldi	r25, 0x00	; 0
     e0a:	90 93 dd 01 	sts	0x01DD, r25	; 0x8001dd <usbprog+0xa>
     e0e:	80 93 dc 01 	sts	0x01DC, r24	; 0x8001dc <usbprog+0x9>

00000e12 <.Loc.923>:
	return; 
     e12:	43 cf       	rjmp	.-378    	; 0xc9a <.L152>

00000e14 <.L197>:
        if (pgmmode.large_flash && (pgmmode.address >> 16) != pgmmode.ext_address){
     e14:	80 91 a4 00 	lds	r24, 0x00A4	; 0x8000a4 <pgmmode+0x14>

00000e18 <.Loc.926>:
     e18:	82 ff       	sbrs	r24, 2
     e1a:	1c c0       	rjmp	.+56     	; 0xe54 <.L194>

00000e1c <.Loc.927>:
     e1c:	60 91 99 00 	lds	r22, 0x0099	; 0x800099 <pgmmode+0x9>
     e20:	70 91 9a 00 	lds	r23, 0x009A	; 0x80009a <pgmmode+0xa>
     e24:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <pgmmode+0xb>
     e28:	90 91 9c 00 	lds	r25, 0x009C	; 0x80009c <pgmmode+0xc>
     e2c:	bc 01       	movw	r22, r24
     e2e:	88 27       	eor	r24, r24
     e30:	99 27       	eor	r25, r25

00000e32 <.Loc.928>:
     e32:	20 91 a5 00 	lds	r18, 0x00A5	; 0x8000a5 <pgmmode+0x15>
     e36:	30 91 a6 00 	lds	r19, 0x00A6	; 0x8000a6 <pgmmode+0x16>

00000e3a <.Loc.929>:
     e3a:	26 17       	cp	r18, r22
     e3c:	37 07       	cpc	r19, r23
     e3e:	18 06       	cpc	r1, r24
     e40:	19 06       	cpc	r1, r25
     e42:	41 f0       	breq	.+16     	; 0xe54 <.L194>

00000e44 <.Loc.930>:
          pgmmode.ext_address = pgmmode.address >> 16;
     e44:	70 93 a6 00 	sts	0x00A6, r23	; 0x8000a6 <pgmmode+0x16>
     e48:	60 93 a5 00 	sts	0x00A5, r22	; 0x8000a5 <pgmmode+0x15>

00000e4c <.Loc.932>:
          spi_cmd(0x4d, pgmmode.ext_address, 0);
     e4c:	40 e0       	ldi	r20, 0x00	; 0
     e4e:	8d e4       	ldi	r24, 0x4D	; 77
     e50:	0e 94 c4 01 	call	0x388	; 0x388 <spi_cmd>

00000e54 <.L194>:
        *ptr++ = spi_cmd(pgmmode.cmd3, pgmmode.address, 0);
     e54:	60 91 99 00 	lds	r22, 0x0099	; 0x800099 <pgmmode+0x9>
     e58:	70 91 9a 00 	lds	r23, 0x009A	; 0x80009a <pgmmode+0xa>
     e5c:	40 e0       	ldi	r20, 0x00	; 0
     e5e:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <pgmmode+0x6>
     e62:	0e 94 c4 01 	call	0x388	; 0x388 <spi_cmd>

00000e66 <.LVL210>:
     e66:	f8 01       	movw	r30, r16
     e68:	82 83       	std	Z+2, r24	; 0x02

00000e6a <.Loc.936>:
        if(pgmmode.cmd3 == 0x20){
     e6a:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <pgmmode+0x6>
     e6e:	80 32       	cpi	r24, 0x20	; 32
     e70:	29 f4       	brne	.+10     	; 0xe7c <.L195>

00000e72 <.Loc.938>:
          pgmmode.cmd3 = 0x28;
     e72:	e0 92 96 00 	sts	0x0096, r14	; 0x800096 <pgmmode+0x6>

00000e76 <.L196>:
     e76:	0f 5f       	subi	r16, 0xFF	; 255
     e78:	1f 4f       	sbci	r17, 0xFF	; 255

00000e7a <.Loc.940>:
     e7a:	a5 cf       	rjmp	.-182    	; 0xdc6 <.L193>

00000e7c <.L195>:
          pgmmode.cmd3 = 0x20;
     e7c:	f0 92 96 00 	sts	0x0096, r15	; 0x800096 <pgmmode+0x6>

00000e80 <.Loc.943>:
          pgmmode.address++;
     e80:	80 91 99 00 	lds	r24, 0x0099	; 0x800099 <pgmmode+0x9>
     e84:	90 91 9a 00 	lds	r25, 0x009A	; 0x80009a <pgmmode+0xa>
     e88:	a0 91 9b 00 	lds	r26, 0x009B	; 0x80009b <pgmmode+0xb>
     e8c:	b0 91 9c 00 	lds	r27, 0x009C	; 0x80009c <pgmmode+0xc>
     e90:	01 96       	adiw	r24, 0x01	; 1
     e92:	a1 1d       	adc	r26, r1
     e94:	b1 1d       	adc	r27, r1
     e96:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <pgmmode+0x9>
     e9a:	90 93 9a 00 	sts	0x009A, r25	; 0x80009a <pgmmode+0xa>
     e9e:	a0 93 9b 00 	sts	0x009B, r26	; 0x80009b <pgmmode+0xb>
     ea2:	b0 93 9c 00 	sts	0x009C, r27	; 0x80009c <pgmmode+0xc>
     ea6:	e7 cf       	rjmp	.-50     	; 0xe76 <.L196>

00000ea8 <.L198>:
	CommandAnswer(pgmmode.numbytes + 2);
     ea8:	8e 5f       	subi	r24, 0xFE	; 254
     eaa:	0e 94 63 02 	call	0x4c6	; 0x4c6 <CommandAnswer>

00000eae <.LVL214>:
	usbprog.datatogl=0; 
     eae:	1f cf       	rjmp	.-450    	; 0xcee <.L207>

00000eb0 <.L161>:
  spi_inout(data);
     eb0:	8a 81       	ldd	r24, Y+2	; 0x02
     eb2:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000eb6 <.LBB258>:
     eb6:	8b 81       	ldd	r24, Y+3	; 0x03
     eb8:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000ebc <.LBB260>:
     ebc:	8c 81       	ldd	r24, Y+4	; 0x04
     ebe:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000ec2 <.LBE260>:
      result = spi_in();
     ec2:	0e 94 da 01 	call	0x3b4	; 0x3b4 <spi_in>

00000ec6 <.LVL219>:
      answer[0] = CMD_READ_LOCK_ISP;
     ec6:	9a e1       	ldi	r25, 0x1A	; 26
     ec8:	92 ce       	rjmp	.-732    	; 0xbee <.L212>

00000eca <.L162>:
  spi_inout(data);
     eca:	89 81       	ldd	r24, Y+1	; 0x01
     ecc:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000ed0 <.LBB264>:
     ed0:	8a 81       	ldd	r24, Y+2	; 0x02
     ed2:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000ed6 <.LBB266>:
     ed6:	8b 81       	ldd	r24, Y+3	; 0x03
     ed8:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000edc <.LBB268>:
     edc:	8c 81       	ldd	r24, Y+4	; 0x04
     ede:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00000ee2 <.LBE268>:
      answer[0] = CMD_PROGRAM_LOCK_ISP;
     ee2:	89 e1       	ldi	r24, 0x19	; 25

00000ee4 <.L213>:
      answer[0] = CMD_PROGRAM_FUSE_ISP;
     ee4:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

00000ee8 <.Loc.984>:
      answer[1] = STATUS_CMD_OK;
     ee8:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

00000eec <.Loc.986>:
      answer[2] = STATUS_CMD_OK;
     eec:	5d ce       	rjmp	.-838    	; 0xba8 <.L189>

00000eee <.L166>:
      pgmmode.numbytes = (buf[1] << 8) | (buf[2]);
     eee:	89 81       	ldd	r24, Y+1	; 0x01
     ef0:	9a 81       	ldd	r25, Y+2	; 0x02
     ef2:	98 27       	eor	r25, r24
     ef4:	89 27       	eor	r24, r25
     ef6:	98 27       	eor	r25, r24
     ef8:	90 93 91 00 	sts	0x0091, r25	; 0x800091 <pgmmode+0x1>
     efc:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <pgmmode>

00000f00 <.Loc.990>:
      pgmmode.mode = buf[3];
     f00:	8b 81       	ldd	r24, Y+3	; 0x03
     f02:	80 93 92 00 	sts	0x0092, r24	; 0x800092 <pgmmode+0x2>

00000f06 <.Loc.992>:
      pgmmode.delay = buf[4];
     f06:	8c 81       	ldd	r24, Y+4	; 0x04
     f08:	80 93 93 00 	sts	0x0093, r24	; 0x800093 <pgmmode+0x3>

00000f0c <.Loc.994>:
      pgmmode.cmd1 = buf[5];
     f0c:	8d 81       	ldd	r24, Y+5	; 0x05
     f0e:	80 93 94 00 	sts	0x0094, r24	; 0x800094 <pgmmode+0x4>

00000f12 <.Loc.996>:
      pgmmode.cmd2 = buf[6];
     f12:	8e 81       	ldd	r24, Y+6	; 0x06
     f14:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <pgmmode+0x5>

00000f18 <.Loc.998>:
      pgmmode.cmd3 = buf[7];
     f18:	8f 81       	ldd	r24, Y+7	; 0x07
     f1a:	80 93 96 00 	sts	0x0096, r24	; 0x800096 <pgmmode+0x6>

00000f1e <.Loc.1000>:
      pgmmode.poll1 = buf[8];
     f1e:	88 85       	ldd	r24, Y+8	; 0x08
     f20:	80 93 97 00 	sts	0x0097, r24	; 0x800097 <pgmmode+0x7>

00000f24 <.Loc.1002>:
      pgmmode.poll2 = buf[9];
     f24:	89 85       	ldd	r24, Y+9	; 0x09
     f26:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <pgmmode+0x8>

00000f2a <.Loc.1004>:
      pgmmode.pageaddress = pgmmode.address;
     f2a:	80 91 99 00 	lds	r24, 0x0099	; 0x800099 <pgmmode+0x9>
     f2e:	90 91 9a 00 	lds	r25, 0x009A	; 0x80009a <pgmmode+0xa>
     f32:	a0 91 9b 00 	lds	r26, 0x009B	; 0x80009b <pgmmode+0xb>
     f36:	b0 91 9c 00 	lds	r27, 0x009C	; 0x80009c <pgmmode+0xc>
     f3a:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <pgmmode+0xd>
     f3e:	90 93 9e 00 	sts	0x009E, r25	; 0x80009e <pgmmode+0xe>
     f42:	a0 93 9f 00 	sts	0x009F, r26	; 0x80009f <pgmmode+0xf>
     f46:	b0 93 a0 00 	sts	0x00A0, r27	; 0x8000a0 <pgmmode+0x10>

00000f4a <.Loc.1006>:
      usbprog.cmdpackage = 1;
     f4a:	81 e0       	ldi	r24, 0x01	; 1
     f4c:	90 e0       	ldi	r25, 0x00	; 0
     f4e:	90 93 d7 01 	sts	0x01D7, r25	; 0x8001d7 <usbprog+0x4>
     f52:	80 93 d6 01 	sts	0x01D6, r24	; 0x8001d6 <usbprog+0x3>

00000f56 <.Loc.1008>:
      program_fsm((uint8_t*)buf, 1);
     f56:	61 e0       	ldi	r22, 0x01	; 1
     f58:	16 cf       	rjmp	.-468    	; 0xd86 <.L208>

00000f5a <.L165>:
      pgmmode.numbytes = ((buf[1] << 8) | (buf[2])) + 1; // number of bytes
     f5a:	89 81       	ldd	r24, Y+1	; 0x01
     f5c:	9a 81       	ldd	r25, Y+2	; 0x02
     f5e:	98 27       	eor	r25, r24
     f60:	89 27       	eor	r24, r25
     f62:	98 27       	eor	r25, r24

00000f64 <.Loc.1011>:
     f64:	9c 01       	movw	r18, r24
     f66:	2f 5f       	subi	r18, 0xFF	; 255
     f68:	3f 4f       	sbci	r19, 0xFF	; 255

00000f6a <.Loc.1012>:
     f6a:	30 93 91 00 	sts	0x0091, r19	; 0x800091 <pgmmode+0x1>
     f6e:	20 93 90 00 	sts	0x0090, r18	; 0x800090 <pgmmode>

00000f72 <.Loc.1013>:
      pgmmode.cmd3 = buf[3];  // read command
     f72:	2b 81       	ldd	r18, Y+3	; 0x03

00000f74 <.Loc.1015>:
     f74:	20 93 96 00 	sts	0x0096, r18	; 0x800096 <pgmmode+0x6>

00000f78 <.Loc.1016>:
      while(numbytes--) {
     f78:	07 ea       	ldi	r16, 0xA7	; 167
     f7a:	10 e0       	ldi	r17, 0x00	; 0
     f7c:	ec 01       	movw	r28, r24

00000f7e <.Loc.1019>:
     f7e:	c9 55       	subi	r28, 0x59	; 89
     f80:	df 4f       	sbci	r29, 0xFF	; 255

00000f82 <.L199>:
     f82:	0c 17       	cp	r16, r28
     f84:	1d 07       	cpc	r17, r29
     f86:	11 f5       	brne	.+68     	; 0xfcc <.L200>

00000f88 <.Loc.1022>:
      answer[0] = CMD_READ_EEPROM_ISP;
     f88:	86 e1       	ldi	r24, 0x16	; 22
     f8a:	80 93 a7 00 	sts	0x00A7, r24	; 0x8000a7 <answer>

00000f8e <.Loc.1024>:
      answer[1] = STATUS_CMD_OK;
     f8e:	10 92 a8 00 	sts	0x00A8, r1	; 0x8000a8 <answer+0x1>

00000f92 <.Loc.1026>:
      answer[pgmmode.numbytes + 1] = STATUS_CMD_OK;
     f92:	80 91 90 00 	lds	r24, 0x0090	; 0x800090 <pgmmode>
     f96:	90 91 91 00 	lds	r25, 0x0091	; 0x800091 <pgmmode+0x1>

00000f9a <.Loc.1028>:
     f9a:	fc 01       	movw	r30, r24
     f9c:	e8 55       	subi	r30, 0x58	; 88
     f9e:	ff 4f       	sbci	r31, 0xFF	; 255
     fa0:	10 82       	st	Z, r1

00000fa2 <.Loc.1029>:
      if(pgmmode.numbytes > 62){
     fa2:	8f 33       	cpi	r24, 0x3F	; 63
     fa4:	91 05       	cpc	r25, r1
     fa6:	08 f0       	brcs	.+2      	; 0xfaa <.Loc.1031>

00000fa8 <L0^A>:
     fa8:	22 cf       	rjmp	.-444    	; 0xdee <.L209>

00000faa <.Loc.1031>:
	CommandAnswer(pgmmode.numbytes + 2);
     faa:	8e 5f       	subi	r24, 0xFE	; 254
     fac:	0e 94 63 02 	call	0x4c6	; 0x4c6 <CommandAnswer>

00000fb0 <.LVL228>:
	if(usbprog.datatogl ==1)
     fb0:	80 91 d8 01 	lds	r24, 0x01D8	; 0x8001d8 <usbprog+0x5>
     fb4:	90 91 d9 01 	lds	r25, 0x01D9	; 0x8001d9 <usbprog+0x6>

00000fb8 <.Loc.1034>:
     fb8:	01 97       	sbiw	r24, 0x01	; 1
     fba:	09 f4       	brne	.+2      	; 0xfbe <.Loc.1035>

00000fbc <L0^A>:
     fbc:	98 ce       	rjmp	.-720    	; 0xcee <.L207>

00000fbe <.Loc.1035>:
	usbprog.datatogl = 1;
     fbe:	81 e0       	ldi	r24, 0x01	; 1
     fc0:	90 e0       	ldi	r25, 0x00	; 0
     fc2:	90 93 d9 01 	sts	0x01D9, r25	; 0x8001d9 <usbprog+0x6>
     fc6:	80 93 d8 01 	sts	0x01D8, r24	; 0x8001d8 <usbprog+0x5>
     fca:	67 ce       	rjmp	.-818    	; 0xc9a <.L152>

00000fcc <.L200>:
        *ptr++ = spi_cmd(pgmmode.cmd3, pgmmode.address, 0);
     fcc:	60 91 99 00 	lds	r22, 0x0099	; 0x800099 <pgmmode+0x9>
     fd0:	70 91 9a 00 	lds	r23, 0x009A	; 0x80009a <pgmmode+0xa>
     fd4:	40 e0       	ldi	r20, 0x00	; 0
     fd6:	80 91 96 00 	lds	r24, 0x0096	; 0x800096 <pgmmode+0x6>
     fda:	0e 94 c4 01 	call	0x388	; 0x388 <spi_cmd>

00000fde <.LVL230>:
     fde:	f8 01       	movw	r30, r16
     fe0:	82 83       	std	Z+2, r24	; 0x02

00000fe2 <.Loc.1040>:
        pgmmode.address++;
     fe2:	80 91 99 00 	lds	r24, 0x0099	; 0x800099 <pgmmode+0x9>
     fe6:	90 91 9a 00 	lds	r25, 0x009A	; 0x80009a <pgmmode+0xa>
     fea:	a0 91 9b 00 	lds	r26, 0x009B	; 0x80009b <pgmmode+0xb>
     fee:	b0 91 9c 00 	lds	r27, 0x009C	; 0x80009c <pgmmode+0xc>
     ff2:	01 96       	adiw	r24, 0x01	; 1
     ff4:	a1 1d       	adc	r26, r1
     ff6:	b1 1d       	adc	r27, r1
     ff8:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <pgmmode+0x9>
     ffc:	90 93 9a 00 	sts	0x009A, r25	; 0x80009a <pgmmode+0xa>
    1000:	a0 93 9b 00 	sts	0x009B, r26	; 0x80009b <pgmmode+0xb>
    1004:	b0 93 9c 00 	sts	0x009C, r27	; 0x80009c <pgmmode+0xc>
    1008:	0f 5f       	subi	r16, 0xFF	; 255
    100a:	1f 4f       	sbci	r17, 0xFF	; 255

0000100c <.Loc.1042>:
    100c:	ba cf       	rjmp	.-140    	; 0xf82 <.L199>

0000100e <.L164>:
  spi_inout(data);
    100e:	89 81       	ldd	r24, Y+1	; 0x01
    1010:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00001014 <.LBB272>:
    1014:	8a 81       	ldd	r24, Y+2	; 0x02
    1016:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

0000101a <.LBB274>:
    101a:	8b 81       	ldd	r24, Y+3	; 0x03
    101c:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00001020 <.LBB276>:
    1020:	8c 81       	ldd	r24, Y+4	; 0x04
    1022:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00001026 <.LBE276>:
      answer[0] = CMD_PROGRAM_FUSE_ISP;
    1026:	87 e1       	ldi	r24, 0x17	; 23
    1028:	5d cf       	rjmp	.-326    	; 0xee4 <.L213>

0000102a <.L163>:
  spi_inout(data);
    102a:	8a 81       	ldd	r24, Y+2	; 0x02
    102c:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00001030 <.LBB280>:
    1030:	8b 81       	ldd	r24, Y+3	; 0x03
    1032:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00001036 <.LBB282>:
    1036:	8c 81       	ldd	r24, Y+4	; 0x04
    1038:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

0000103c <.LBE282>:
      result = spi_in();
    103c:	0e 94 da 01 	call	0x3b4	; 0x3b4 <spi_in>

00001040 <.LVL241>:
      answer[0] = CMD_READ_FUSE_ISP;
    1040:	98 e1       	ldi	r25, 0x18	; 24
    1042:	d5 cd       	rjmp	.-1110   	; 0xbee <.L212>

00001044 <.L160>:
  spi_inout(data);
    1044:	8a 81       	ldd	r24, Y+2	; 0x02
    1046:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

0000104a <.LBB286>:
    104a:	8b 81       	ldd	r24, Y+3	; 0x03
    104c:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00001050 <.LBB288>:
    1050:	8c 81       	ldd	r24, Y+4	; 0x04
    1052:	0e 94 74 01 	call	0x2e8	; 0x2e8 <spi_inout>

00001056 <.LBE288>:
      result = spi_in();
    1056:	0e 94 da 01 	call	0x3b4	; 0x3b4 <spi_in>

0000105a <.LVL246>:
      answer[0] = CMD_READ_SIGNATURE_ISP;
    105a:	9b e1       	ldi	r25, 0x1B	; 27
    105c:	c8 cd       	rjmp	.-1136   	; 0xbee <.L212>

0000105e <.L157>:
      usbprog.avrstudio=0;  // only avrdude use this command // this is not true! also at89 @ avr studio
    105e:	10 92 df 01 	sts	0x01DF, r1	; 0x8001df <usbprog+0xc>
    1062:	10 92 de 01 	sts	0x01DE, r1	; 0x8001de <usbprog+0xb>

00001066 <.Loc.1099>:
      cmd_spi_multi((struct cmd_spi_multi_s *)buf);
    1066:	ce 01       	movw	r24, r28

00001068 <.Loc.1100>:
}
    1068:	df 91       	pop	r29
    106a:	cf 91       	pop	r28

0000106c <.Loc.1101>:
    106c:	1f 91       	pop	r17
    106e:	0f 91       	pop	r16
    1070:	ff 90       	pop	r15
    1072:	ef 90       	pop	r14

00001074 <.Loc.1102>:
      cmd_spi_multi((struct cmd_spi_multi_s *)buf);
    1074:	0c 94 da 04 	jmp	0x9b4	; 0x9b4 <cmd_spi_multi>

00001078 <_USBNInitEP0>:

FunctionInfo  USBNFunctionInfo;

void _USBNInitEP0(void)
{
  EP0rx.usbnCommand   = RXC0;
    1078:	e2 e2       	ldi	r30, 0x22	; 34
    107a:	f2 e0       	ldi	r31, 0x02	; 2
    107c:	87 e2       	ldi	r24, 0x27	; 39
    107e:	81 83       	std	Z+1, r24	; 0x01

00001080 <.Loc.3>:
  EP0rx.usbnData      = RXD0;
    1080:	85 e2       	ldi	r24, 0x25	; 37
    1082:	80 83       	st	Z, r24

00001084 <.Loc.5>:
  EP0rx.usbnControl   = EPC0;
    1084:	20 e2       	ldi	r18, 0x20	; 32
    1086:	22 83       	std	Z+2, r18	; 0x02

00001088 <.Loc.7>:
  EP0rx.DataPid	      = 0;
    1088:	13 82       	std	Z+3, r1	; 0x03

0000108a <.Loc.10>:
  EP0rx.usbnfifo      = 8;
    108a:	88 e0       	ldi	r24, 0x08	; 8
    108c:	90 e0       	ldi	r25, 0x00	; 0
    108e:	95 83       	std	Z+5, r25	; 0x05
    1090:	84 83       	std	Z+4, r24	; 0x04

00001092 <.Loc.11>:


  EP0tx.usbnCommand   = TXC0;
    1092:	e6 e1       	ldi	r30, 0x16	; 22
    1094:	f2 e0       	ldi	r31, 0x02	; 2
    1096:	33 e2       	ldi	r19, 0x23	; 35
    1098:	31 83       	std	Z+1, r19	; 0x01

0000109a <.Loc.13>:
  EP0tx.usbnData      = TXD0;
    109a:	31 e2       	ldi	r19, 0x21	; 33
    109c:	30 83       	st	Z, r19

0000109e <.Loc.15>:
  EP0tx.usbnControl   = EPC0;
    109e:	22 83       	std	Z+2, r18	; 0x02

000010a0 <.Loc.17>:
  EP0tx.DataPid	      = 0;
    10a0:	13 82       	std	Z+3, r1	; 0x03

000010a2 <.Loc.19>:
  EP0tx.usbnfifo      = 8;
    10a2:	95 83       	std	Z+5, r25	; 0x05
    10a4:	84 83       	std	Z+4, r24	; 0x04

000010a6 <.Loc.21>:

} 
    10a6:	08 95       	ret

000010a8 <_USBNNackEvent>:
void _USBNNackEvent(void)
{
  unsigned char event;
  //void (*ptr)();
  
  event = USBNRead(NAKEV);
    10a8:	8e e0       	ldi	r24, 0x0E	; 14
    10aa:	0c 94 2e 0b 	jmp	0x165c	; 0x165c <USBNRead>

000010ae <_USBNAlternateEvent>:
    USBNRead(TXS3);                        // get transmitter status
  }
}

void _USBNAlternateEvent(void)
{
    10ae:	cf 93       	push	r28

000010b0 <.Loc.27>:
  unsigned char event;
  event = USBNRead(ALTEV);
    10b0:	88 e0       	ldi	r24, 0x08	; 8
    10b2:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

000010b6 <.LVL1>:
    10b6:	c8 2f       	mov	r28, r24

000010b8 <.Loc.30>:
  //USBNDebug("alt event\r\n");

  if(event & ALT_RESET)
    10b8:	86 ff       	sbrs	r24, 6
    10ba:	18 c0       	rjmp	.+48     	; 0x10ec <.L4>

000010bc <.Loc.32>:
  {
    USBNWrite(NFSR,RST_ST);                   // NFS = NodeReset
    10bc:	60 e0       	ldi	r22, 0x00	; 0
    10be:	85 e0       	ldi	r24, 0x05	; 5

000010c0 <.Loc.33>:
    10c0:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000010c4 <.LVL4>:
    USBNWrite(FAR,AD_EN+0); 
    10c4:	60 e8       	ldi	r22, 0x80	; 128
    10c6:	84 e0       	ldi	r24, 0x04	; 4
    10c8:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000010cc <.LVL5>:
    USBNWrite(EPC0,0x00);
    10cc:	60 e0       	ldi	r22, 0x00	; 0
    10ce:	80 e2       	ldi	r24, 0x20	; 32
    10d0:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000010d4 <.LVL6>:
    USBNWrite(TXC0,FLUSH);
    10d4:	68 e0       	ldi	r22, 0x08	; 8
    10d6:	83 e2       	ldi	r24, 0x23	; 35
    10d8:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000010dc <.LVL7>:
    USBNWrite(RXC0,RX_EN);                    // allow reception
    10dc:	61 e0       	ldi	r22, 0x01	; 1
    10de:	87 e2       	ldi	r24, 0x27	; 39
    10e0:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000010e4 <.LVL8>:
    USBNWrite(NFSR,OPR_ST);                   // NFS = NodeOperational
    10e4:	62 e0       	ldi	r22, 0x02	; 2
    10e6:	85 e0       	ldi	r24, 0x05	; 5
    10e8:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000010ec <.L4>:
  	//USBNDebug("reset\r\n");
  }
  if(event & ALT_SD3)
    10ec:	c4 ff       	sbrs	r28, 4
    10ee:	04 c0       	rjmp	.+8      	; 0x10f8 <.L5>

000010f0 <.Loc.41>:
  {
    USBNWrite(ALTMSK,ALT_RESUME+ALT_RESET);   // adjust interrupts
    10f0:	60 ec       	ldi	r22, 0xC0	; 192
    10f2:	89 e0       	ldi	r24, 0x09	; 9
    10f4:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000010f8 <.L5>:
  /*
    USBNWrite(NFSR,SUS_ST);                   // enter suspend state
  	USBNDebug("sd3\r\n");
  */
  }
  if(event & ALT_RESUME)
    10f8:	c7 ff       	sbrs	r28, 7
    10fa:	05 c0       	rjmp	.+10     	; 0x1106 <.L3>

000010fc <.Loc.44>:
  {
    USBNWrite(ALTMSK,ALT_SD3+ALT_RESET+ALT_RESUME);
    10fc:	60 ed       	ldi	r22, 0xD0	; 208
    10fe:	89 e0       	ldi	r24, 0x09	; 9

00001100 <.Loc.45>:
  if(event & ALT_EOP)
  {
  	//USBNDebug("eop\r\n");
  }

}
    1100:	cf 91       	pop	r28

00001102 <.Loc.46>:
    USBNWrite(ALTMSK,ALT_SD3+ALT_RESET+ALT_RESUME);
    1102:	0c 94 45 0b 	jmp	0x168a	; 0x168a <USBNWrite>

00001106 <.L3>:
}
    1106:	cf 91       	pop	r28

00001108 <.Loc.48>:
    1108:	08 95       	ret

0000110a <_USBNReceive>:
// ********************************************************************
// Communicate with the FIFOs         
// ********************************************************************


void _USBNReceive(EPInfo* ep)
    110a:	08 95       	ret

0000110c <_USBNTransmit>:
  */ 
}


void _USBNTransmit(EPInfo* ep)
{
    110c:	0f 93       	push	r16
    110e:	1f 93       	push	r17
    1110:	cf 93       	push	r28
    1112:	df 93       	push	r29
    1114:	ec 01       	movw	r28, r24

00001116 <.Loc.52>:
  int i;
  if(ep->Size > 0)
    1116:	88 85       	ldd	r24, Y+8	; 0x08
    1118:	99 85       	ldd	r25, Y+9	; 0x09

0000111a <.Loc.55>:
    111a:	18 16       	cp	r1, r24
    111c:	19 06       	cpc	r1, r25
    111e:	a4 f5       	brge	.+104    	; 0x1188 <.L14>

00001120 <.Loc.56>:
  {
    if(ep->Index < ep->Size)
    1120:	2e 81       	ldd	r18, Y+6	; 0x06
    1122:	3f 81       	ldd	r19, Y+7	; 0x07
    1124:	28 17       	cp	r18, r24
    1126:	39 07       	cpc	r19, r25
    1128:	6c f4       	brge	.+26     	; 0x1144 <.L16>

0000112a <.Loc.58>:
    {
      
      USBNWrite(TXC0,FLUSH);       //send data to the FIFO
    112a:	68 e0       	ldi	r22, 0x08	; 8
    112c:	83 e2       	ldi	r24, 0x23	; 35
    112e:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001132 <.LVL16>:
    1132:	08 e0       	ldi	r16, 0x08	; 8
    1134:	10 e0       	ldi	r17, 0x00	; 0

00001136 <.L17>:
      //USBNDebug(" ");
      for(i=0;((i < 8) && (ep->Index < ep->Size)); i++)
    1136:	8e 81       	ldd	r24, Y+6	; 0x06
    1138:	9f 81       	ldd	r25, Y+7	; 0x07

0000113a <.Loc.63>:
    113a:	28 85       	ldd	r18, Y+8	; 0x08
    113c:	39 85       	ldd	r19, Y+9	; 0x09
    113e:	82 17       	cp	r24, r18
    1140:	93 07       	cpc	r25, r19
    1142:	2c f0       	brlt	.+10     	; 0x114e <.L19>

00001144 <.L16>:
        ep->Index++;
      }

      // if end of multipaket
      if(ep->Size<=ep->Index)
	USBNWrite(RXC0,RX_EN);
    1144:	61 e0       	ldi	r22, 0x01	; 1
    1146:	87 e2       	ldi	r24, 0x27	; 39
    1148:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

0000114c <.LVL19>:
    114c:	15 c0       	rjmp	.+42     	; 0x1178 <.L20>

0000114e <.L19>:
        USBNWrite(TXD0,ep->Buf[ep->Index]);
    114e:	ea 85       	ldd	r30, Y+10	; 0x0a
    1150:	fb 85       	ldd	r31, Y+11	; 0x0b
    1152:	e8 0f       	add	r30, r24
    1154:	f9 1f       	adc	r31, r25
    1156:	60 81       	ld	r22, Z
    1158:	81 e2       	ldi	r24, 0x21	; 33
    115a:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

0000115e <.LVL21>:
        ep->Index++;
    115e:	8e 81       	ldd	r24, Y+6	; 0x06
    1160:	9f 81       	ldd	r25, Y+7	; 0x07
    1162:	01 96       	adiw	r24, 0x01	; 1
    1164:	9f 83       	std	Y+7, r25	; 0x07
    1166:	8e 83       	std	Y+6, r24	; 0x06

00001168 <.Loc.68>:
      for(i=0;((i < 8) && (ep->Index < ep->Size)); i++)
    1168:	01 50       	subi	r16, 0x01	; 1
    116a:	10 40       	sbci	r17, 0x00	; 0

0000116c <.Loc.70>:
    116c:	21 f7       	brne	.-56     	; 0x1136 <.L17>

0000116e <.Loc.71>:
      if(ep->Size<=ep->Index)
    116e:	28 85       	ldd	r18, Y+8	; 0x08
    1170:	39 85       	ldd	r19, Y+9	; 0x09
    1172:	82 17       	cp	r24, r18
    1174:	93 07       	cpc	r25, r19
    1176:	34 f7       	brge	.-52     	; 0x1144 <.L16>

00001178 <.L20>:
    }

    // toggle mechanism
    if(ep->DataPid == 1)
    {
      USBNWrite(ep->usbnCommand,TX_TOGL+TX_EN);
    1178:	89 81       	ldd	r24, Y+1	; 0x01

0000117a <.Loc.75>:
    if(ep->DataPid == 1)
    117a:	9b 81       	ldd	r25, Y+3	; 0x03
    117c:	91 30       	cpi	r25, 0x01	; 1
    117e:	49 f4       	brne	.+18     	; 0x1192 <.L21>

00001180 <.Loc.76>:
      USBNWrite(ep->usbnCommand,TX_TOGL+TX_EN);
    1180:	65 e0       	ldi	r22, 0x05	; 5
    1182:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001186 <.LVL25>:
      ep->DataPid=0;
    1186:	1b 82       	std	Y+3, r1	; 0x03

00001188 <.L14>:
    {
      USBNWrite(ep->usbnCommand,TX_EN);
      ep->DataPid=1;
    }
  }
}
    1188:	df 91       	pop	r29
    118a:	cf 91       	pop	r28

0000118c <.Loc.80>:
    118c:	1f 91       	pop	r17
    118e:	0f 91       	pop	r16
    1190:	08 95       	ret

00001192 <.L21>:
      USBNWrite(ep->usbnCommand,TX_EN);
    1192:	61 e0       	ldi	r22, 0x01	; 1
    1194:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001198 <.LVL28>:
      ep->DataPid=1;
    1198:	81 e0       	ldi	r24, 0x01	; 1
    119a:	8b 83       	std	Y+3, r24	; 0x03

0000119c <.Loc.84>:
}
    119c:	f5 cf       	rjmp	.-22     	; 0x1188 <.L14>

0000119e <_USBNTransmitFIFO0>:
{
    119e:	cf 93       	push	r28

000011a0 <.Loc.86>:
  txstat = USBNRead(TXS0);                        // get transmitter status
    11a0:	82 e2       	ldi	r24, 0x22	; 34
    11a2:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

000011a6 <.LVL29>:
    11a6:	c8 2f       	mov	r28, r24

000011a8 <.Loc.89>:
  if(txstat & TX_DONE)                            // if transmit completed
    11a8:	85 ff       	sbrs	r24, 5
    11aa:	1b c0       	rjmp	.+54     	; 0x11e2 <.L22>

000011ac <.Loc.91>:
    USBNWrite(TXC0,FLUSH);                        // flush TX0 and disable
    11ac:	68 e0       	ldi	r22, 0x08	; 8
    11ae:	83 e2       	ldi	r24, 0x23	; 35

000011b0 <.Loc.92>:
    11b0:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000011b4 <.LVL32>:
    if(txstat & ACK_STAT)                         // ACK received
    11b4:	c6 ff       	sbrs	r28, 6
    11b6:	10 c0       	rjmp	.+32     	; 0x11d8 <.L24>

000011b8 <.Loc.95>:
      if(EP0tx.Index < EP0tx.Size)
    11b8:	20 91 1c 02 	lds	r18, 0x021C	; 0x80021c <EP0tx+0x6>
    11bc:	30 91 1d 02 	lds	r19, 0x021D	; 0x80021d <EP0tx+0x7>
    11c0:	80 91 1e 02 	lds	r24, 0x021E	; 0x80021e <EP0tx+0x8>
    11c4:	90 91 1f 02 	lds	r25, 0x021F	; 0x80021f <EP0tx+0x9>
    11c8:	28 17       	cp	r18, r24
    11ca:	39 07       	cpc	r19, r25
    11cc:	2c f4       	brge	.+10     	; 0x11d8 <.L24>

000011ce <.Loc.97>:
        _USBNTransmit(&EP0tx);
    11ce:	86 e1       	ldi	r24, 0x16	; 22
    11d0:	92 e0       	ldi	r25, 0x02	; 2

000011d2 <.Loc.98>:
}
    11d2:	cf 91       	pop	r28

000011d4 <.Loc.99>:
        _USBNTransmit(&EP0tx);
    11d4:	0c 94 86 08 	jmp	0x110c	; 0x110c <_USBNTransmit>

000011d8 <.L24>:
	USBNWrite(RXC0,RX_EN);               // re-enable the receiver
    11d8:	61 e0       	ldi	r22, 0x01	; 1
    11da:	87 e2       	ldi	r24, 0x27	; 39

000011dc <.Loc.101>:
}
    11dc:	cf 91       	pop	r28

000011de <.Loc.102>:
	USBNWrite(RXC0,RX_EN);               // re-enable the receiver
    11de:	0c 94 45 0b 	jmp	0x168a	; 0x168a <USBNWrite>

000011e2 <.L22>:
}
    11e2:	cf 91       	pop	r28
    11e4:	08 95       	ret

000011e6 <_USBNTransmitEvent>:
  event = USBNRead(TXEV);
    11e6:	8a e0       	ldi	r24, 0x0A	; 10
    11e8:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

000011ec <.LVL38>:
  if(event & TX_FIFO0) _USBNTransmitFIFO0();
    11ec:	80 fd       	sbrc	r24, 0

000011ee <.Loc.111>:
    11ee:	0c 94 cf 08 	jmp	0x119e	; 0x119e <_USBNTransmitFIFO0>

000011f2 <.LVL39>:
  else if(event & TX_FIFO1) 
    11f2:	81 ff       	sbrs	r24, 1
    11f4:	0c c0       	rjmp	.+24     	; 0x120e <.L30>

000011f6 <.Loc.114>:
    USBNRead(TXS1);
    11f6:	8a e2       	ldi	r24, 0x2A	; 42

000011f8 <.Loc.115>:
    11f8:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

000011fc <.LVL41>:
    if(txfifos.tx1==1){
    11fc:	80 91 0d 02 	lds	r24, 0x020D	; 0x80020d <txfifos>
    1200:	81 30       	cpi	r24, 0x01	; 1
    1202:	59 f4       	brne	.+22     	; 0x121a <.L28>

00001204 <.Loc.118>:
      (*ptr)();
    1204:	e0 91 10 02 	lds	r30, 0x0210	; 0x800210 <txfifos+0x3>
    1208:	f0 91 11 02 	lds	r31, 0x0211	; 0x800211 <txfifos+0x4>
    120c:	09 94       	ijmp

0000120e <.L30>:
    USBNRead(TXS2);                        // get transmitter status
    120e:	82 e3       	ldi	r24, 0x32	; 50

00001210 <.Loc.122>:
    1210:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

00001214 <.LVL45>:
    USBNRead(TXS3);                        // get transmitter status
    1214:	8a e3       	ldi	r24, 0x3A	; 58
    1216:	0c 94 2e 0b 	jmp	0x165c	; 0x165c <USBNRead>

0000121a <.L28>:
}
    121a:	08 95       	ret

0000121c <_USBNSetAddress>:
  }
}
*/

void _USBNSetAddress(DeviceRequest *req)
{
    121c:	cf 93       	push	r28
    121e:	df 93       	push	r29
    1220:	ec 01       	movw	r28, r24

00001222 <.Loc.127>:
 // set the address
  USBNWrite(EPC0,DEF);
    1222:	60 e4       	ldi	r22, 0x40	; 64
    1224:	80 e2       	ldi	r24, 0x20	; 32

00001226 <.Loc.128>:
    1226:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

0000122a <.LVL49>:
  USBNWrite(FAR,AD_EN+req->wValue);
    122a:	6a 81       	ldd	r22, Y+2	; 0x02
    122c:	60 58       	subi	r22, 0x80	; 128
    122e:	84 e0       	ldi	r24, 0x04	; 4
    1230:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001234 <.LVL50>:
  USBNFunctionInfo.Address = req->wValue;
    1234:	8a 81       	ldd	r24, Y+2	; 0x02
    1236:	80 93 e6 01 	sts	0x01E6, r24	; 0x8001e6 <USBNFunctionInfo>

0000123a <.Loc.132>:
}
    123a:	df 91       	pop	r29
    123c:	cf 91       	pop	r28

0000123e <.Loc.133>:
    123e:	08 95       	ret

00001240 <_USBNGetDescriptor>:


void _USBNGetDescriptor(DeviceRequest *req)
{
    1240:	cf 93       	push	r28
    1242:	df 93       	push	r29
    1244:	00 d0       	rcall	.+0      	; 0x1246 <L0^A>

00001246 <L0^A>:
    1246:	00 d0       	rcall	.+0      	; 0x1248 <L0^A>

00001248 <L0^A>:
    1248:	cd b7       	in	r28, 0x3d	; 61
    124a:	de b7       	in	r29, 0x3e	; 62
    124c:	fc 01       	movw	r30, r24

0000124e <.Loc.136>:
  unsigned char index =  req->wValue;
    124e:	82 81       	ldd	r24, Z+2	; 0x02
    1250:	93 81       	ldd	r25, Z+3	; 0x03

00001252 <.Loc.138>:
  unsigned char type = req->wValue >> 8;
    1252:	29 2f       	mov	r18, r25
    1254:	33 27       	eor	r19, r19

00001256 <.Loc.140>:

  EP0tx.Index = 0;
    1256:	10 92 1d 02 	sts	0x021D, r1	; 0x80021d <EP0tx+0x7>
    125a:	10 92 1c 02 	sts	0x021C, r1	; 0x80021c <EP0tx+0x6>

0000125e <.Loc.142>:
  EP0tx.DataPid = 1;
    125e:	41 e0       	ldi	r20, 0x01	; 1
    1260:	40 93 19 02 	sts	0x0219, r20	; 0x800219 <EP0tx+0x3>

00001264 <.Loc.144>:
  switch (type)
    1264:	22 30       	cpi	r18, 0x02	; 2
    1266:	31 05       	cpc	r19, r1
    1268:	89 f1       	breq	.+98     	; 0x12cc <.L34>
    126a:	23 30       	cpi	r18, 0x03	; 3
    126c:	31 05       	cpc	r19, r1
    126e:	09 f4       	brne	.+2      	; 0x1272 <L0^A+0x2>

00001270 <L0^A>:
    1270:	43 c0       	rjmp	.+134    	; 0x12f8 <.L35>
    1272:	21 30       	cpi	r18, 0x01	; 1
    1274:	31 05       	cpc	r19, r1
    1276:	01 f5       	brne	.+64     	; 0x12b8 <.L36>

00001278 <.Loc.145>:
  {
    case DEVICE:
      //#if DEBUG 
      //USBNDebug("DEVICE DESCRIPTOR\n\r");  
      //#endif
      EP0tx.Size = DeviceDescriptor.bLength;
    1278:	80 91 f0 01 	lds	r24, 0x01F0	; 0x8001f0 <DeviceDescriptor>

0000127c <.Loc.147>:
    127c:	90 e0       	ldi	r25, 0x00	; 0
    127e:	90 93 1f 02 	sts	0x021F, r25	; 0x80021f <EP0tx+0x9>
    1282:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <EP0tx+0x8>

00001286 <.Loc.148>:
      EP0tx.Buf = (unsigned char*)(&DeviceDescriptor);
    1286:	80 ef       	ldi	r24, 0xF0	; 240
    1288:	91 e0       	ldi	r25, 0x01	; 1
    128a:	90 93 21 02 	sts	0x0221, r25	; 0x800221 <EP0tx+0xb>
    128e:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <EP0tx+0xa>

00001292 <.Loc.150>:
      
      // first get descriptor request is
      // always be answered with first 8 unsigned chars of dev descriptor
      //SendHex(req->wLength);
      
      if(req->wLength==0x08)
    1292:	86 81       	ldd	r24, Z+6	; 0x06
    1294:	97 81       	ldd	r25, Z+7	; 0x07

00001296 <.Loc.152>:
    1296:	88 30       	cpi	r24, 0x08	; 8
    1298:	91 05       	cpc	r25, r1
    129a:	59 f4       	brne	.+22     	; 0x12b2 <.L37>

0000129c <.Loc.153>:
	req->wLength=0x40;
    129c:	80 e4       	ldi	r24, 0x40	; 64
    129e:	90 e0       	ldi	r25, 0x00	; 0
    12a0:	97 83       	std	Z+7, r25	; 0x07
    12a2:	86 83       	std	Z+6, r24	; 0x06

000012a4 <.L38>:


      if(req->wLength==0x40)
        EP0tx.Size = 8;
    12a4:	88 e0       	ldi	r24, 0x08	; 8
    12a6:	90 e0       	ldi	r25, 0x00	; 0

000012a8 <.L41>:
      #endif

      if(index >0)
      {
	EP0tx.Buf = (unsigned char*)&(FinalStringArray[index][0]);
	EP0tx.Size = EP0tx.Buf[0];
    12a8:	90 93 1f 02 	sts	0x021F, r25	; 0x80021f <EP0tx+0x9>
    12ac:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <EP0tx+0x8>
    12b0:	03 c0       	rjmp	.+6      	; 0x12b8 <.L36>

000012b2 <.L37>:
      if(req->wLength==0x40)
    12b2:	80 34       	cpi	r24, 0x40	; 64
    12b4:	91 05       	cpc	r25, r1
    12b6:	b1 f3       	breq	.-20     	; 0x12a4 <.L38>

000012b8 <.L36>:
    break;
  }
  //if (EP0rx.Buf[7]==0)                  //if less than 256 req'd  
  //  if (EP0tx.Size > EP0rx.Buf[6]) EP0tx.Size = EP0rx.Buf[6];

  _USBNTransmit(&EP0tx);
    12b8:	86 e1       	ldi	r24, 0x16	; 22
    12ba:	92 e0       	ldi	r25, 0x02	; 2

000012bc <.Loc.162>:
}
    12bc:	0f 90       	pop	r0
    12be:	0f 90       	pop	r0
    12c0:	0f 90       	pop	r0
    12c2:	0f 90       	pop	r0
    12c4:	df 91       	pop	r29
    12c6:	cf 91       	pop	r28

000012c8 <.Loc.163>:
  _USBNTransmit(&EP0tx);
    12c8:	0c 94 86 08 	jmp	0x110c	; 0x110c <_USBNTransmit>

000012cc <.L34>:
      EP0tx.Size =req->wLength;
    12cc:	26 81       	ldd	r18, Z+6	; 0x06
    12ce:	37 81       	ldd	r19, Z+7	; 0x07

000012d0 <.Loc.166>:
    12d0:	30 93 1f 02 	sts	0x021F, r19	; 0x80021f <EP0tx+0x9>
    12d4:	20 93 1e 02 	sts	0x021E, r18	; 0x80021e <EP0tx+0x8>

000012d8 <.Loc.167>:
      EP0tx.Buf = (unsigned char*)&(FinalConfigurationArray[index][0]);
    12d8:	99 27       	eor	r25, r25

000012da <.Loc.169>:
    12da:	88 0f       	add	r24, r24
    12dc:	99 1f       	adc	r25, r25
    12de:	e0 91 ee 01 	lds	r30, 0x01EE	; 0x8001ee <FinalConfigurationArray>
    12e2:	f0 91 ef 01 	lds	r31, 0x01EF	; 0x8001ef <FinalConfigurationArray+0x1>

000012e6 <.Loc.170>:
    12e6:	e8 0f       	add	r30, r24
    12e8:	f9 1f       	adc	r31, r25

000012ea <.Loc.171>:
    12ea:	80 81       	ld	r24, Z
    12ec:	91 81       	ldd	r25, Z+1	; 0x01

000012ee <.L40>:
	EP0tx.Buf = (unsigned char*)lang;
    12ee:	90 93 21 02 	sts	0x0221, r25	; 0x800221 <EP0tx+0xb>
    12f2:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <EP0tx+0xa>
    12f6:	e0 cf       	rjmp	.-64     	; 0x12b8 <.L36>

000012f8 <.L35>:
      if(index >0)
    12f8:	81 15       	cp	r24, r1
    12fa:	99 f0       	breq	.+38     	; 0x1322 <.L39>

000012fc <.Loc.176>:
	EP0tx.Buf = (unsigned char*)&(FinalStringArray[index][0]);
    12fc:	99 27       	eor	r25, r25

000012fe <.Loc.178>:
    12fe:	88 0f       	add	r24, r24
    1300:	99 1f       	adc	r25, r25

00001302 <.Loc.179>:
    1302:	e0 91 ec 01 	lds	r30, 0x01EC	; 0x8001ec <FinalStringArray>
    1306:	f0 91 ed 01 	lds	r31, 0x01ED	; 0x8001ed <FinalStringArray+0x1>

0000130a <.Loc.180>:
    130a:	e8 0f       	add	r30, r24
    130c:	f9 1f       	adc	r31, r25
    130e:	01 90       	ld	r0, Z+
    1310:	f0 81       	ld	r31, Z
    1312:	e0 2d       	mov	r30, r0

00001314 <.Loc.181>:
    1314:	f0 93 21 02 	sts	0x0221, r31	; 0x800221 <EP0tx+0xb>
    1318:	e0 93 20 02 	sts	0x0220, r30	; 0x800220 <EP0tx+0xa>

0000131c <.Loc.182>:
	EP0tx.Size = EP0tx.Buf[0];
    131c:	80 81       	ld	r24, Z
    131e:	90 e0       	ldi	r25, 0x00	; 0
    1320:	c3 cf       	rjmp	.-122    	; 0x12a8 <.L41>

00001322 <.L39>:
	EP0tx.Size=4;
    1322:	84 e0       	ldi	r24, 0x04	; 4
    1324:	90 e0       	ldi	r25, 0x00	; 0

00001326 <.Loc.187>:
    1326:	90 93 1f 02 	sts	0x021F, r25	; 0x80021f <EP0tx+0x9>
    132a:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <EP0tx+0x8>

0000132e <.Loc.188>:
	EP0tx.Buf = (unsigned char*)lang;
    132e:	ce 01       	movw	r24, r28
    1330:	01 96       	adiw	r24, 0x01	; 1
    1332:	dd cf       	rjmp	.-70     	; 0x12ee <.L40>

00001334 <_USBNGetStatus>:
  char tmp[]={0x01,0x00};
  EP0tx.Size=4;
  EP0tx.Buf=tmp;
  _USBNTransmit(&EP0tx);
  */
}
    1334:	08 95       	ret

00001336 <_USBNSetConfiguration>:
  // define EPaddresses
  // save the configuration index
  // load fct pointer list for out eps
  //

USBNWrite(TXC1,FLUSH);
    1336:	68 e0       	ldi	r22, 0x08	; 8
    1338:	8b e2       	ldi	r24, 0x2B	; 43

0000133a <.Loc.194>:
    133a:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

0000133e <.LVL72>:
USBNWrite(EPC1,EP_EN+0x02);      // enable EP1 at adr 1
    133e:	62 e1       	ldi	r22, 0x12	; 18
    1340:	88 e2       	ldi	r24, 0x28	; 40
    1342:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001346 <.LVL73>:


USBNWrite(RXC1,FLUSH);
    1346:	68 e0       	ldi	r22, 0x08	; 8
    1348:	8f e2       	ldi	r24, 0x2F	; 47
    134a:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

0000134e <.LVL74>:
USBNWrite(EPC2,EP_EN+0x02); 
    134e:	62 e1       	ldi	r22, 0x12	; 18
    1350:	8c e2       	ldi	r24, 0x2C	; 44
    1352:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001356 <.LVL75>:
USBNWrite(RXC1,RX_EN);
    1356:	61 e0       	ldi	r22, 0x01	; 1
    1358:	8f e2       	ldi	r24, 0x2F	; 47
    135a:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

0000135e <.LVL76>:
  
  USBNWrite(RXC1,RX_EN);
  USBNWrite(RXC2,RX_EN);
  USBNWrite(RXC3,RX_EN);
*/
  USBNWrite(TXC0,TX_TOGL+TX_EN);  //enable the TX (DATA1)
    135e:	65 e0       	ldi	r22, 0x05	; 5
    1360:	83 e2       	ldi	r24, 0x23	; 35
    1362:	0c 94 45 0b 	jmp	0x168a	; 0x168a <USBNWrite>

00001366 <_USBNGetConfiguration>:
  
}

void _USBNGetConfiguration(DeviceRequest *req)
{
  USBNWrite(TXD0,USBNFunctionInfo.ConfigurationIndex);
    1366:	60 91 e7 01 	lds	r22, 0x01E7	; 0x8001e7 <USBNFunctionInfo+0x1>
    136a:	81 e2       	ldi	r24, 0x21	; 33

0000136c <.Loc.202>:
    136c:	0c 94 45 0b 	jmp	0x168a	; 0x168a <USBNWrite>

00001370 <_USBNReceiveFIFO0>:
{
    1370:	cf 92       	push	r12
    1372:	df 92       	push	r13
    1374:	ef 92       	push	r14
    1376:	ff 92       	push	r15
    1378:	0f 93       	push	r16
    137a:	1f 93       	push	r17
    137c:	cf 93       	push	r28
    137e:	df 93       	push	r29
    1380:	cd b7       	in	r28, 0x3d	; 61
    1382:	de b7       	in	r29, 0x3e	; 62
    1384:	28 97       	sbiw	r28, 0x08	; 8
    1386:	0f b6       	in	r0, 0x3f	; 63
    1388:	f8 94       	cli
    138a:	de bf       	out	0x3e, r29	; 62
    138c:	0f be       	out	0x3f, r0	; 63
    138e:	cd bf       	out	0x3d, r28	; 61

00001390 <.Loc.204>:
  rxstatus = USBNRead(RXS0);
    1390:	86 e2       	ldi	r24, 0x26	; 38
    1392:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

00001396 <.LVL81>:
  if(rxstatus & SETUP_R)
    1396:	86 ff       	sbrs	r24, 6
    1398:	74 c0       	rjmp	.+232    	; 0x1482 <.L46>
    139a:	ce 01       	movw	r24, r28

0000139c <.Loc.212>:
    139c:	01 96       	adiw	r24, 0x01	; 1
    139e:	7c 01       	movw	r14, r24
    13a0:	6e 01       	movw	r12, r28
    13a2:	99 e0       	ldi	r25, 0x09	; 9
    13a4:	c9 0e       	add	r12, r25
    13a6:	d1 1c       	adc	r13, r1
    13a8:	87 01       	movw	r16, r14

000013aa <.L47>:
      Buf[i] = USBNRead(EP0rx.usbnData);  
    13aa:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <EP0rx>
    13ae:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

000013b2 <.LVL83>:
    13b2:	f7 01       	movw	r30, r14
    13b4:	81 93       	st	Z+, r24
    13b6:	7f 01       	movw	r14, r30

000013b8 <.Loc.216>:
    for(i=0;i<8;i++){ 
    13b8:	ec 15       	cp	r30, r12
    13ba:	fd 05       	cpc	r31, r13
    13bc:	b1 f7       	brne	.-20     	; 0x13aa <.L47>

000013be <.Loc.218>:
    USBNWrite(RXC0,FLUSH);		      // make sure the RX is off 
    13be:	68 e0       	ldi	r22, 0x08	; 8
    13c0:	87 e2       	ldi	r24, 0x27	; 39
    13c2:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000013c6 <.LVL85>:
    USBNWrite(TXC0,FLUSH);		      // make sure the TX is off 
    13c6:	68 e0       	ldi	r22, 0x08	; 8
    13c8:	83 e2       	ldi	r24, 0x23	; 35
    13ca:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000013ce <.LVL86>:
    USBNWrite(EPC0,USBNRead(EPC0)&0x7F);      // turn of stall
    13ce:	80 e2       	ldi	r24, 0x20	; 32
    13d0:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

000013d4 <.LVL87>:
    13d4:	68 2f       	mov	r22, r24
    13d6:	6f 77       	andi	r22, 0x7F	; 127
    13d8:	80 e2       	ldi	r24, 0x20	; 32
    13da:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000013de <.LVL88>:
    switch (req->bmRequestType & 0x60)  // decode request type     
    13de:	89 81       	ldd	r24, Y+1	; 0x01
    13e0:	80 76       	andi	r24, 0x60	; 96
    13e2:	80 32       	cpi	r24, 0x20	; 32
    13e4:	b1 f1       	breq	.+108    	; 0x1452 <.L64>
    13e6:	80 34       	cpi	r24, 0x40	; 64
    13e8:	09 f4       	brne	.+2      	; 0x13ec <L0^A+0x2>

000013ea <L0^A>:
    13ea:	47 c0       	rjmp	.+142    	; 0x147a <.L49>
    13ec:	81 11       	cpse	r24, r1
    13ee:	3c c0       	rjmp	.+120    	; 0x1468 <.L50>

000013f0 <.Loc.225>:
        switch (req->bRequest)	      // decode request code     
    13f0:	ea 81       	ldd	r30, Y+2	; 0x02
    13f2:	ec 30       	cpi	r30, 0x0C	; 12
    13f4:	c8 f5       	brcc	.+114    	; 0x1468 <.L50>
    13f6:	f0 e0       	ldi	r31, 0x00	; 0
    13f8:	ec 50       	subi	r30, 0x0C	; 12
    13fa:	fd 4e       	sbci	r31, 0xED	; 237
    13fc:	0c 94 83 11 	jmp	0x2306	; 0x2306 <__tablejump2__>

00001400 <.L54>:
            _USBNGetConfiguration(req);
    1400:	c8 01       	movw	r24, r16
    1402:	0e 94 b3 09 	call	0x1366	; 0x1366 <_USBNGetConfiguration>

00001406 <.L52>:
      if(req->bmRequestType == 0x00)
    1406:	89 81       	ldd	r24, Y+1	; 0x01
    1408:	81 11       	cpse	r24, r1
    140a:	04 c0       	rjmp	.+8      	; 0x1414 <.L45>

0000140c <.Loc.230>:
	USBNWrite(TXC0,TX_TOGL+TX_EN);  //enable the TX (DATA1)
    140c:	65 e0       	ldi	r22, 0x05	; 5
    140e:	83 e2       	ldi	r24, 0x23	; 35
    1410:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001414 <.L45>:
}
    1414:	28 96       	adiw	r28, 0x08	; 8
    1416:	0f b6       	in	r0, 0x3f	; 63
    1418:	f8 94       	cli
    141a:	de bf       	out	0x3e, r29	; 62
    141c:	0f be       	out	0x3f, r0	; 63
    141e:	cd bf       	out	0x3d, r28	; 61
    1420:	df 91       	pop	r29
    1422:	cf 91       	pop	r28
    1424:	1f 91       	pop	r17
    1426:	0f 91       	pop	r16
    1428:	ff 90       	pop	r15
    142a:	ef 90       	pop	r14
    142c:	df 90       	pop	r13
    142e:	cf 90       	pop	r12
    1430:	08 95       	ret

00001432 <.L55>:
            _USBNGetDescriptor(req);
    1432:	c8 01       	movw	r24, r16
    1434:	0e 94 20 09 	call	0x1240	; 0x1240 <_USBNGetDescriptor>

00001438 <.LVL92>:
          break;
    1438:	e6 cf       	rjmp	.-52     	; 0x1406 <.L52>

0000143a <.L57>:
	    USBNWrite(TXC0,FLUSH);
    143a:	68 e0       	ldi	r22, 0x08	; 8
    143c:	83 e2       	ldi	r24, 0x23	; 35
    143e:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001442 <.LVL93>:
	    USBNWrite(TXD0,1);
    1442:	61 e0       	ldi	r22, 0x01	; 1
    1444:	81 e2       	ldi	r24, 0x21	; 33
    1446:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

0000144a <.LVL94>:
	    USBNWrite(TXD0,0);
    144a:	60 e0       	ldi	r22, 0x00	; 0
    144c:	81 e2       	ldi	r24, 0x21	; 33
    144e:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001452 <.L64>:
	USBNWrite(TXC0,TX_TOGL+TX_EN);  //enable the TX (DATA1)
    1452:	65 e0       	ldi	r22, 0x05	; 5
    1454:	83 e2       	ldi	r24, 0x23	; 35
    1456:	0e c0       	rjmp	.+28     	; 0x1474 <.L65>

00001458 <.L56>:
            _USBNSetAddress(req); 
    1458:	c8 01       	movw	r24, r16
    145a:	0e 94 0e 09 	call	0x121c	; 0x121c <_USBNSetAddress>

0000145e <.LVL96>:
          break;
    145e:	d3 cf       	rjmp	.-90     	; 0x1406 <.L52>

00001460 <.L53>:
            _USBNSetConfiguration(req); 
    1460:	c8 01       	movw	r24, r16
    1462:	0e 94 9b 09 	call	0x1336	; 0x1336 <_USBNSetConfiguration>

00001466 <.LVL97>:
          break;
    1466:	cf cf       	rjmp	.-98     	; 0x1406 <.L52>

00001468 <.L50>:
            USBNWrite(EPC0,USBNRead(EPC0)+STALL);      // stall the endpoint
    1468:	80 e2       	ldi	r24, 0x20	; 32
    146a:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

0000146e <.LVL98>:
    146e:	60 e8       	ldi	r22, 0x80	; 128
    1470:	68 0f       	add	r22, r24
    1472:	80 e2       	ldi	r24, 0x20	; 32

00001474 <.L65>:
	USBNWrite(TXC0,TX_TOGL+TX_EN);  //enable the TX (DATA1)
    1474:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001478 <.LVL99>:
      break;              
    1478:	c6 cf       	rjmp	.-116    	; 0x1406 <.L52>

0000147a <.L49>:
	USBNDecodeVendorRequest(req);
    147a:	c8 01       	movw	r24, r16
    147c:	0e 94 11 01 	call	0x222	; 0x222 <USBNDecodeVendorRequest>

00001480 <.LVL100>:
    1480:	e8 cf       	rjmp	.-48     	; 0x1452 <.L64>

00001482 <.L46>:
    if (EP0tx.Size > EP0tx.usbnfifo)   // multi-pkt status stage? 
    1482:	80 91 1e 02 	lds	r24, 0x021E	; 0x80021e <EP0tx+0x8>
    1486:	90 91 1f 02 	lds	r25, 0x021F	; 0x80021f <EP0tx+0x9>

0000148a <.Loc.253>:
    148a:	20 91 1a 02 	lds	r18, 0x021A	; 0x80021a <EP0tx+0x4>
    148e:	30 91 1b 02 	lds	r19, 0x021B	; 0x80021b <EP0tx+0x5>
    1492:	28 17       	cp	r18, r24
    1494:	39 07       	cpc	r19, r25
    1496:	0c f0       	brlt	.+2      	; 0x149a <.Loc.254>

00001498 <L0^A>:
    1498:	bd cf       	rjmp	.-134    	; 0x1414 <.L45>

0000149a <.Loc.254>:
      EP0tx.Size=0;                // exit multi-packet mode  
    149a:	10 92 1f 02 	sts	0x021F, r1	; 0x80021f <EP0tx+0x9>
    149e:	10 92 1e 02 	sts	0x021E, r1	; 0x80021e <EP0tx+0x8>

000014a2 <.Loc.258>:
      USBNWrite(TXC0,FLUSH);       // flush TX0 and disable   
    14a2:	68 e0       	ldi	r22, 0x08	; 8
    14a4:	83 e2       	ldi	r24, 0x23	; 35
    14a6:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000014aa <.LVL103>:
      USBNWrite(RXC0,RX_EN);          // re-enable the receiver  
    14aa:	61 e0       	ldi	r22, 0x01	; 1
    14ac:	87 e2       	ldi	r24, 0x27	; 39

000014ae <.Loc.260>:
}
    14ae:	28 96       	adiw	r28, 0x08	; 8
    14b0:	0f b6       	in	r0, 0x3f	; 63
    14b2:	f8 94       	cli
    14b4:	de bf       	out	0x3e, r29	; 62
    14b6:	0f be       	out	0x3f, r0	; 63
    14b8:	cd bf       	out	0x3d, r28	; 61
    14ba:	df 91       	pop	r29
    14bc:	cf 91       	pop	r28
    14be:	1f 91       	pop	r17
    14c0:	0f 91       	pop	r16
    14c2:	ff 90       	pop	r15
    14c4:	ef 90       	pop	r14
    14c6:	df 90       	pop	r13
    14c8:	cf 90       	pop	r12

000014ca <.Loc.261>:
      USBNWrite(RXC0,RX_EN);          // re-enable the receiver  
    14ca:	0c 94 45 0b 	jmp	0x168a	; 0x168a <USBNWrite>

000014ce <_USBNReceiveEvent>:
{
    14ce:	cf 92       	push	r12
    14d0:	df 92       	push	r13
    14d2:	ef 92       	push	r14
    14d4:	ff 92       	push	r15
    14d6:	0f 93       	push	r16
    14d8:	1f 93       	push	r17
    14da:	cf 93       	push	r28
    14dc:	df 93       	push	r29
    14de:	cd b7       	in	r28, 0x3d	; 61
    14e0:	de b7       	in	r29, 0x3e	; 62
    14e2:	c0 54       	subi	r28, 0x40	; 64
    14e4:	d1 09       	sbc	r29, r1
    14e6:	0f b6       	in	r0, 0x3f	; 63
    14e8:	f8 94       	cli
    14ea:	de bf       	out	0x3e, r29	; 62
    14ec:	0f be       	out	0x3f, r0	; 63
    14ee:	cd bf       	out	0x3d, r28	; 61

000014f0 <.Loc.263>:
  event = USBNRead(RXEV);
    14f0:	8c e0       	ldi	r24, 0x0C	; 12
    14f2:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

000014f6 <.LVL106>:
  if(event & RX_FIFO0) _USBNReceiveFIFO0();
    14f6:	80 ff       	sbrs	r24, 0
    14f8:	11 c0       	rjmp	.+34     	; 0x151c <.L67>

000014fa <.Loc.272>:
}
    14fa:	c0 5c       	subi	r28, 0xC0	; 192
    14fc:	df 4f       	sbci	r29, 0xFF	; 255
    14fe:	0f b6       	in	r0, 0x3f	; 63
    1500:	f8 94       	cli
    1502:	de bf       	out	0x3e, r29	; 62
    1504:	0f be       	out	0x3f, r0	; 63
    1506:	cd bf       	out	0x3d, r28	; 61
    1508:	df 91       	pop	r29
    150a:	cf 91       	pop	r28
    150c:	1f 91       	pop	r17
    150e:	0f 91       	pop	r16
    1510:	ff 90       	pop	r15
    1512:	ef 90       	pop	r14
    1514:	df 90       	pop	r13
    1516:	cf 90       	pop	r12

00001518 <.Loc.274>:
  if(event & RX_FIFO0) _USBNReceiveFIFO0();
    1518:	0c 94 b8 09 	jmp	0x1370	; 0x1370 <_USBNReceiveFIFO0>

0000151c <.L67>:
  else if(event & RX_FIFO1) 
    151c:	81 ff       	sbrs	r24, 1
    151e:	3a c0       	rjmp	.+116    	; 0x1594 <.L68>

00001520 <.Loc.277>:
    USBNRead(RXS1);
    1520:	8e e2       	ldi	r24, 0x2E	; 46

00001522 <.Loc.278>:
    1522:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

00001526 <.LVL109>:
    *bufp = USBNRead(RXD1);
    1526:	8d e2       	ldi	r24, 0x2D	; 45
    1528:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

0000152c <.LVL110>:
    152c:	89 83       	std	Y+1, r24	; 0x01

0000152e <.Loc.282>:
  char *bufp=&buf[0];
    152e:	8e 01       	movw	r16, r28
    1530:	0f 5f       	subi	r16, 0xFF	; 255
    1532:	1f 4f       	sbci	r17, 0xFF	; 255
    1534:	78 01       	movw	r14, r16

00001536 <.Loc.285>:
    for(i=0;i<63;i++) 
    1536:	6e 01       	movw	r12, r28
    1538:	80 e4       	ldi	r24, 0x40	; 64
    153a:	c8 0e       	add	r12, r24
    153c:	d1 1c       	adc	r13, r1

0000153e <.L69>:
      *(++bufp)=USBNBurstRead(); 
    153e:	0f 5f       	subi	r16, 0xFF	; 255
    1540:	1f 4f       	sbci	r17, 0xFF	; 255

00001542 <.Loc.288>:
    1542:	0e 94 23 0b 	call	0x1646	; 0x1646 <USBNBurstRead>

00001546 <.LVL114>:
    1546:	f8 01       	movw	r30, r16
    1548:	80 83       	st	Z, r24

0000154a <.Loc.290>:
    for(i=0;i<63;i++) 
    154a:	0c 15       	cp	r16, r12
    154c:	1d 05       	cpc	r17, r13
    154e:	b9 f7       	brne	.-18     	; 0x153e <.L69>

00001550 <.Loc.292>:
    if(rxfifos.rx1==1){
    1550:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <rxfifos>
    1554:	81 30       	cpi	r24, 0x01	; 1
    1556:	31 f4       	brne	.+12     	; 0x1564 <.L70>

00001558 <.Loc.294>:
      (*ptr)(&buf);
    1558:	e0 91 05 02 	lds	r30, 0x0205	; 0x800205 <rxfifos+0x3>
    155c:	f0 91 06 02 	lds	r31, 0x0206	; 0x800206 <rxfifos+0x4>
    1560:	c7 01       	movw	r24, r14
    1562:	09 95       	icall

00001564 <.L70>:
    USBNWrite(RXC1,FLUSH);   
    1564:	68 e0       	ldi	r22, 0x08	; 8
    1566:	8f e2       	ldi	r24, 0x2F	; 47
    1568:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

0000156c <.LVL117>:
    USBNWrite(RXC1,RX_EN);    
    156c:	61 e0       	ldi	r22, 0x01	; 1
    156e:	8f e2       	ldi	r24, 0x2F	; 47

00001570 <.L81>:
    USBNWrite(RXC2,RX_EN);    
    1570:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001574 <.L66>:
}
    1574:	c0 5c       	subi	r28, 0xC0	; 192
    1576:	df 4f       	sbci	r29, 0xFF	; 255
    1578:	0f b6       	in	r0, 0x3f	; 63
    157a:	f8 94       	cli
    157c:	de bf       	out	0x3e, r29	; 62
    157e:	0f be       	out	0x3f, r0	; 63
    1580:	cd bf       	out	0x3d, r28	; 61
    1582:	df 91       	pop	r29
    1584:	cf 91       	pop	r28
    1586:	1f 91       	pop	r17
    1588:	0f 91       	pop	r16
    158a:	ff 90       	pop	r15
    158c:	ef 90       	pop	r14
    158e:	df 90       	pop	r13
    1590:	cf 90       	pop	r12
    1592:	08 95       	ret

00001594 <.L68>:
  else if(event & RX_FIFO2) 
    1594:	82 ff       	sbrs	r24, 2
    1596:	29 c0       	rjmp	.+82     	; 0x15ea <.L72>

00001598 <.Loc.304>:
    USBNRead(RXS2);
    1598:	86 e3       	ldi	r24, 0x36	; 54

0000159a <.Loc.305>:
    159a:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

0000159e <.LVL121>:
    *bufp = USBNRead(RXD2);
    159e:	85 e3       	ldi	r24, 0x35	; 53
    15a0:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

000015a4 <.LVL122>:
    15a4:	89 83       	std	Y+1, r24	; 0x01

000015a6 <.Loc.309>:
  char *bufp=&buf[0];
    15a6:	8e 01       	movw	r16, r28
    15a8:	0f 5f       	subi	r16, 0xFF	; 255
    15aa:	1f 4f       	sbci	r17, 0xFF	; 255
    15ac:	78 01       	movw	r14, r16

000015ae <.Loc.312>:
    for(i=0;i<63;i++) 
    15ae:	6e 01       	movw	r12, r28
    15b0:	f0 e4       	ldi	r31, 0x40	; 64
    15b2:	cf 0e       	add	r12, r31
    15b4:	d1 1c       	adc	r13, r1

000015b6 <.L73>:
      *(++bufp)=USBNBurstRead(); 
    15b6:	0f 5f       	subi	r16, 0xFF	; 255
    15b8:	1f 4f       	sbci	r17, 0xFF	; 255

000015ba <.Loc.315>:
    15ba:	0e 94 23 0b 	call	0x1646	; 0x1646 <USBNBurstRead>

000015be <.LVL126>:
    15be:	f8 01       	movw	r30, r16
    15c0:	80 83       	st	Z, r24

000015c2 <.Loc.317>:
    for(i=0;i<63;i++) 
    15c2:	0c 15       	cp	r16, r12
    15c4:	1d 05       	cpc	r17, r13
    15c6:	b9 f7       	brne	.-18     	; 0x15b6 <.L73>

000015c8 <.Loc.319>:
    if(rxfifos.rx2==1){
    15c8:	80 91 03 02 	lds	r24, 0x0203	; 0x800203 <rxfifos+0x1>
    15cc:	81 30       	cpi	r24, 0x01	; 1
    15ce:	31 f4       	brne	.+12     	; 0x15dc <.L74>

000015d0 <.Loc.321>:
      (*ptr)(&buf);
    15d0:	e0 91 07 02 	lds	r30, 0x0207	; 0x800207 <rxfifos+0x5>
    15d4:	f0 91 08 02 	lds	r31, 0x0208	; 0x800208 <rxfifos+0x6>
    15d8:	c7 01       	movw	r24, r14
    15da:	09 95       	icall

000015dc <.L74>:
    USBNWrite(RXC2,FLUSH);   
    15dc:	68 e0       	ldi	r22, 0x08	; 8
    15de:	87 e3       	ldi	r24, 0x37	; 55
    15e0:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

000015e4 <.LVL129>:
    USBNWrite(RXC2,RX_EN);    
    15e4:	61 e0       	ldi	r22, 0x01	; 1
    15e6:	87 e3       	ldi	r24, 0x37	; 55
    15e8:	c3 cf       	rjmp	.-122    	; 0x1570 <.L81>

000015ea <.L72>:
  else if(event & RX_FIFO3) 
    15ea:	83 ff       	sbrs	r24, 3
    15ec:	c3 cf       	rjmp	.-122    	; 0x1574 <.L66>

000015ee <.Loc.328>:
    USBNRead(RXS3);
    15ee:	8e e3       	ldi	r24, 0x3E	; 62

000015f0 <.Loc.329>:
    15f0:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

000015f4 <.LVL132>:
    for(i=0;i<64;i++) 
    15f4:	8e 01       	movw	r16, r28
    15f6:	0f 5f       	subi	r16, 0xFF	; 255
    15f8:	1f 4f       	sbci	r17, 0xFF	; 255
    15fa:	6e 01       	movw	r12, r28
    15fc:	f1 e4       	ldi	r31, 0x41	; 65
    15fe:	cf 0e       	add	r12, r31
    1600:	d1 1c       	adc	r13, r1
    1602:	78 01       	movw	r14, r16

00001604 <.L76>:
      buf[i]=USBNRead(RXD3); 
    1604:	8d e3       	ldi	r24, 0x3D	; 61
    1606:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

0000160a <.LVL134>:
    160a:	f8 01       	movw	r30, r16
    160c:	81 93       	st	Z+, r24
    160e:	8f 01       	movw	r16, r30

00001610 <.Loc.335>:
    for(i=0;i<64;i++) 
    1610:	ec 15       	cp	r30, r12
    1612:	fd 05       	cpc	r31, r13
    1614:	b9 f7       	brne	.-18     	; 0x1604 <.L76>

00001616 <.Loc.337>:
    if(rxfifos.rx3==1){
    1616:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <rxfifos+0x2>
    161a:	81 30       	cpi	r24, 0x01	; 1
    161c:	09 f0       	breq	.+2      	; 0x1620 <.Loc.339>

0000161e <L0^A>:
    161e:	aa cf       	rjmp	.-172    	; 0x1574 <.L66>

00001620 <.Loc.339>:
      (*ptr)(&buf);
    1620:	e0 91 05 02 	lds	r30, 0x0205	; 0x800205 <rxfifos+0x3>
    1624:	f0 91 06 02 	lds	r31, 0x0206	; 0x800206 <rxfifos+0x4>
    1628:	c7 01       	movw	r24, r14
    162a:	09 95       	icall

0000162c <.LVL136>:
  else {}
    162c:	a3 cf       	rjmp	.-186    	; 0x1574 <.L66>

0000162e <USBNInitMC>:

// Read data from usbn96x register

void USBNInitMC(void)
{
  MCUCR |=  (1 << ISC01); // fallende flanke
    162e:	85 b7       	in	r24, 0x35	; 53

00001630 <.Loc.2>:
    1630:	82 60       	ori	r24, 0x02	; 2
    1632:	85 bf       	out	0x35, r24	; 53

00001634 <.Loc.3>:
  GICR |= (1 << INT0);
    1634:	8b b7       	in	r24, 0x3b	; 59

00001636 <.Loc.4>:
    1636:	80 64       	ori	r24, 0x40	; 64
    1638:	8b bf       	out	0x3b, r24	; 59

0000163a <.Loc.5>:

  USB_CTRL_DDR = 0xf8;
    163a:	88 ef       	ldi	r24, 0xF8	; 248
    163c:	81 bb       	out	0x11, r24	; 17

0000163e <.Loc.7>:
  //USB_CTRL_DDR = 0xff;
  //USB_CTRL_PORT |= ((PF_RD | PF_WR | PF_CS | PF_RESET) & ~(PF_A0));
  USB_CTRL_PORT |= ((PF_RD | PF_WR | PF_CS) & ~(PF_A0));
    163e:	82 b3       	in	r24, 0x12	; 18

00001640 <.Loc.8>:
    1640:	88 63       	ori	r24, 0x38	; 56
    1642:	82 bb       	out	0x12, r24	; 18

00001644 <.Loc.9>:
}
    1644:	08 95       	ret

00001646 <USBNBurstRead>:

unsigned char USBNBurstRead(void)
{
  //unsigned char result;
                                                                                
  USB_CTRL_PORT ^= (PF_CS | PF_RD);
    1646:	82 b3       	in	r24, 0x12	; 18

00001648 <.Loc.12>:
    1648:	98 e1       	ldi	r25, 0x18	; 24
    164a:	89 27       	eor	r24, r25
    164c:	82 bb       	out	0x12, r24	; 18

0000164e <.Loc.13>:
	...

00001650 <.Loc.14>:
	...

00001652 <.Loc.15>:
  asm("nop");              // pause for data to get to bus
  asm("nop"); 
  //result = USB_DATA_IN;
  USB_CTRL_PORT ^= (PF_CS | PF_RD);
    1652:	82 b3       	in	r24, 0x12	; 18

00001654 <.Loc.16>:
    1654:	89 27       	eor	r24, r25
    1656:	82 bb       	out	0x12, r24	; 18

00001658 <.Loc.17>:
  return USB_DATA_IN;
    1658:	83 b3       	in	r24, 0x13	; 19

0000165a <.Loc.19>:
  //return result;
}
    165a:	08 95       	ret

0000165c <USBNRead>:

unsigned char USBNRead(unsigned char Adr)
{
  USB_DATA_DDR = 0xff;        // set for output
    165c:	9f ef       	ldi	r25, 0xFF	; 255
    165e:	94 bb       	out	0x14, r25	; 20

00001660 <.Loc.23>:
  USB_DATA_OUT = Adr;        // load address
    1660:	85 bb       	out	0x15, r24	; 21

00001662 <.Loc.25>:

  USB_CTRL_PORT ^= (PF_CS | PF_WR | PF_A0);  // strobe the CS, WR, and A0 pins
    1662:	82 b3       	in	r24, 0x12	; 18

00001664 <.Loc.26>:
    1664:	98 e6       	ldi	r25, 0x68	; 104
    1666:	89 27       	eor	r24, r25
    1668:	82 bb       	out	0x12, r24	; 18

0000166a <.Loc.27>:
  USB_CTRL_PORT ^= (PF_CS | PF_WR | PF_A0);
    166a:	82 b3       	in	r24, 0x12	; 18

0000166c <.Loc.28>:
    166c:	89 27       	eor	r24, r25
    166e:	82 bb       	out	0x12, r24	; 18

00001670 <.Loc.29>:
	...

00001672 <.Loc.30>:
  asm("nop");              // pause for data to get to bus
  USB_DATA_DDR = 0x00;       // set PortD for input
    1672:	14 ba       	out	0x14, r1	; 20

00001674 <.Loc.32>:
  return (USBNBurstRead());// get data off the bus
    1674:	0c 94 23 0b 	jmp	0x1646	; 0x1646 <USBNBurstRead>

00001678 <USBNBurstWrite>:
}


void USBNBurstWrite(unsigned char Data)
{
   USB_DATA_OUT = Data;       // put data on the bus
    1678:	85 bb       	out	0x15, r24	; 21

0000167a <.Loc.37>:
   USB_CTRL_PORT ^= (PF_CS | PF_WR);
    167a:	82 b3       	in	r24, 0x12	; 18

0000167c <.Loc.38>:
    167c:	98 e2       	ldi	r25, 0x28	; 40
    167e:	89 27       	eor	r24, r25
    1680:	82 bb       	out	0x12, r24	; 18

00001682 <.Loc.39>:
   USB_CTRL_PORT ^= (PF_CS | PF_WR);
    1682:	82 b3       	in	r24, 0x12	; 18

00001684 <.Loc.40>:
    1684:	89 27       	eor	r24, r25
    1686:	82 bb       	out	0x12, r24	; 18

00001688 <.Loc.41>:
}
    1688:	08 95       	ret

0000168a <USBNWrite>:
{
    168a:	98 2f       	mov	r25, r24
    168c:	86 2f       	mov	r24, r22

0000168e <.Loc.44>:
  USB_DATA_OUT = Adr;        // put the address on the bus
    168e:	95 bb       	out	0x15, r25	; 21

00001690 <.Loc.46>:
  USB_DATA_DDR = 0xff;         // set for output
    1690:	9f ef       	ldi	r25, 0xFF	; 255

00001692 <.Loc.48>:
    1692:	94 bb       	out	0x14, r25	; 20

00001694 <.Loc.49>:
  USB_CTRL_PORT ^= (PF_CS | PF_WR | PF_A0);
    1694:	92 b3       	in	r25, 0x12	; 18

00001696 <.Loc.50>:
    1696:	28 e6       	ldi	r18, 0x68	; 104
    1698:	92 27       	eor	r25, r18
    169a:	92 bb       	out	0x12, r25	; 18

0000169c <.Loc.51>:
  USB_CTRL_PORT ^= (PF_CS | PF_WR | PF_A0);
    169c:	92 b3       	in	r25, 0x12	; 18

0000169e <.Loc.52>:
    169e:	92 27       	eor	r25, r18
    16a0:	92 bb       	out	0x12, r25	; 18

000016a2 <.Loc.53>:
  USBNBurstWrite(Data);
    16a2:	0c 94 3c 0b 	jmp	0x1678	; 0x1678 <USBNBurstWrite>

000016a6 <USBNDebug>:
void USBNDebug(char *msg)
{
  #if DEBUG_ON
  UARTWrite(msg);
  #endif
}
    16a6:	08 95       	ret

000016a8 <USBNInit>:

// setup global datastructure
void USBNInit(void)
{
  // one and only device descriptor
  DeviceDescriptor.bLength=0x12; // length of device descriptor
    16a8:	e0 ef       	ldi	r30, 0xF0	; 240
    16aa:	f1 e0       	ldi	r31, 0x01	; 1
    16ac:	82 e1       	ldi	r24, 0x12	; 18
    16ae:	80 83       	st	Z, r24

000016b0 <.Loc.3>:
  DeviceDescriptor.bDescriptorType=0x01;
    16b0:	81 e0       	ldi	r24, 0x01	; 1
    16b2:	81 83       	std	Z+1, r24	; 0x01

000016b4 <.Loc.5>:
  DeviceDescriptor.bcdUSB=0x0110;
    16b4:	80 e1       	ldi	r24, 0x10	; 16
    16b6:	91 e0       	ldi	r25, 0x01	; 1
    16b8:	93 83       	std	Z+3, r25	; 0x03
    16ba:	82 83       	std	Z+2, r24	; 0x02

000016bc <.Loc.7>:
  DeviceDescriptor.bDeviceClass=0x00;
    16bc:	14 82       	std	Z+4, r1	; 0x04

000016be <.Loc.10>:
  DeviceDescriptor.bDeviceSubClass=0x00;
    16be:	15 82       	std	Z+5, r1	; 0x05

000016c0 <.Loc.11>:
  DeviceDescriptor.bDeviceProtocol=0x00;
    16c0:	16 82       	std	Z+6, r1	; 0x06

000016c2 <.Loc.13>:
  DeviceDescriptor.bMaxPacketSize0=0x08;
    16c2:	88 e0       	ldi	r24, 0x08	; 8
    16c4:	87 83       	std	Z+7, r24	; 0x07

000016c6 <.Loc.15>:
  DeviceDescriptor.idVendor=0x0000;
    16c6:	11 86       	std	Z+9, r1	; 0x09
    16c8:	10 86       	std	Z+8, r1	; 0x08

000016ca <.Loc.17>:
  DeviceDescriptor.idProduct=0x0000;
    16ca:	13 86       	std	Z+11, r1	; 0x0b
    16cc:	12 86       	std	Z+10, r1	; 0x0a

000016ce <.Loc.19>:
  DeviceDescriptor.bcdDevice=0x0000;
    16ce:	15 86       	std	Z+13, r1	; 0x0d
    16d0:	14 86       	std	Z+12, r1	; 0x0c

000016d2 <.Loc.21>:
  DeviceDescriptor.iManufacturer=0x00;
    16d2:	16 86       	std	Z+14, r1	; 0x0e

000016d4 <.Loc.23>:
  DeviceDescriptor.iProduct=0x00;
    16d4:	17 86       	std	Z+15, r1	; 0x0f

000016d6 <.Loc.25>:
  DeviceDescriptor.iSerialNumber=0x00;
    16d6:	10 8a       	std	Z+16, r1	; 0x10

000016d8 <.Loc.27>:
  DeviceDescriptor.bNumConfigurations=0;
    16d8:	11 8a       	std	Z+17, r1	; 0x11

000016da <.Loc.29>:

  // function caller for incomming data
  rxfifos.rx1 = 0;
    16da:	e2 e0       	ldi	r30, 0x02	; 2
    16dc:	f2 e0       	ldi	r31, 0x02	; 2
    16de:	10 82       	st	Z, r1

000016e0 <.Loc.31>:
  rxfifos.rx2 = 0;
    16e0:	11 82       	std	Z+1, r1	; 0x01

000016e2 <.Loc.33>:
  rxfifos.rx3 = 0;
    16e2:	12 82       	std	Z+2, r1	; 0x02

000016e4 <.Loc.35>:

  txfifos.tx1 = 0;
    16e4:	ed e0       	ldi	r30, 0x0D	; 13
    16e6:	f2 e0       	ldi	r31, 0x02	; 2
    16e8:	10 82       	st	Z, r1

000016ea <.Loc.37>:
  txfifos.tx2 = 0;
    16ea:	11 82       	std	Z+1, r1	; 0x01

000016ec <.Loc.39>:
  txfifos.tx3 = 0;
    16ec:	12 82       	std	Z+2, r1	; 0x02

000016ee <.Loc.41>:


  DescriptorList=NULL;
    16ee:	10 92 eb 01 	sts	0x01EB, r1	; 0x8001eb <DescriptorList+0x1>
    16f2:	10 92 ea 01 	sts	0x01EA, r1	; 0x8001ea <DescriptorList>

000016f6 <.Loc.43>:
  StringList=NULL;
    16f6:	10 92 e9 01 	sts	0x01E9, r1	; 0x8001e9 <StringList+0x1>
    16fa:	10 92 e8 01 	sts	0x01E8, r1	; 0x8001e8 <StringList>

000016fe <.Loc.45>:
}
    16fe:	08 95       	ret

00001700 <USBNDeviceIDs>:


// set all device ids vendor/product/device
void USBNDeviceIDs(unsigned short idVendor, unsigned short idProduct, unsigned short bcdDevice)
{
  DeviceDescriptor.idVendor = idVendor;
    1700:	e0 ef       	ldi	r30, 0xF0	; 240
    1702:	f1 e0       	ldi	r31, 0x01	; 1
    1704:	91 87       	std	Z+9, r25	; 0x09
    1706:	80 87       	std	Z+8, r24	; 0x08

00001708 <.Loc.49>:
  DeviceDescriptor.idProduct = idProduct;
    1708:	73 87       	std	Z+11, r23	; 0x0b
    170a:	62 87       	std	Z+10, r22	; 0x0a

0000170c <.Loc.51>:
  DeviceDescriptor.bcdDevice = bcdDevice;
    170c:	55 87       	std	Z+13, r21	; 0x0d
    170e:	44 87       	std	Z+12, r20	; 0x0c

00001710 <.Loc.53>:
}
    1710:	08 95       	ret

00001712 <USBNDeviceVendorID>:


// set vendor id
void USBNDeviceVendorID(unsigned short idVendor)
{
  DeviceDescriptor.idVendor = idVendor;
    1712:	90 93 f9 01 	sts	0x01F9, r25	; 0x8001f9 <DeviceDescriptor+0x9>
    1716:	80 93 f8 01 	sts	0x01F8, r24	; 0x8001f8 <DeviceDescriptor+0x8>

0000171a <.Loc.57>:
}
    171a:	08 95       	ret

0000171c <USBNDeviceProductID>:


//set product id
void USBNDeviceProductID(unsigned short idProduct)
{
  DeviceDescriptor.idProduct = idProduct;
    171c:	90 93 fb 01 	sts	0x01FB, r25	; 0x8001fb <DeviceDescriptor+0xb>
    1720:	80 93 fa 01 	sts	0x01FA, r24	; 0x8001fa <DeviceDescriptor+0xa>

00001724 <.Loc.61>:
}
    1724:	08 95       	ret

00001726 <USBNDeviceBCDDevice>:


//set device id
void USBNDeviceBCDDevice(unsigned short bcdDevice)
{
  DeviceDescriptor.bcdDevice = bcdDevice;
    1726:	90 93 fd 01 	sts	0x01FD, r25	; 0x8001fd <DeviceDescriptor+0xd>
    172a:	80 93 fc 01 	sts	0x01FC, r24	; 0x8001fc <DeviceDescriptor+0xc>

0000172e <.Loc.65>:
}
    172e:	08 95       	ret

00001730 <USBNDeviceClass>:
}

// define class code
void USBNDeviceClass(unsigned char classcode)
{
  DeviceDescriptor.bDeviceClass = classcode;
    1730:	80 93 f4 01 	sts	0x01F4, r24	; 0x8001f4 <DeviceDescriptor+0x4>

00001734 <.Loc.69>:
}
    1734:	08 95       	ret

00001736 <USBNDeviceSubClass>:

// define sub class code
void USBNDeviceSubClass(unsigned char subclasscode)
{
  DeviceDescriptor.bDeviceSubClass = subclasscode;
    1736:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <DeviceDescriptor+0x5>

0000173a <.Loc.73>:
}
    173a:	08 95       	ret

0000173c <USBNDeviceProtocol>:

// define protocol 
void USBNDeviceProtocol(unsigned char protocolcode)
{
  DeviceDescriptor.bDeviceProtocol = protocolcode;
    173c:	80 93 f6 01 	sts	0x01F6, r24	; 0x8001f6 <DeviceDescriptor+0x6>

00001740 <.Loc.77>:
}
    1740:	08 95       	ret

00001742 <USBNConfigurationPower>:
    ptr=ptr->next;
  }
}

void USBNConfigurationPower (int configuration, int power)
{
    1742:	ac 01       	movw	r20, r24
    1744:	9b 01       	movw	r18, r22

00001746 <.Loc.80>:
  // find configuration id  
  struct list_entry *ptr = DescriptorList;
    1746:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <DescriptorList>
    174a:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <DescriptorList+0x1>

0000174e <.L10>:
  char *values; 	      
  while(ptr != NULL) {
    174e:	30 97       	sbiw	r30, 0x00	; 0
    1750:	09 f4       	brne	.+2      	; 0x1754 <.L13>

00001752 <.Loc.85>:
    {
      values[8]=power/2;
    }
    ptr=ptr->next;
  }
}
    1752:	08 95       	ret

00001754 <.L13>:
    if(ptr->type==0x02 && values[5]==configuration) // if descr = confi 
    1754:	82 81       	ldd	r24, Z+2	; 0x02
    1756:	82 30       	cpi	r24, 0x02	; 2
    1758:	79 f4       	brne	.+30     	; 0x1778 <.L11>

0000175a <.Loc.89>:
    values = (char*)ptr->data;	      
    175a:	a0 81       	ld	r26, Z
    175c:	b1 81       	ldd	r27, Z+1	; 0x01

0000175e <.Loc.90>:
    if(ptr->type==0x02 && values[5]==configuration) // if descr = confi 
    175e:	15 96       	adiw	r26, 0x05	; 5
    1760:	8c 91       	ld	r24, X
    1762:	15 97       	sbiw	r26, 0x05	; 5

00001764 <.Loc.91>:
    1764:	84 17       	cp	r24, r20
    1766:	15 06       	cpc	r1, r21
    1768:	39 f4       	brne	.+14     	; 0x1778 <.L11>

0000176a <.Loc.92>:
      values[8]=power/2;
    176a:	c9 01       	movw	r24, r18
    176c:	37 fd       	sbrc	r19, 7

0000176e <.Loc.94>:
    176e:	01 96       	adiw	r24, 0x01	; 1
    1770:	95 95       	asr	r25
    1772:	87 95       	ror	r24

00001774 <.Loc.95>:
    1774:	18 96       	adiw	r26, 0x08	; 8
    1776:	8c 93       	st	X, r24

00001778 <.L11>:
    ptr=ptr->next;
    1778:	07 80       	ldd	r0, Z+7	; 0x07
    177a:	f0 85       	ldd	r31, Z+8	; 0x08
    177c:	e0 2d       	mov	r30, r0

0000177e <.Loc.98>:
    177e:	e7 cf       	rjmp	.-50     	; 0x174e <.L10>

00001780 <USBNAlternateSetting>:
  }
}

// TODO
void USBNAlternateSetting(int configuration, int interface, int setting)
{
    1780:	cf 93       	push	r28
    1782:	df 93       	push	r29
    1784:	9c 01       	movw	r18, r24
    1786:	db 01       	movw	r26, r22

00001788 <.Loc.101>:
  // find configuration id  
  struct list_entry *ptr = DescriptorList;
    1788:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <DescriptorList>
    178c:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <DescriptorList+0x1>

00001790 <.L15>:
  char *values; 	      
  while(ptr != NULL) {
    1790:	30 97       	sbiw	r30, 0x00	; 0
    1792:	19 f4       	brne	.+6      	; 0x179a <.L17>

00001794 <.Loc.106>:
    {
      values[3]=setting;
    }
    ptr=ptr->next;
  }
}
    1794:	df 91       	pop	r29
    1796:	cf 91       	pop	r28
    1798:	08 95       	ret

0000179a <.L17>:
    if(ptr->type==0x04 && ptr->conf==configuration && ptr->index==interface) // if descr = confi 
    179a:	82 81       	ldd	r24, Z+2	; 0x02
    179c:	84 30       	cpi	r24, 0x04	; 4
    179e:	59 f4       	brne	.+22     	; 0x17b6 <.L16>

000017a0 <.Loc.110>:
    17a0:	84 81       	ldd	r24, Z+4	; 0x04

000017a2 <.Loc.111>:
    17a2:	82 17       	cp	r24, r18
    17a4:	13 06       	cpc	r1, r19
    17a6:	39 f4       	brne	.+14     	; 0x17b6 <.L16>

000017a8 <.Loc.112>:
    17a8:	86 81       	ldd	r24, Z+6	; 0x06

000017aa <.Loc.113>:
    17aa:	8a 17       	cp	r24, r26
    17ac:	1b 06       	cpc	r1, r27
    17ae:	19 f4       	brne	.+6      	; 0x17b6 <.L16>

000017b0 <.Loc.114>:
    values = (char*)ptr->data;	      
    17b0:	c0 81       	ld	r28, Z
    17b2:	d1 81       	ldd	r29, Z+1	; 0x01

000017b4 <.Loc.115>:
      values[3]=setting;
    17b4:	4b 83       	std	Y+3, r20	; 0x03

000017b6 <.L16>:
    ptr=ptr->next;
    17b6:	07 80       	ldd	r0, Z+7	; 0x07
    17b8:	f0 85       	ldd	r31, Z+8	; 0x08
    17ba:	e0 2d       	mov	r30, r0

000017bc <.Loc.119>:
    17bc:	e9 cf       	rjmp	.-46     	; 0x1790 <.L15>

000017be <USBNNackEvent>:
}


void USBNNackEvent(void *callback)
{
   rxfifos.nack_callback = callback;
    17be:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <rxfifos+0xa>
    17c2:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <rxfifos+0x9>

000017c6 <.Loc.123>:
}
    17c6:	08 95       	ret

000017c8 <_USBNCreateConfDescrField>:

// *******************************************************************
// put configuration/interface and ep descr in a linear field
// ********************************************************************
void _USBNCreateConfDescrField(void)
{
    17c8:	6f 92       	push	r6
    17ca:	7f 92       	push	r7
    17cc:	8f 92       	push	r8
    17ce:	9f 92       	push	r9
    17d0:	af 92       	push	r10
    17d2:	bf 92       	push	r11
    17d4:	cf 92       	push	r12
    17d6:	df 92       	push	r13
    17d8:	ef 92       	push	r14
    17da:	ff 92       	push	r15
    17dc:	0f 93       	push	r16
    17de:	1f 93       	push	r17
    17e0:	cf 93       	push	r28
    17e2:	df 93       	push	r29

000017e4 <.Loc.125>:
  char *values=NULL;
  char *actualconf=NULL;


  // number of configurations
  ptr = DescriptorList;
    17e4:	e0 90 ea 01 	lds	r14, 0x01EA	; 0x8001ea <DescriptorList>
    17e8:	f0 90 eb 01 	lds	r15, 0x01EB	; 0x8001eb <DescriptorList+0x1>

000017ec <.Loc.134>:
  int conf=0;
    17ec:	61 2c       	mov	r6, r1
    17ee:	71 2c       	mov	r7, r1

000017f0 <.L20>:
  while(ptr != NULL) {
    17f0:	e1 14       	cp	r14, r1
    17f2:	f1 04       	cpc	r15, r1
    17f4:	69 f5       	brne	.+90     	; 0x1850 <.L22>

000017f6 <.Loc.137>:
      conf++;
    ptr=ptr->next;
  }
  
  // now get the array with the numbers of configurations 
  FinalConfigurationArray = (char**)malloc(sizeof(char*)*conf);
    17f6:	83 01       	movw	r16, r6
    17f8:	00 0f       	add	r16, r16
    17fa:	11 1f       	adc	r17, r17
    17fc:	c8 01       	movw	r24, r16
    17fe:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

00001802 <.LVL21>:
    1802:	90 93 ef 01 	sts	0x01EF, r25	; 0x8001ef <FinalConfigurationArray+0x1>
    1806:	80 93 ee 01 	sts	0x01EE, r24	; 0x8001ee <FinalConfigurationArray>

0000180a <.Loc.140>:
	actualconf = values;
      }	
      ptr=ptr->next;
    }
    // reserve memory for every configuration descriptor
    FinalConfigurationArray[conf-1] = (char*)malloc(sizeof(char)*desclen);
    180a:	02 50       	subi	r16, 0x02	; 2
    180c:	11 09       	sbc	r17, r1

0000180e <.Loc.142>:
  for(i=1;i<=conf;i++)
    180e:	cc 24       	eor	r12, r12
    1810:	c3 94       	inc	r12
    1812:	d1 2c       	mov	r13, r1

00001814 <.L23>:
    1814:	6c 14       	cp	r6, r12
    1816:	7d 04       	cpc	r7, r13
    1818:	34 f5       	brge	.+76     	; 0x1866 <.L29>
    181a:	00 e0       	ldi	r16, 0x00	; 0
    181c:	10 e0       	ldi	r17, 0x00	; 0

0000181e <.Loc.144>:
    //FinalConfigurationArray[conf-1][2] = desclen +9 ; //  old version
  }

  // next index start`s here ( confi descr is always 9 signs long )
  index = 9;
  int numofinterf=0;
    181e:	a1 2c       	mov	r10, r1
    1820:	b1 2c       	mov	r11, r1

00001822 <.Loc.145>:
  index = 9;
    1822:	29 e0       	ldi	r18, 0x09	; 9
    1824:	30 e0       	ldi	r19, 0x00	; 0

00001826 <.Loc.146>:
  struct list_entry *findep;
  char *endpoint;
  // copy interface and endpoint descr
  for(i=1;i<=conf;i++)
    1826:	81 e0       	ldi	r24, 0x01	; 1
    1828:	90 e0       	ldi	r25, 0x00	; 0

0000182a <.L30>:
    182a:	68 16       	cp	r6, r24
    182c:	79 06       	cpc	r7, r25
    182e:	0c f0       	brlt	.+2      	; 0x1832 <.Loc.148>

00001830 <L0^A>:
    1830:	67 c0       	rjmp	.+206    	; 0x1900 <.L45>

00001832 <.Loc.148>:

  }

//  for(i=0;i<32;i++)
//    SendHex(FinalConfigurationArray[0][i]);
}
    1832:	df 91       	pop	r29
    1834:	cf 91       	pop	r28
    1836:	1f 91       	pop	r17
    1838:	0f 91       	pop	r16
    183a:	ff 90       	pop	r15
    183c:	ef 90       	pop	r14
    183e:	df 90       	pop	r13
    1840:	cf 90       	pop	r12
    1842:	bf 90       	pop	r11
    1844:	af 90       	pop	r10
    1846:	9f 90       	pop	r9
    1848:	8f 90       	pop	r8
    184a:	7f 90       	pop	r7
    184c:	6f 90       	pop	r6

0000184e <.Loc.149>:
    184e:	08 95       	ret

00001850 <.L22>:
    if(ptr->type==0x02)
    1850:	e7 01       	movw	r28, r14
    1852:	8a 81       	ldd	r24, Y+2	; 0x02
    1854:	82 30       	cpi	r24, 0x02	; 2
    1856:	19 f4       	brne	.+6      	; 0x185e <.L21>

00001858 <.Loc.152>:
      conf++;
    1858:	df ef       	ldi	r29, 0xFF	; 255
    185a:	6d 1a       	sub	r6, r29
    185c:	7d 0a       	sbc	r7, r29

0000185e <.L21>:
    ptr=ptr->next;
    185e:	f7 01       	movw	r30, r14
    1860:	e7 80       	ldd	r14, Z+7	; 0x07
    1862:	f0 84       	ldd	r15, Z+8	; 0x08

00001864 <.Loc.156>:
    1864:	c5 cf       	rjmp	.-118    	; 0x17f0 <.L20>

00001866 <.L29>:
    ptr = DescriptorList;
    1866:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <DescriptorList>
    186a:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <DescriptorList+0x1>

0000186e <.Loc.159>:
    desclen=0x09;
    186e:	89 e0       	ldi	r24, 0x09	; 9
    1870:	88 2e       	mov	r8, r24
    1872:	91 2c       	mov	r9, r1

00001874 <.L24>:
    while(ptr != NULL) 
    1874:	30 97       	sbiw	r30, 0x00	; 0
    1876:	71 f5       	brne	.+92     	; 0x18d4 <.L27>

00001878 <.Loc.163>:
    FinalConfigurationArray[conf-1] = (char*)malloc(sizeof(char)*desclen);
    1878:	a0 90 ee 01 	lds	r10, 0x01EE	; 0x8001ee <FinalConfigurationArray>
    187c:	b0 90 ef 01 	lds	r11, 0x01EF	; 0x8001ef <FinalConfigurationArray+0x1>
    1880:	a0 0e       	add	r10, r16
    1882:	b1 1e       	adc	r11, r17

00001884 <.Loc.165>:
    1884:	c4 01       	movw	r24, r8
    1886:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

0000188a <.LVL32>:
    188a:	e5 01       	movw	r28, r10
    188c:	99 83       	std	Y+1, r25	; 0x01
    188e:	88 83       	st	Y, r24

00001890 <.Loc.167>:
    for(index=0;index<len;index++)
    1890:	d7 01       	movw	r26, r14

00001892 <.Loc.170>:
    1892:	80 e0       	ldi	r24, 0x00	; 0
    1894:	90 e0       	ldi	r25, 0x00	; 0

00001896 <.L28>:
      FinalConfigurationArray[conf-1][index] = actualconf[index];
    1896:	2d 91       	ld	r18, X+

00001898 <.Loc.173>:
    1898:	e0 91 ee 01 	lds	r30, 0x01EE	; 0x8001ee <FinalConfigurationArray>
    189c:	f0 91 ef 01 	lds	r31, 0x01EF	; 0x8001ef <FinalConfigurationArray+0x1>
    18a0:	e0 0f       	add	r30, r16
    18a2:	f1 1f       	adc	r31, r17

000018a4 <.Loc.174>:
    18a4:	01 90       	ld	r0, Z+
    18a6:	f0 81       	ld	r31, Z
    18a8:	e0 2d       	mov	r30, r0
    18aa:	e8 0f       	add	r30, r24
    18ac:	f9 1f       	adc	r31, r25
    18ae:	20 83       	st	Z, r18

000018b0 <.Loc.175>:
    for(index=0;index<len;index++)
    18b0:	01 96       	adiw	r24, 0x01	; 1

000018b2 <.Loc.176>:
    18b2:	89 30       	cpi	r24, 0x09	; 9
    18b4:	91 05       	cpc	r25, r1
    18b6:	79 f7       	brne	.-34     	; 0x1896 <.L28>

000018b8 <.Loc.177>:
    FinalConfigurationArray[conf-1][2] = desclen; // FIXME
    18b8:	e0 91 ee 01 	lds	r30, 0x01EE	; 0x8001ee <FinalConfigurationArray>
    18bc:	f0 91 ef 01 	lds	r31, 0x01EF	; 0x8001ef <FinalConfigurationArray+0x1>
    18c0:	e0 0f       	add	r30, r16
    18c2:	f1 1f       	adc	r31, r17
    18c4:	01 90       	ld	r0, Z+
    18c6:	f0 81       	ld	r31, Z
    18c8:	e0 2d       	mov	r30, r0

000018ca <.Loc.179>:
    18ca:	82 82       	std	Z+2, r8	; 0x02

000018cc <.Loc.180>:
  for(i=1;i<=conf;i++)
    18cc:	df ef       	ldi	r29, 0xFF	; 255
    18ce:	cd 1a       	sub	r12, r29
    18d0:	dd 0a       	sbc	r13, r29

000018d2 <.Loc.181>:
    18d2:	a0 cf       	rjmp	.-192    	; 0x1814 <.L23>

000018d4 <.L27>:
      values = (char*)ptr->data;	      
    18d4:	a0 81       	ld	r26, Z
    18d6:	b1 81       	ldd	r27, Z+1	; 0x01

000018d8 <.Loc.184>:
      if(ptr->conf==i)
    18d8:	84 81       	ldd	r24, Z+4	; 0x04

000018da <.Loc.186>:
    18da:	8c 15       	cp	r24, r12
    18dc:	1d 04       	cpc	r1, r13
    18de:	19 f4       	brne	.+6      	; 0x18e6 <.L25>

000018e0 <.Loc.187>:
	desclen=desclen+ptr->len;
    18e0:	83 81       	ldd	r24, Z+3	; 0x03

000018e2 <.Loc.189>:
    18e2:	88 0e       	add	r8, r24
    18e4:	91 1c       	adc	r9, r1

000018e6 <.L25>:
      if((values[5]==(char)i) && (ptr->type==0x02))
    18e6:	15 96       	adiw	r26, 0x05	; 5
    18e8:	8c 91       	ld	r24, X
    18ea:	15 97       	sbiw	r26, 0x05	; 5
    18ec:	8c 11       	cpse	r24, r12
    18ee:	04 c0       	rjmp	.+8      	; 0x18f8 <.L26>

000018f0 <.Loc.192>:
    18f0:	82 81       	ldd	r24, Z+2	; 0x02
    18f2:	82 30       	cpi	r24, 0x02	; 2
    18f4:	09 f4       	brne	.+2      	; 0x18f8 <.L26>

000018f6 <.Loc.193>:
	actualconf = values;
    18f6:	7d 01       	movw	r14, r26

000018f8 <.L26>:
      ptr=ptr->next;
    18f8:	07 80       	ldd	r0, Z+7	; 0x07
    18fa:	f0 85       	ldd	r31, Z+8	; 0x08
    18fc:	e0 2d       	mov	r30, r0

000018fe <.Loc.196>:
    18fe:	ba cf       	rjmp	.-140    	; 0x1874 <.L24>

00001900 <.L45>:
    ptr = DescriptorList;
    1900:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <DescriptorList>
    1904:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <DescriptorList+0x1>

00001908 <.L31>:
    while(ptr != NULL) 
    1908:	30 97       	sbiw	r30, 0x00	; 0
    190a:	89 f0       	breq	.+34     	; 0x192e <.L33>

0000190c <.Loc.201>:
      values = (char*)ptr->data;	      
    190c:	a0 81       	ld	r26, Z
    190e:	b1 81       	ldd	r27, Z+1	; 0x01

00001910 <.Loc.203>:
      if(values[1]==0x02 && values[5]==i)
    1910:	11 96       	adiw	r26, 0x01	; 1
    1912:	4c 91       	ld	r20, X
    1914:	11 97       	sbiw	r26, 0x01	; 1
    1916:	42 30       	cpi	r20, 0x02	; 2
    1918:	99 f4       	brne	.+38     	; 0x1940 <.L32>

0000191a <.Loc.205>:
    191a:	15 96       	adiw	r26, 0x05	; 5
    191c:	4c 91       	ld	r20, X
    191e:	15 97       	sbiw	r26, 0x05	; 5

00001920 <.Loc.206>:
    1920:	48 17       	cp	r20, r24
    1922:	19 06       	cpc	r1, r25
    1924:	69 f4       	brne	.+26     	; 0x1940 <.L32>

00001926 <.Loc.207>:
	numofinterf = values[4];
    1926:	14 96       	adiw	r26, 0x04	; 4
    1928:	4c 91       	ld	r20, X

0000192a <.Loc.209>:
    192a:	a4 2e       	mov	r10, r20
    192c:	b1 2c       	mov	r11, r1

0000192e <.L33>:
    for(j=1;j<=numofinterf;j++)
    192e:	41 e0       	ldi	r20, 0x01	; 1
    1930:	50 e0       	ldi	r21, 0x00	; 0

00001932 <.L35>:
    1932:	a4 16       	cp	r10, r20
    1934:	b5 06       	cpc	r11, r21
    1936:	44 f4       	brge	.+16     	; 0x1948 <.L44>

00001938 <.Loc.214>:
  for(i=1;i<=conf;i++)
    1938:	01 96       	adiw	r24, 0x01	; 1

0000193a <.Loc.216>:
    193a:	0e 5f       	subi	r16, 0xFE	; 254
    193c:	1f 4f       	sbci	r17, 0xFF	; 255
    193e:	75 cf       	rjmp	.-278    	; 0x182a <.L30>

00001940 <.L32>:
      ptr=ptr->next;
    1940:	07 80       	ldd	r0, Z+7	; 0x07
    1942:	f0 85       	ldd	r31, Z+8	; 0x08
    1944:	e0 2d       	mov	r30, r0

00001946 <.Loc.219>:
    1946:	e0 cf       	rjmp	.-64     	; 0x1908 <.L31>

00001948 <.L44>:
      ptr = DescriptorList;
    1948:	a0 91 ea 01 	lds	r26, 0x01EA	; 0x8001ea <DescriptorList>
    194c:	b0 91 eb 01 	lds	r27, 0x01EB	; 0x8001eb <DescriptorList+0x1>

00001950 <.L36>:
      while(ptr != NULL) 
    1950:	10 97       	sbiw	r26, 0x00	; 0
    1952:	19 f4       	brne	.+6      	; 0x195a <.L43>

00001954 <.Loc.224>:
    for(j=1;j<=numofinterf;j++)
    1954:	4f 5f       	subi	r20, 0xFF	; 255
    1956:	5f 4f       	sbci	r21, 0xFF	; 255

00001958 <.Loc.225>:
    1958:	ec cf       	rjmp	.-40     	; 0x1932 <.L35>

0000195a <.L43>:
	values = (char*)ptr->data;	      
    195a:	ed 91       	ld	r30, X+
    195c:	fc 91       	ld	r31, X
    195e:	11 97       	sbiw	r26, 0x01	; 1

00001960 <.Loc.228>:
	if(values[1]==0x04 && ptr->index==j && ptr->conf==i)
    1960:	61 81       	ldd	r22, Z+1	; 0x01
    1962:	64 30       	cpi	r22, 0x04	; 4
    1964:	71 f5       	brne	.+92     	; 0x19c2 <.L37>

00001966 <.Loc.230>:
    1966:	16 96       	adiw	r26, 0x06	; 6
    1968:	6c 91       	ld	r22, X
    196a:	16 97       	sbiw	r26, 0x06	; 6

0000196c <.Loc.231>:
    196c:	64 17       	cp	r22, r20
    196e:	15 06       	cpc	r1, r21
    1970:	41 f5       	brne	.+80     	; 0x19c2 <.L37>

00001972 <.Loc.232>:
    1972:	14 96       	adiw	r26, 0x04	; 4
    1974:	6c 91       	ld	r22, X
    1976:	14 97       	sbiw	r26, 0x04	; 4

00001978 <.Loc.233>:
    1978:	68 17       	cp	r22, r24
    197a:	19 06       	cpc	r1, r25
    197c:	11 f5       	brne	.+68     	; 0x19c2 <.L37>
    197e:	ef 01       	movw	r28, r30

00001980 <.Loc.234>:
	  for(x=0;x<9;x++)
    1980:	e1 2c       	mov	r14, r1
    1982:	f1 2c       	mov	r15, r1

00001984 <.L38>:
	    FinalConfigurationArray[i-1][index] = values[x];
    1984:	d9 90       	ld	r13, Y+

00001986 <.Loc.237>:
    1986:	60 91 ee 01 	lds	r22, 0x01EE	; 0x8001ee <FinalConfigurationArray>
    198a:	70 91 ef 01 	lds	r23, 0x01EF	; 0x8001ef <FinalConfigurationArray+0x1>
    198e:	60 0f       	add	r22, r16
    1990:	71 1f       	adc	r23, r17

00001992 <.Loc.238>:
    1992:	fb 01       	movw	r30, r22
    1994:	60 81       	ld	r22, Z
    1996:	71 81       	ldd	r23, Z+1	; 0x01
    1998:	62 0f       	add	r22, r18
    199a:	73 1f       	adc	r23, r19
    199c:	6e 0d       	add	r22, r14
    199e:	7f 1d       	adc	r23, r15
    19a0:	fb 01       	movw	r30, r22
    19a2:	d0 82       	st	Z, r13

000019a4 <.Loc.239>:
	  for(x=0;x<9;x++)
    19a4:	ff ef       	ldi	r31, 0xFF	; 255
    19a6:	ef 1a       	sub	r14, r31
    19a8:	ff 0a       	sbc	r15, r31

000019aa <.Loc.241>:
    19aa:	69 e0       	ldi	r22, 0x09	; 9
    19ac:	e6 16       	cp	r14, r22
    19ae:	f1 04       	cpc	r15, r1
    19b0:	49 f7       	brne	.-46     	; 0x1984 <.L38>

000019b2 <.Loc.242>:
    19b2:	27 5f       	subi	r18, 0xF7	; 247
    19b4:	3f 4f       	sbci	r19, 0xFF	; 255

000019b6 <.Loc.243>:
	    findep = DescriptorList;
    19b6:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <DescriptorList>
    19ba:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <DescriptorList+0x1>

000019be <.L39>:
	    while(findep!=NULL)
    19be:	30 97       	sbiw	r30, 0x00	; 0
    19c0:	29 f4       	brne	.+10     	; 0x19cc <.L42>

000019c2 <.L37>:
	ptr=ptr->next;
    19c2:	17 96       	adiw	r26, 0x07	; 7
    19c4:	0d 90       	ld	r0, X+
    19c6:	bc 91       	ld	r27, X
    19c8:	a0 2d       	mov	r26, r0

000019ca <.Loc.249>:
    19ca:	c2 cf       	rjmp	.-124    	; 0x1950 <.L36>

000019cc <.L42>:
	      if(findep->type==0x05 && findep->conf==i && findep->interf==j)
    19cc:	62 81       	ldd	r22, Z+2	; 0x02
    19ce:	65 30       	cpi	r22, 0x05	; 5
    19d0:	39 f5       	brne	.+78     	; 0x1a20 <.L40>

000019d2 <.Loc.252>:
    19d2:	64 81       	ldd	r22, Z+4	; 0x04

000019d4 <.Loc.253>:
    19d4:	68 17       	cp	r22, r24
    19d6:	19 06       	cpc	r1, r25
    19d8:	19 f5       	brne	.+70     	; 0x1a20 <.L40>

000019da <.Loc.254>:
    19da:	65 81       	ldd	r22, Z+5	; 0x05

000019dc <.Loc.255>:
    19dc:	64 17       	cp	r22, r20
    19de:	15 06       	cpc	r1, r21
    19e0:	f9 f4       	brne	.+62     	; 0x1a20 <.L40>

000019e2 <.Loc.256>:
		for(x=0;x<7;x++)
    19e2:	c0 80       	ld	r12, Z
    19e4:	d1 80       	ldd	r13, Z+1	; 0x01

000019e6 <.Loc.259>:
    19e6:	e1 2c       	mov	r14, r1
    19e8:	f1 2c       	mov	r15, r1

000019ea <.L41>:
		  FinalConfigurationArray[i-1][index] = endpoint[x];
    19ea:	e6 01       	movw	r28, r12
    19ec:	99 90       	ld	r9, Y+
    19ee:	6e 01       	movw	r12, r28

000019f0 <.Loc.262>:
    19f0:	60 91 ee 01 	lds	r22, 0x01EE	; 0x8001ee <FinalConfigurationArray>
    19f4:	70 91 ef 01 	lds	r23, 0x01EF	; 0x8001ef <FinalConfigurationArray+0x1>
    19f8:	60 0f       	add	r22, r16
    19fa:	71 1f       	adc	r23, r17

000019fc <.Loc.263>:
    19fc:	eb 01       	movw	r28, r22
    19fe:	68 81       	ld	r22, Y
    1a00:	79 81       	ldd	r23, Y+1	; 0x01
    1a02:	62 0f       	add	r22, r18
    1a04:	73 1f       	adc	r23, r19
    1a06:	6e 0d       	add	r22, r14
    1a08:	7f 1d       	adc	r23, r15
    1a0a:	eb 01       	movw	r28, r22
    1a0c:	98 82       	st	Y, r9

00001a0e <.Loc.264>:
		for(x=0;x<7;x++)
    1a0e:	df ef       	ldi	r29, 0xFF	; 255
    1a10:	ed 1a       	sub	r14, r29
    1a12:	fd 0a       	sbc	r15, r29

00001a14 <.Loc.266>:
    1a14:	67 e0       	ldi	r22, 0x07	; 7
    1a16:	e6 16       	cp	r14, r22
    1a18:	f1 04       	cpc	r15, r1
    1a1a:	39 f7       	brne	.-50     	; 0x19ea <.L41>

00001a1c <.Loc.267>:
    1a1c:	29 5f       	subi	r18, 0xF9	; 249
    1a1e:	3f 4f       	sbci	r19, 0xFF	; 255

00001a20 <.L40>:
	      findep = findep->next;
    1a20:	07 80       	ldd	r0, Z+7	; 0x07
    1a22:	f0 85       	ldd	r31, Z+8	; 0x08
    1a24:	e0 2d       	mov	r30, r0

00001a26 <.Loc.270>:
    1a26:	cb cf       	rjmp	.-106    	; 0x19be <.L39>

00001a28 <_USBNCreateStringField>:



void _USBNCreateStringField(void)
{
    1a28:	ef 92       	push	r14
    1a2a:	ff 92       	push	r15
    1a2c:	0f 93       	push	r16
    1a2e:	1f 93       	push	r17
    1a30:	cf 93       	push	r28
    1a32:	df 93       	push	r29

00001a34 <.Loc.272>:
  struct string_entry *tmp;
  int index=0;
  
  tmp = StringList;
    1a34:	c0 91 e8 01 	lds	r28, 0x01E8	; 0x8001e8 <StringList>
    1a38:	d0 91 e9 01 	lds	r29, 0x01E9	; 0x8001e9 <StringList+0x1>

00001a3c <.Loc.276>:
    1a3c:	fe 01       	movw	r30, r28

00001a3e <.Loc.278>:
  int index=0;
    1a3e:	80 e0       	ldi	r24, 0x00	; 0
    1a40:	90 e0       	ldi	r25, 0x00	; 0

00001a42 <.L51>:
  while(tmp->next != NULL)
    1a42:	03 80       	ldd	r0, Z+3	; 0x03
    1a44:	f4 81       	ldd	r31, Z+4	; 0x04
    1a46:	e0 2d       	mov	r30, r0

00001a48 <.Loc.281>:
  {
    tmp=tmp->next;
    index++;
    1a48:	01 96       	adiw	r24, 0x01	; 1

00001a4a <.Loc.282>:
  while(tmp->next != NULL)
    1a4a:	30 97       	sbiw	r30, 0x00	; 0
    1a4c:	d1 f7       	brne	.-12     	; 0x1a42 <.L51>

00001a4e <.Loc.283>:
  } 
  // memory for all string descriptors
  index++;
  FinalStringArray = (char**)malloc(sizeof(char*)*index);
    1a4e:	88 0f       	add	r24, r24
    1a50:	99 1f       	adc	r25, r25

00001a52 <.Loc.286>:
    1a52:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

00001a56 <.LVL79>:
    1a56:	90 93 ed 01 	sts	0x01ED, r25	; 0x8001ed <FinalStringArray+0x1>
    1a5a:	80 93 ec 01 	sts	0x01EC, r24	; 0x8001ec <FinalStringArray>

00001a5e <.L54>:
  {
    if(!first) 
      tmp=tmp->next;
    first=0;

    ptr = (char*)tmp->data;
    1a5e:	08 81       	ld	r16, Y
    1a60:	19 81       	ldd	r17, Y+1	; 0x01

00001a62 <.Loc.297>:
    //USBNDebug("string index: ");
    //SendHex(tmp->index);
    //USBNDebug(" length: ");
    //SendHex(ptr[0]);
    //USBNDebug("\r\n\r\n");
    FinalStringArray[tmp->index] = (char*)malloc(sizeof(char)*(int)ptr[0]);
    1a62:	8a 81       	ldd	r24, Y+2	; 0x02

00001a64 <.Loc.299>:
    1a64:	e0 90 ec 01 	lds	r14, 0x01EC	; 0x8001ec <FinalStringArray>
    1a68:	f0 90 ed 01 	lds	r15, 0x01ED	; 0x8001ed <FinalStringArray+0x1>
    1a6c:	e8 0e       	add	r14, r24
    1a6e:	f1 1c       	adc	r15, r1
    1a70:	e8 0e       	add	r14, r24
    1a72:	f1 1c       	adc	r15, r1

00001a74 <.Loc.300>:
    1a74:	f8 01       	movw	r30, r16
    1a76:	80 81       	ld	r24, Z
    1a78:	90 e0       	ldi	r25, 0x00	; 0
    1a7a:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

00001a7e <.LVL82>:
    1a7e:	f7 01       	movw	r30, r14
    1a80:	91 83       	std	Z+1, r25	; 0x01
    1a82:	80 83       	st	Z, r24

00001a84 <.Loc.302>:

     for(x=0;x<(int)ptr[0];x++)
    1a84:	d8 01       	movw	r26, r16

00001a86 <.Loc.304>:
    1a86:	80 e0       	ldi	r24, 0x00	; 0
    1a88:	90 e0       	ldi	r25, 0x00	; 0

00001a8a <.L52>:
    1a8a:	f8 01       	movw	r30, r16
    1a8c:	20 81       	ld	r18, Z

00001a8e <.Loc.307>:
    1a8e:	82 17       	cp	r24, r18
    1a90:	91 05       	cpc	r25, r1
    1a92:	64 f0       	brlt	.+24     	; 0x1aac <.L53>

00001a94 <.Loc.308>:
       FinalStringArray[tmp->index][x] = ptr[x];


  } while(tmp->next != NULL);
    1a94:	0b 80       	ldd	r0, Y+3	; 0x03
    1a96:	dc 81       	ldd	r29, Y+4	; 0x04
    1a98:	c0 2d       	mov	r28, r0

00001a9a <.Loc.310>:
    1a9a:	20 97       	sbiw	r28, 0x00	; 0
    1a9c:	01 f7       	brne	.-64     	; 0x1a5e <.L54>

00001a9e <.Loc.311>:

}
    1a9e:	df 91       	pop	r29
    1aa0:	cf 91       	pop	r28
    1aa2:	1f 91       	pop	r17
    1aa4:	0f 91       	pop	r16

00001aa6 <.Loc.312>:
    1aa6:	ff 90       	pop	r15
    1aa8:	ef 90       	pop	r14
    1aaa:	08 95       	ret

00001aac <.L53>:
       FinalStringArray[tmp->index][x] = ptr[x];
    1aac:	2d 91       	ld	r18, X+

00001aae <.Loc.315>:
    1aae:	3a 81       	ldd	r19, Y+2	; 0x02

00001ab0 <.Loc.316>:
    1ab0:	e0 91 ec 01 	lds	r30, 0x01EC	; 0x8001ec <FinalStringArray>
    1ab4:	f0 91 ed 01 	lds	r31, 0x01ED	; 0x8001ed <FinalStringArray+0x1>
    1ab8:	e3 0f       	add	r30, r19
    1aba:	f1 1d       	adc	r31, r1
    1abc:	e3 0f       	add	r30, r19
    1abe:	f1 1d       	adc	r31, r1

00001ac0 <.Loc.317>:
    1ac0:	01 90       	ld	r0, Z+
    1ac2:	f0 81       	ld	r31, Z
    1ac4:	e0 2d       	mov	r30, r0
    1ac6:	e8 0f       	add	r30, r24
    1ac8:	f9 1f       	adc	r31, r25
    1aca:	20 83       	st	Z, r18

00001acc <.Loc.318>:
     for(x=0;x<(int)ptr[0];x++)
    1acc:	01 96       	adiw	r24, 0x01	; 1

00001ace <.Loc.319>:
    1ace:	dd cf       	rjmp	.-70     	; 0x1a8a <.L52>

00001ad0 <USBNStart>:
// start USB Chip
// ********************************************************************

void USBNStart(void)
{
  _USBNCreateConfDescrField();
    1ad0:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <_USBNCreateConfDescrField>

00001ad4 <.LVL89>:
  _USBNCreateStringField();
    1ad4:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <_USBNCreateStringField>

00001ad8 <.LVL90>:

  _USBNInitEP0();
    1ad8:	0e 94 3c 08 	call	0x1078	; 0x1078 <_USBNInitEP0>

00001adc <.LVL91>:
                                    // usbn starts here

  USBNWrite(MCNTRL,SRST);           // clear all registers
    1adc:	61 e0       	ldi	r22, 0x01	; 1
    1ade:	80 e0       	ldi	r24, 0x00	; 0
    1ae0:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001ae4 <.L58>:
  while(USBNRead(MCNTRL)&SRST);
    1ae4:	80 e0       	ldi	r24, 0x00	; 0
    1ae6:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

00001aea <.LVL93>:
    1aea:	80 fd       	sbrc	r24, 0
    1aec:	fb cf       	rjmp	.-10     	; 0x1ae4 <.L58>

00001aee <.Loc.327>:

  USBNWrite(CCONF, 0x02);           // clock to 16 MHz
    1aee:	62 e0       	ldi	r22, 0x02	; 2
    1af0:	81 e0       	ldi	r24, 0x01	; 1
    1af2:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001af6 <.LVL94>:
  USBNWrite(FAR,AD_EN+0x00);            // set default address
    1af6:	60 e8       	ldi	r22, 0x80	; 128
    1af8:	84 e0       	ldi	r24, 0x04	; 4
    1afa:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001afe <.LVL95>:
  USBNWrite(EPC0,DEF);
    1afe:	60 e4       	ldi	r22, 0x40	; 64
    1b00:	80 e2       	ldi	r24, 0x20	; 32
    1b02:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001b06 <.LVL96>:
  USBNWrite(TXC0,FLUSH);            // FLUSHTX0;
    1b06:	68 e0       	ldi	r22, 0x08	; 8
    1b08:	83 e2       	ldi	r24, 0x23	; 35
    1b0a:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001b0e <.LVL97>:

  USBNWrite(RXC0,RX_EN+FLUSH);            // enable EP0 receive
    1b0e:	69 e0       	ldi	r22, 0x09	; 9
    1b10:	87 e2       	ldi	r24, 0x27	; 39
    1b12:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001b16 <.LVL98>:
  //USBNWrite(RXC1,RX_EN);            // enable EP0 receive
 
  USBNWrite(RXMSK, RX_FIFO0+RX_FIFO1+RX_FIFO2+RX_FIFO3);            // data incoming EP0
    1b16:	6f e0       	ldi	r22, 0x0F	; 15
    1b18:	8d e0       	ldi	r24, 0x0D	; 13
    1b1a:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001b1e <.LVL99>:
  USBNWrite(TXMSK, TX_FIFO0+TX_FIFO1+TX_FIFO2+TX_FIFO3);            // data incoming EP0
    1b1e:	6f e0       	ldi	r22, 0x0F	; 15
    1b20:	8b e0       	ldi	r24, 0x0B	; 11
    1b22:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001b26 <.LVL100>:
 
  USBNWrite(ALTMSK, ALT_RESET+ALT_SD3+ALT_EOP+ALT_RESUME);
    1b26:	68 ed       	ldi	r22, 0xD8	; 216
    1b28:	89 e0       	ldi	r24, 0x09	; 9
    1b2a:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001b2e <.LVL101>:
  USBNWrite(NAKMSK,NAK_OUT0+NAK_OUT1+NAK_IN0+NAK_IN1);
    1b2e:	63 e3       	ldi	r22, 0x33	; 51
    1b30:	8f e0       	ldi	r24, 0x0F	; 15
    1b32:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001b36 <.LVL102>:
  //USBNWrite(NAKMSK,NAK_OUT0);

  USBNWrite(MAMSK, (INTR_E+RX_EV+ALT+TX_EV+NAK) );
    1b36:	66 ed       	ldi	r22, 0xD6	; 214
    1b38:	87 e0       	ldi	r24, 0x07	; 7
    1b3a:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001b3e <.LVL103>:
 
  
  USBNWrite(NFSR,OPR_ST);
    1b3e:	62 e0       	ldi	r22, 0x02	; 2
    1b40:	85 e0       	ldi	r24, 0x05	; 5
    1b42:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001b46 <.LVL104>:
  USBNWrite(MCNTRL, VGE+NAT+INT_L_P);     // VGE, no NAT, interrupt on high
    1b46:	6c ec       	ldi	r22, 0xCC	; 204
    1b48:	80 e0       	ldi	r24, 0x00	; 0
    1b4a:	0c 94 45 0b 	jmp	0x168a	; 0x168a <USBNWrite>

00001b4e <USBNInterrupt>:
// Interrupt Routine for USBN960x
// ********************************************************************


void USBNInterrupt(void)
{
    1b4e:	cf 93       	push	r28

00001b50 <.Loc.340>:
  unsigned char maev,mask;
  //UARTWrite("irq\r\n");
  
  maev = USBNRead(MAEV);
    1b50:	86 e0       	ldi	r24, 0x06	; 6
    1b52:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

00001b56 <.LVL106>:
    1b56:	c8 2f       	mov	r28, r24

00001b58 <.Loc.343>:
  //SendHex(maev);

  if(maev & NAK) _USBNNackEvent(); 
    1b58:	84 fd       	sbrc	r24, 4

00001b5a <.Loc.345>:
    1b5a:	0e 94 54 08 	call	0x10a8	; 0x10a8 <_USBNNackEvent>

00001b5e <.LVL108>:
  if(maev & RX_EV)  _USBNReceiveEvent();
    1b5e:	c6 fd       	sbrc	r28, 6

00001b60 <.Loc.348>:
    1b60:	0e 94 67 0a 	call	0x14ce	; 0x14ce <_USBNReceiveEvent>

00001b64 <.LVL109>:
  if(maev & TX_EV) _USBNTransmitEvent();
    1b64:	c2 fd       	sbrc	r28, 2

00001b66 <.Loc.351>:
    1b66:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <_USBNTransmitEvent>

00001b6a <.LVL110>:
  if(maev & ALT)   _USBNAlternateEvent();
    1b6a:	c1 fd       	sbrc	r28, 1

00001b6c <.Loc.354>:
    1b6c:	0e 94 57 08 	call	0x10ae	; 0x10ae <_USBNAlternateEvent>

00001b70 <.LVL111>:
  
  mask = USBNRead(MAMSK);
    1b70:	87 e0       	ldi	r24, 0x07	; 7
    1b72:	0e 94 2e 0b 	call	0x165c	; 0x165c <USBNRead>

00001b76 <.LVL112>:
    1b76:	c8 2f       	mov	r28, r24

00001b78 <.Loc.357>:
  USBNWrite(MAMSK,0x00);                  // disable irq
    1b78:	60 e0       	ldi	r22, 0x00	; 0
    1b7a:	87 e0       	ldi	r24, 0x07	; 7

00001b7c <.Loc.358>:
    1b7c:	0e 94 45 0b 	call	0x168a	; 0x168a <USBNWrite>

00001b80 <.LVL115>:
  USBNWrite(MAMSK,mask);
    1b80:	6c 2f       	mov	r22, r28
    1b82:	87 e0       	ldi	r24, 0x07	; 7

00001b84 <.Loc.360>:

}
    1b84:	cf 91       	pop	r28

00001b86 <.Loc.361>:
  USBNWrite(MAMSK,mask);
    1b86:	0c 94 45 0b 	jmp	0x168a	; 0x168a <USBNWrite>

00001b8a <USBNAddToStringList>:
}



uint8_t USBNAddToStringList( void* data)
{
    1b8a:	cf 92       	push	r12
    1b8c:	df 92       	push	r13
    1b8e:	ef 92       	push	r14
    1b90:	ff 92       	push	r15
    1b92:	0f 93       	push	r16
    1b94:	1f 93       	push	r17
    1b96:	cf 93       	push	r28
    1b98:	df 93       	push	r29
    1b9a:	7c 01       	movw	r14, r24

00001b9c <.Loc.365>:
  uint8_t index=0;
  struct string_entry *tmp;

  //USBNDebug("add to string list\r\n");
  if(StringList == NULL)
    1b9c:	c0 90 e8 01 	lds	r12, 0x01E8	; 0x8001e8 <StringList>
    1ba0:	d0 90 e9 01 	lds	r13, 0x01E9	; 0x8001e9 <StringList+0x1>

00001ba4 <.Loc.369>:
  }
  else
  {
    //USBNDebug("next string element\r\n");
    
    index++;
    1ba4:	11 e0       	ldi	r17, 0x01	; 1

00001ba6 <.Loc.370>:
  if(StringList == NULL)
    1ba6:	c1 14       	cp	r12, r1
    1ba8:	d1 04       	cpc	r13, r1
    1baa:	d9 f4       	brne	.+54     	; 0x1be2 <.L78>

00001bac <.LBB4>:
    StringList = (struct string_entry*)malloc(sizeof(struct string_entry));
    1bac:	85 e0       	ldi	r24, 0x05	; 5
    1bae:	90 e0       	ldi	r25, 0x00	; 0

00001bb0 <.Loc.374>:
    1bb0:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

00001bb4 <.LVL122>:
    1bb4:	90 93 e9 01 	sts	0x01E9, r25	; 0x8001e9 <StringList+0x1>
    1bb8:	80 93 e8 01 	sts	0x01E8, r24	; 0x8001e8 <StringList>

00001bbc <.Loc.376>:
    StringList->data = data;
    1bbc:	fc 01       	movw	r30, r24
    1bbe:	e0 82       	st	Z, r14
    1bc0:	f1 82       	std	Z+1, r15	; 0x01

00001bc2 <.Loc.378>:
    StringList->index = 0;
    1bc2:	12 82       	std	Z+2, r1	; 0x02

00001bc4 <.Loc.380>:
    StringList->next = NULL;
    1bc4:	14 82       	std	Z+4, r1	; 0x04
    1bc6:	13 82       	std	Z+3, r1	; 0x03

00001bc8 <.Loc.382>:
    1bc8:	10 e0       	ldi	r17, 0x00	; 0

00001bca <.L77>:
    tmp->index = index;
    tmp->next=NULL;
  }
  //SendHex(index);    
  return index;
}
    1bca:	81 2f       	mov	r24, r17
    1bcc:	df 91       	pop	r29
    1bce:	cf 91       	pop	r28
    1bd0:	1f 91       	pop	r17
    1bd2:	0f 91       	pop	r16
    1bd4:	ff 90       	pop	r15
    1bd6:	ef 90       	pop	r14

00001bd8 <.Loc.386>:
    1bd8:	df 90       	pop	r13
    1bda:	cf 90       	pop	r12
    1bdc:	08 95       	ret

00001bde <.L80>:
      index++;
    1bde:	1f 5f       	subi	r17, 0xFF	; 255

00001be0 <.Loc.390>:
      tmp=tmp->next;
    1be0:	6c 01       	movw	r12, r24

00001be2 <.L78>:
    while(tmp->next != NULL)
    1be2:	f6 01       	movw	r30, r12
    1be4:	83 81       	ldd	r24, Z+3	; 0x03
    1be6:	94 81       	ldd	r25, Z+4	; 0x04

00001be8 <.Loc.393>:
    1be8:	00 97       	sbiw	r24, 0x00	; 0
    1bea:	c9 f7       	brne	.-14     	; 0x1bde <.L80>

00001bec <.Loc.394>:
    tmp->next = (struct string_entry*)malloc(sizeof(struct string_entry));
    1bec:	85 e0       	ldi	r24, 0x05	; 5
    1bee:	90 e0       	ldi	r25, 0x00	; 0
    1bf0:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

00001bf4 <.LVL129>:
    1bf4:	ec 01       	movw	r28, r24

00001bf6 <.Loc.396>:
    1bf6:	f6 01       	movw	r30, r12
    1bf8:	94 83       	std	Z+4, r25	; 0x04
    1bfa:	83 83       	std	Z+3, r24	; 0x03

00001bfc <.Loc.397>:
    tmp->data = data;
    1bfc:	e8 82       	st	Y, r14
    1bfe:	f9 82       	std	Y+1, r15	; 0x01

00001c00 <.Loc.400>:
    tmp->index = index;
    1c00:	1a 83       	std	Y+2, r17	; 0x02

00001c02 <.Loc.402>:
    tmp->next=NULL;
    1c02:	1c 82       	std	Y+4, r1	; 0x04
    1c04:	1b 82       	std	Y+3, r1	; 0x03

00001c06 <.Loc.404>:
  return index;
    1c06:	e1 cf       	rjmp	.-62     	; 0x1bca <.L77>

00001c08 <_USBNAddStringDescriptor>:
{
    1c08:	0f 93       	push	r16
    1c0a:	1f 93       	push	r17
    1c0c:	cf 93       	push	r28
    1c0e:	df 93       	push	r29
    1c10:	ec 01       	movw	r28, r24

00001c12 <.Loc.408>:
  char *newstring = (char*)malloc(strlen(string)*2+2);
    1c12:	fc 01       	movw	r30, r24

00001c14 <.L0^B1>:
    1c14:	01 90       	ld	r0, Z+
    1c16:	00 20       	and	r0, r0
    1c18:	e9 f7       	brne	.-6      	; 0x1c14 <.L0^B1>

00001c1a <.Loc.413>:
    1c1a:	cf 01       	movw	r24, r30

00001c1c <.Loc.414>:
    1c1c:	8c 1b       	sub	r24, r28
    1c1e:	9d 0b       	sbc	r25, r29

00001c20 <.Loc.415>:
    1c20:	88 0f       	add	r24, r24
    1c22:	99 1f       	adc	r25, r25
    1c24:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

00001c28 <.LVL134>:
    1c28:	8c 01       	movw	r16, r24

00001c2a <.Loc.416>:
  newstring[0]=(strlen(string)*2)+2; // length;
    1c2a:	fe 01       	movw	r30, r28

00001c2c <.L0^B2>:
    1c2c:	01 90       	ld	r0, Z+
    1c2e:	00 20       	and	r0, r0
    1c30:	e9 f7       	brne	.-6      	; 0x1c2c <.L0^B2>

00001c32 <.Loc.418>:
    1c32:	cf 01       	movw	r24, r30
    1c34:	8c 1b       	sub	r24, r28
    1c36:	9d 0b       	sbc	r25, r29

00001c38 <.Loc.419>:
    1c38:	88 0f       	add	r24, r24
    1c3a:	f8 01       	movw	r30, r16
    1c3c:	80 83       	st	Z, r24

00001c3e <.Loc.420>:
  newstring[1]=0x03; //Descriptor Type
    1c3e:	83 e0       	ldi	r24, 0x03	; 3
    1c40:	81 83       	std	Z+1, r24	; 0x01

00001c42 <.Loc.422>:
  for(i=0;i<strlen(string);i++)
    1c42:	9e 01       	movw	r18, r28
    1c44:	d8 01       	movw	r26, r16

00001c46 <.Loc.424>:
    1c46:	80 e0       	ldi	r24, 0x00	; 0
    1c48:	90 e0       	ldi	r25, 0x00	; 0

00001c4a <.L83>:
    1c4a:	fe 01       	movw	r30, r28

00001c4c <.L0^B3>:
    1c4c:	01 90       	ld	r0, Z+
    1c4e:	00 20       	and	r0, r0
    1c50:	e9 f7       	brne	.-6      	; 0x1c4c <.L0^B3>
    1c52:	31 97       	sbiw	r30, 0x01	; 1
    1c54:	ec 1b       	sub	r30, r28
    1c56:	fd 0b       	sbc	r31, r29

00001c58 <.Loc.427>:
    1c58:	12 96       	adiw	r26, 0x02	; 2

00001c5a <.Loc.428>:
    1c5a:	8e 17       	cp	r24, r30
    1c5c:	9f 07       	cpc	r25, r31
    1c5e:	48 f0       	brcs	.+18     	; 0x1c72 <.L84>

00001c60 <.Loc.429>:
  index = USBNAddToStringList((void*)newstring);
    1c60:	c8 01       	movw	r24, r16

00001c62 <.Loc.431>:
    1c62:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <USBNAddToStringList>

00001c66 <.LVL140>:
}
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	df 91       	pop	r29
    1c6a:	cf 91       	pop	r28

00001c6c <.Loc.434>:
    1c6c:	1f 91       	pop	r17
    1c6e:	0f 91       	pop	r16

00001c70 <.Loc.435>:
    1c70:	08 95       	ret

00001c72 <.L84>:
    newstring[j]=string[i];
    1c72:	f9 01       	movw	r30, r18
    1c74:	41 91       	ld	r20, Z+
    1c76:	9f 01       	movw	r18, r30

00001c78 <.Loc.438>:
    1c78:	4c 93       	st	X, r20

00001c7a <.Loc.439>:
    newstring[j+1]=0x00;
    1c7a:	11 96       	adiw	r26, 0x01	; 1
    1c7c:	1c 92       	st	X, r1
    1c7e:	11 97       	sbiw	r26, 0x01	; 1

00001c80 <.Loc.441>:
  for(i=0;i<strlen(string);i++)
    1c80:	01 96       	adiw	r24, 0x01	; 1

00001c82 <.Loc.443>:
    1c82:	e3 cf       	rjmp	.-58     	; 0x1c4a <.L83>

00001c84 <USBNDeviceManufacture>:
{
    1c84:	cf 93       	push	r28
    1c86:	df 93       	push	r29

00001c88 <.Loc.446>:
  index = _USBNAddStringDescriptor(manufacture);
    1c88:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <_USBNAddStringDescriptor>

00001c8c <.LVL148>:
  if(index>0)
    1c8c:	00 97       	sbiw	r24, 0x00	; 0
    1c8e:	11 f0       	breq	.+4      	; 0x1c94 <.L85>

00001c90 <.Loc.451>:
    DeviceDescriptor.iManufacturer = index;
    1c90:	80 93 fe 01 	sts	0x01FE, r24	; 0x8001fe <DeviceDescriptor+0xe>

00001c94 <.L85>:
}
    1c94:	df 91       	pop	r29
    1c96:	cf 91       	pop	r28
    1c98:	08 95       	ret

00001c9a <USBNDeviceProduct>:
{
    1c9a:	cf 93       	push	r28
    1c9c:	df 93       	push	r29

00001c9e <.Loc.456>:
  index = _USBNAddStringDescriptor(product);
    1c9e:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <_USBNAddStringDescriptor>

00001ca2 <.LVL151>:
  if(index>0)
    1ca2:	00 97       	sbiw	r24, 0x00	; 0
    1ca4:	11 f0       	breq	.+4      	; 0x1caa <.L90>

00001ca6 <.Loc.461>:
    DeviceDescriptor.iProduct = index;
    1ca6:	80 93 ff 01 	sts	0x01FF, r24	; 0x8001ff <DeviceDescriptor+0xf>

00001caa <.L90>:
}
    1caa:	df 91       	pop	r29
    1cac:	cf 91       	pop	r28
    1cae:	08 95       	ret

00001cb0 <USBNDeviceSerialNumber>:
{
    1cb0:	cf 93       	push	r28
    1cb2:	df 93       	push	r29

00001cb4 <.Loc.466>:
  index = _USBNAddStringDescriptor(serialnumber);
    1cb4:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <_USBNAddStringDescriptor>

00001cb8 <.LVL154>:
  if(index>0)
    1cb8:	00 97       	sbiw	r24, 0x00	; 0
    1cba:	11 f0       	breq	.+4      	; 0x1cc0 <.L95>

00001cbc <.Loc.471>:
    DeviceDescriptor.iSerialNumber = index;
    1cbc:	80 93 00 02 	sts	0x0200, r24	; 0x800200 <DeviceDescriptor+0x10>

00001cc0 <.L95>:
}
    1cc0:	df 91       	pop	r29
    1cc2:	cf 91       	pop	r28
    1cc4:	08 95       	ret

00001cc6 <USBNConfigurationName>:
{
    1cc6:	cf 93       	push	r28
    1cc8:	df 93       	push	r29
    1cca:	ec 01       	movw	r28, r24
    1ccc:	cb 01       	movw	r24, r22

00001cce <.Loc.476>:
  index = _USBNAddStringDescriptor(name);
    1cce:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <_USBNAddStringDescriptor>

00001cd2 <.LVL157>:
  struct list_entry *ptr = DescriptorList;
    1cd2:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <DescriptorList>
    1cd6:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <DescriptorList+0x1>

00001cda <.L101>:
  while(ptr != NULL) {
    1cda:	30 97       	sbiw	r30, 0x00	; 0
    1cdc:	19 f4       	brne	.+6      	; 0x1ce4 <.L103>

00001cde <.Loc.484>:
}
    1cde:	df 91       	pop	r29
    1ce0:	cf 91       	pop	r28

00001ce2 <.Loc.485>:
    1ce2:	08 95       	ret

00001ce4 <.L103>:
    if(ptr->type==0x02 && values[5]==configuration) // if descr = confi 
    1ce4:	92 81       	ldd	r25, Z+2	; 0x02
    1ce6:	92 30       	cpi	r25, 0x02	; 2
    1ce8:	51 f4       	brne	.+20     	; 0x1cfe <.L102>

00001cea <.Loc.489>:
    values = (char*)ptr->data;	      
    1cea:	a0 81       	ld	r26, Z
    1cec:	b1 81       	ldd	r27, Z+1	; 0x01

00001cee <.Loc.490>:
    if(ptr->type==0x02 && values[5]==configuration) // if descr = confi 
    1cee:	15 96       	adiw	r26, 0x05	; 5
    1cf0:	9c 91       	ld	r25, X
    1cf2:	15 97       	sbiw	r26, 0x05	; 5

00001cf4 <.Loc.491>:
    1cf4:	9c 17       	cp	r25, r28
    1cf6:	1d 06       	cpc	r1, r29
    1cf8:	11 f4       	brne	.+4      	; 0x1cfe <.L102>

00001cfa <.Loc.492>:
      values[6]=index;
    1cfa:	16 96       	adiw	r26, 0x06	; 6
    1cfc:	8c 93       	st	X, r24

00001cfe <.L102>:
    ptr=ptr->next;
    1cfe:	07 80       	ldd	r0, Z+7	; 0x07
    1d00:	f0 85       	ldd	r31, Z+8	; 0x08
    1d02:	e0 2d       	mov	r30, r0

00001d04 <.Loc.496>:
    1d04:	ea cf       	rjmp	.-44     	; 0x1cda <.L101>

00001d06 <USBNInterfaceName>:
{
    1d06:	0f 93       	push	r16
    1d08:	1f 93       	push	r17
    1d0a:	cf 93       	push	r28
    1d0c:	df 93       	push	r29
    1d0e:	ec 01       	movw	r28, r24
    1d10:	8b 01       	movw	r16, r22
    1d12:	ca 01       	movw	r24, r20

00001d14 <.Loc.499>:
  index = _USBNAddStringDescriptor(name);
    1d14:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <_USBNAddStringDescriptor>

00001d18 <.LVL165>:
  struct list_entry *ptr = DescriptorList;
    1d18:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <DescriptorList>
    1d1c:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <DescriptorList+0x1>

00001d20 <.L105>:
  while(ptr != NULL) {
    1d20:	30 97       	sbiw	r30, 0x00	; 0
    1d22:	29 f4       	brne	.+10     	; 0x1d2e <.L107>

00001d24 <.Loc.507>:
}
    1d24:	df 91       	pop	r29
    1d26:	cf 91       	pop	r28

00001d28 <.Loc.508>:
    1d28:	1f 91       	pop	r17
    1d2a:	0f 91       	pop	r16

00001d2c <.Loc.509>:
    1d2c:	08 95       	ret

00001d2e <.L107>:
    if(ptr->type==0x04 && ptr->conf==configuration && ptr->index==interface) // if descr = confi 
    1d2e:	92 81       	ldd	r25, Z+2	; 0x02
    1d30:	94 30       	cpi	r25, 0x04	; 4
    1d32:	61 f4       	brne	.+24     	; 0x1d4c <.L106>

00001d34 <.Loc.513>:
    1d34:	94 81       	ldd	r25, Z+4	; 0x04

00001d36 <.Loc.514>:
    1d36:	9c 17       	cp	r25, r28
    1d38:	1d 06       	cpc	r1, r29
    1d3a:	41 f4       	brne	.+16     	; 0x1d4c <.L106>

00001d3c <.Loc.515>:
    1d3c:	96 81       	ldd	r25, Z+6	; 0x06

00001d3e <.Loc.516>:
    1d3e:	90 17       	cp	r25, r16
    1d40:	11 06       	cpc	r1, r17
    1d42:	21 f4       	brne	.+8      	; 0x1d4c <.L106>

00001d44 <.Loc.517>:
    values = (char*)ptr->data;	      
    1d44:	a0 81       	ld	r26, Z
    1d46:	b1 81       	ldd	r27, Z+1	; 0x01

00001d48 <.Loc.518>:
      values[8]=index;
    1d48:	18 96       	adiw	r26, 0x08	; 8
    1d4a:	8c 93       	st	X, r24

00001d4c <.L106>:
    ptr=ptr->next;
    1d4c:	07 80       	ldd	r0, Z+7	; 0x07
    1d4e:	f0 85       	ldd	r31, Z+8	; 0x08
    1d50:	e0 2d       	mov	r30, r0

00001d52 <.Loc.522>:
    1d52:	e6 cf       	rjmp	.-52     	; 0x1d20 <.L105>

00001d54 <_USBNAddToList>:




void _USBNAddToList( void* data, uint8_t len,uint8_t type,uint8_t conf,uint8_t interf,uint8_t index)
{
    1d54:	9f 92       	push	r9
    1d56:	af 92       	push	r10
    1d58:	bf 92       	push	r11
    1d5a:	cf 92       	push	r12
    1d5c:	df 92       	push	r13
    1d5e:	ef 92       	push	r14
    1d60:	ff 92       	push	r15
    1d62:	0f 93       	push	r16
    1d64:	1f 93       	push	r17
    1d66:	cf 93       	push	r28
    1d68:	df 93       	push	r29
    1d6a:	98 2e       	mov	r9, r24
    1d6c:	a9 2e       	mov	r10, r25
    1d6e:	b6 2e       	mov	r11, r22
    1d70:	f4 2e       	mov	r15, r20
    1d72:	12 2f       	mov	r17, r18

00001d74 <.Loc.525>:
  struct list_entry *tmp;
  //USBNDebug("add to list\r\n");
  if(DescriptorList == NULL)
    1d74:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <DescriptorList>
    1d78:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <DescriptorList+0x1>

00001d7c <.Loc.528>:
    1d7c:	30 97       	sbiw	r30, 0x00	; 0
    1d7e:	f1 f4       	brne	.+60     	; 0x1dbc <.L109>

00001d80 <.Loc.529>:
  {
    //USBNDebug("first elemennt\r\n");
    DescriptorList = (struct list_entry*)malloc(sizeof(struct list_entry));
    1d80:	89 e0       	ldi	r24, 0x09	; 9
    1d82:	90 e0       	ldi	r25, 0x00	; 0

00001d84 <.Loc.531>:
    1d84:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

00001d88 <.LVL174>:
    1d88:	90 93 eb 01 	sts	0x01EB, r25	; 0x8001eb <DescriptorList+0x1>
    1d8c:	80 93 ea 01 	sts	0x01EA, r24	; 0x8001ea <DescriptorList>

00001d90 <.Loc.533>:

    DescriptorList->data = data;
    1d90:	fc 01       	movw	r30, r24
    1d92:	90 82       	st	Z, r9
    1d94:	a1 82       	std	Z+1, r10	; 0x01

00001d96 <.Loc.535>:
    DescriptorList->len = len;
    1d96:	b3 82       	std	Z+3, r11	; 0x03

00001d98 <.Loc.537>:
    DescriptorList->next = NULL;
    1d98:	10 86       	std	Z+8, r1	; 0x08
    1d9a:	17 82       	std	Z+7, r1	; 0x07

00001d9c <.Loc.539>:
    DescriptorList->type = type;
    1d9c:	f2 82       	std	Z+2, r15	; 0x02

00001d9e <.Loc.541>:
    DescriptorList->conf = conf;
    1d9e:	14 83       	std	Z+4, r17	; 0x04

00001da0 <.Loc.543>:
    DescriptorList->interf = interf;
    1da0:	05 83       	std	Z+5, r16	; 0x05

00001da2 <.Loc.545>:
    DescriptorList->index = index;
    1da2:	e6 82       	std	Z+6, r14	; 0x06

00001da4 <.L108>:
    tmp->conf = conf;
    tmp->interf = interf;
    tmp->index = index;
    tmp->next=NULL;
  }
}
    1da4:	df 91       	pop	r29
    1da6:	cf 91       	pop	r28
    1da8:	1f 91       	pop	r17

00001daa <.Loc.548>:
    1daa:	0f 91       	pop	r16

00001dac <.Loc.549>:
    1dac:	ff 90       	pop	r15

00001dae <.Loc.550>:
    1dae:	ef 90       	pop	r14

00001db0 <.Loc.551>:
    1db0:	df 90       	pop	r13
    1db2:	cf 90       	pop	r12
    1db4:	bf 90       	pop	r11

00001db6 <.Loc.552>:
    1db6:	af 90       	pop	r10
    1db8:	9f 90       	pop	r9
    1dba:	08 95       	ret

00001dbc <.L109>:
    while(tmp->next != NULL)
    1dbc:	6f 01       	movw	r12, r30

00001dbe <.Loc.554>:
    1dbe:	07 80       	ldd	r0, Z+7	; 0x07
    1dc0:	f0 85       	ldd	r31, Z+8	; 0x08
    1dc2:	e0 2d       	mov	r30, r0

00001dc4 <.Loc.555>:
    1dc4:	30 97       	sbiw	r30, 0x00	; 0
    1dc6:	d1 f7       	brne	.-12     	; 0x1dbc <.L109>

00001dc8 <.Loc.556>:
    tmp->next = (struct list_entry*)malloc(sizeof(struct list_entry));
    1dc8:	89 e0       	ldi	r24, 0x09	; 9
    1dca:	90 e0       	ldi	r25, 0x00	; 0

00001dcc <.Loc.558>:
    1dcc:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

00001dd0 <.LVL183>:
    1dd0:	ec 01       	movw	r28, r24

00001dd2 <.Loc.559>:
    1dd2:	f6 01       	movw	r30, r12
    1dd4:	90 87       	std	Z+8, r25	; 0x08
    1dd6:	87 83       	std	Z+7, r24	; 0x07

00001dd8 <.Loc.560>:
    tmp->data = data;
    1dd8:	98 82       	st	Y, r9
    1dda:	a9 82       	std	Y+1, r10	; 0x01

00001ddc <.Loc.563>:
    tmp->len = len;
    1ddc:	bb 82       	std	Y+3, r11	; 0x03

00001dde <.Loc.565>:
    tmp->type = type;
    1dde:	fa 82       	std	Y+2, r15	; 0x02

00001de0 <.Loc.567>:
    tmp->conf = conf;
    1de0:	1c 83       	std	Y+4, r17	; 0x04

00001de2 <.Loc.569>:
    tmp->interf = interf;
    1de2:	0d 83       	std	Y+5, r16	; 0x05

00001de4 <.Loc.571>:
    tmp->index = index;
    1de4:	ee 82       	std	Y+6, r14	; 0x06

00001de6 <.Loc.573>:
    tmp->next=NULL;
    1de6:	18 86       	std	Y+8, r1	; 0x08
    1de8:	1f 82       	std	Y+7, r1	; 0x07

00001dea <.Loc.575>:
}
    1dea:	dc cf       	rjmp	.-72     	; 0x1da4 <.L108>

00001dec <USBNAddConfiguration>:
{
    1dec:	ef 92       	push	r14
    1dee:	0f 93       	push	r16
    1df0:	1f 93       	push	r17
    1df2:	cf 93       	push	r28
    1df4:	df 93       	push	r29

00001df6 <.Loc.577>:
  index = ++DeviceDescriptor.bNumConfigurations;
    1df6:	e0 ef       	ldi	r30, 0xF0	; 240
    1df8:	f1 e0       	ldi	r31, 0x01	; 1

00001dfa <.Loc.580>:
    1dfa:	11 89       	ldd	r17, Z+17	; 0x11
    1dfc:	1f 5f       	subi	r17, 0xFF	; 255

00001dfe <.Loc.581>:
    1dfe:	11 8b       	std	Z+17, r17	; 0x11

00001e00 <.Loc.582>:
      (struct usb_configuration_descriptor*)malloc(sizeof(struct usb_configuration_descriptor));
    1e00:	89 e0       	ldi	r24, 0x09	; 9
    1e02:	90 e0       	ldi	r25, 0x00	; 0
    1e04:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

00001e08 <.LVL186>:
    1e08:	ec 01       	movw	r28, r24

00001e0a <.Loc.584>:
  conf->bLength=sizeof(struct usb_configuration_descriptor);
    1e0a:	89 e0       	ldi	r24, 0x09	; 9

00001e0c <.Loc.586>:
    1e0c:	88 83       	st	Y, r24

00001e0e <.Loc.587>:
  conf->wTotalLength=0x09; // will be updated when confarray has been built
    1e0e:	89 e0       	ldi	r24, 0x09	; 9
    1e10:	90 e0       	ldi	r25, 0x00	; 0
    1e12:	9b 83       	std	Y+3, r25	; 0x03
    1e14:	8a 83       	std	Y+2, r24	; 0x02

00001e16 <.Loc.589>:
  conf->bDescriptorType=0x02;
    1e16:	82 e0       	ldi	r24, 0x02	; 2
    1e18:	89 83       	std	Y+1, r24	; 0x01

00001e1a <.Loc.591>:
  conf->bNumInterfaces=0x00;
    1e1a:	1c 82       	std	Y+4, r1	; 0x04

00001e1c <.Loc.593>:
  conf->bConfigurationValue=index; // number of configuration
    1e1c:	1d 83       	std	Y+5, r17	; 0x05

00001e1e <.Loc.595>:
  conf->iConfiguration=0x00; // string index for configuration 
    1e1e:	1e 82       	std	Y+6, r1	; 0x06

00001e20 <.Loc.597>:
  conf->bmAttributes=0x80;  // bus powered
    1e20:	80 e8       	ldi	r24, 0x80	; 128
    1e22:	8f 83       	std	Y+7, r24	; 0x07

00001e24 <.Loc.599>:
  conf->MaxPower=0x1A;  // max power 
    1e24:	8a e1       	ldi	r24, 0x1A	; 26
    1e26:	88 87       	std	Y+8, r24	; 0x08

00001e28 <.Loc.601>:
  _USBNAddToList((void*)conf, 0x09,0x02,0,0,0);
    1e28:	e1 2c       	mov	r14, r1
    1e2a:	00 e0       	ldi	r16, 0x00	; 0
    1e2c:	20 e0       	ldi	r18, 0x00	; 0
    1e2e:	42 e0       	ldi	r20, 0x02	; 2
    1e30:	69 e0       	ldi	r22, 0x09	; 9
    1e32:	ce 01       	movw	r24, r28
    1e34:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <_USBNAddToList>

00001e38 <.LVL189>:
}
    1e38:	81 2f       	mov	r24, r17
    1e3a:	90 e0       	ldi	r25, 0x00	; 0
    1e3c:	df 91       	pop	r29
    1e3e:	cf 91       	pop	r28

00001e40 <.Loc.604>:
    1e40:	1f 91       	pop	r17

00001e42 <.Loc.605>:
    1e42:	0f 91       	pop	r16
    1e44:	ef 90       	pop	r14
    1e46:	08 95       	ret

00001e48 <USBNAddInterfaceClass>:
{
    1e48:	bf 92       	push	r11
    1e4a:	cf 92       	push	r12
    1e4c:	df 92       	push	r13
    1e4e:	ef 92       	push	r14
    1e50:	ff 92       	push	r15
    1e52:	0f 93       	push	r16
    1e54:	1f 93       	push	r17
    1e56:	cf 93       	push	r28
    1e58:	df 93       	push	r29
    1e5a:	18 2f       	mov	r17, r24
    1e5c:	b6 2e       	mov	r11, r22
    1e5e:	e4 2e       	mov	r14, r20
    1e60:	f2 2e       	mov	r15, r18

00001e62 <.Loc.608>:
  struct list_entry *ptr = DescriptorList;
    1e62:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <DescriptorList>
    1e66:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <DescriptorList+0x1>

00001e6a <.Loc.611>:
  int index=0;
    1e6a:	c1 2c       	mov	r12, r1
    1e6c:	d1 2c       	mov	r13, r1

00001e6e <.L115>:
  while(ptr != NULL) {
    1e6e:	30 97       	sbiw	r30, 0x00	; 0
    1e70:	19 f5       	brne	.+70     	; 0x1eb8 <.L117>

00001e72 <.Loc.615>:
  interf = (struct usb_interface_descriptor*)malloc(sizeof(struct usb_interface_descriptor));
    1e72:	89 e0       	ldi	r24, 0x09	; 9
    1e74:	90 e0       	ldi	r25, 0x00	; 0
    1e76:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

00001e7a <.LVL196>:
    1e7a:	ec 01       	movw	r28, r24

00001e7c <.Loc.619>:
  interf->bLength = 0x09;  
    1e7c:	89 e0       	ldi	r24, 0x09	; 9

00001e7e <.Loc.621>:
    1e7e:	88 83       	st	Y, r24

00001e80 <.Loc.622>:
  interf->bDescriptorType     = INTERFACE;
    1e80:	84 e0       	ldi	r24, 0x04	; 4
    1e82:	89 83       	std	Y+1, r24	; 0x01

00001e84 <.Loc.624>:
  interf->bInterfaceNumber     = number; // FIXME
    1e84:	ba 82       	std	Y+2, r11	; 0x02

00001e86 <.Loc.626>:
  interf->bAlternateSetting   = 0x00;
    1e86:	1b 82       	std	Y+3, r1	; 0x03

00001e88 <.Loc.628>:
  interf->bNumEndpoints       = 0x00;
    1e88:	1c 82       	std	Y+4, r1	; 0x04

00001e8a <.Loc.630>:
  interf->bInterfaceClass     = class;
    1e8a:	ed 82       	std	Y+5, r14	; 0x05

00001e8c <.Loc.632>:
  interf->bInterfaceSubClass   = subclass;
    1e8c:	fe 82       	std	Y+6, r15	; 0x06

00001e8e <.Loc.634>:
  interf->bInterfaceProtocol   = protocol;
    1e8e:	0f 83       	std	Y+7, r16	; 0x07

00001e90 <.Loc.636>:
  interf->iInterface           = 0x00;
    1e90:	18 86       	std	Y+8, r1	; 0x08

00001e92 <.Loc.638>:
  _USBNAddToList((void*)interf, 0x09,INTERFACE,(uint8_t)configuration,0,index);
    1e92:	ec 2c       	mov	r14, r12

00001e94 <.Loc.639>:
    1e94:	00 e0       	ldi	r16, 0x00	; 0

00001e96 <.Loc.640>:
    1e96:	21 2f       	mov	r18, r17
    1e98:	44 e0       	ldi	r20, 0x04	; 4
    1e9a:	69 e0       	ldi	r22, 0x09	; 9
    1e9c:	ce 01       	movw	r24, r28
    1e9e:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <_USBNAddToList>

00001ea2 <.LVL201>:
}
    1ea2:	c6 01       	movw	r24, r12
    1ea4:	df 91       	pop	r29
    1ea6:	cf 91       	pop	r28

00001ea8 <.Loc.643>:
    1ea8:	1f 91       	pop	r17
    1eaa:	0f 91       	pop	r16
    1eac:	ff 90       	pop	r15

00001eae <.Loc.644>:
    1eae:	ef 90       	pop	r14
    1eb0:	df 90       	pop	r13
    1eb2:	cf 90       	pop	r12

00001eb4 <.Loc.645>:
    1eb4:	bf 90       	pop	r11
    1eb6:	08 95       	ret

00001eb8 <.L117>:
    values = (char*)ptr->data;	      
    1eb8:	a0 81       	ld	r26, Z
    1eba:	b1 81       	ldd	r27, Z+1	; 0x01

00001ebc <.Loc.648>:
    if(values[5]==(char)configuration && ptr->type==0x02) // if descr = confi 
    1ebc:	15 96       	adiw	r26, 0x05	; 5
    1ebe:	8c 91       	ld	r24, X
    1ec0:	15 97       	sbiw	r26, 0x05	; 5
    1ec2:	81 13       	cpse	r24, r17
    1ec4:	0a c0       	rjmp	.+20     	; 0x1eda <.L116>

00001ec6 <.Loc.650>:
    1ec6:	82 81       	ldd	r24, Z+2	; 0x02
    1ec8:	82 30       	cpi	r24, 0x02	; 2
    1eca:	39 f4       	brne	.+14     	; 0x1eda <.L116>

00001ecc <.Loc.651>:
      values[4]++;
    1ecc:	14 96       	adiw	r26, 0x04	; 4
    1ece:	cc 90       	ld	r12, X
    1ed0:	14 97       	sbiw	r26, 0x04	; 4

00001ed2 <.Loc.653>:
    1ed2:	c3 94       	inc	r12
    1ed4:	14 96       	adiw	r26, 0x04	; 4
    1ed6:	cc 92       	st	X, r12

00001ed8 <.Loc.654>:
      index =  values[4];
    1ed8:	d1 2c       	mov	r13, r1

00001eda <.L116>:
    ptr=ptr->next;
    1eda:	07 80       	ldd	r0, Z+7	; 0x07
    1edc:	f0 85       	ldd	r31, Z+8	; 0x08
    1ede:	e0 2d       	mov	r30, r0

00001ee0 <.Loc.658>:
    1ee0:	c6 cf       	rjmp	.-116    	; 0x1e6e <.L115>

00001ee2 <USBNAddInterface>:
{
    1ee2:	cf 92       	push	r12
    1ee4:	df 92       	push	r13
    1ee6:	ef 92       	push	r14
    1ee8:	0f 93       	push	r16
    1eea:	1f 93       	push	r17
    1eec:	cf 93       	push	r28
    1eee:	df 93       	push	r29
    1ef0:	18 2f       	mov	r17, r24
    1ef2:	06 2f       	mov	r16, r22

00001ef4 <.Loc.661>:
  struct list_entry *ptr = DescriptorList;
    1ef4:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <DescriptorList>
    1ef8:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <DescriptorList+0x1>

00001efc <.Loc.664>:
  int index=0;
    1efc:	c1 2c       	mov	r12, r1
    1efe:	d1 2c       	mov	r13, r1

00001f00 <.L119>:
  while(ptr != NULL) {
    1f00:	30 97       	sbiw	r30, 0x00	; 0
    1f02:	09 f5       	brne	.+66     	; 0x1f46 <.L121>

00001f04 <.Loc.668>:
  interf = (struct usb_interface_descriptor*)malloc(sizeof(struct usb_interface_descriptor));
    1f04:	89 e0       	ldi	r24, 0x09	; 9
    1f06:	90 e0       	ldi	r25, 0x00	; 0
    1f08:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

00001f0c <.LVL214>:
    1f0c:	ec 01       	movw	r28, r24

00001f0e <.Loc.672>:
  interf->bLength = 0x09;  
    1f0e:	89 e0       	ldi	r24, 0x09	; 9

00001f10 <.Loc.674>:
    1f10:	88 83       	st	Y, r24

00001f12 <.Loc.675>:
  interf->bDescriptorType     = INTERFACE;
    1f12:	84 e0       	ldi	r24, 0x04	; 4
    1f14:	89 83       	std	Y+1, r24	; 0x01

00001f16 <.Loc.677>:
  interf->bInterfaceNumber     = number; // FIXME
    1f16:	0a 83       	std	Y+2, r16	; 0x02

00001f18 <.Loc.679>:
  interf->bAlternateSetting   = 0x00;
    1f18:	1b 82       	std	Y+3, r1	; 0x03

00001f1a <.Loc.681>:
  interf->bNumEndpoints       = 0x00;
    1f1a:	1c 82       	std	Y+4, r1	; 0x04

00001f1c <.Loc.683>:
  interf->bInterfaceClass     = 0x00;
    1f1c:	1d 82       	std	Y+5, r1	; 0x05

00001f1e <.Loc.685>:
  interf->bInterfaceSubClass   = 0x00;
    1f1e:	1e 82       	std	Y+6, r1	; 0x06

00001f20 <.Loc.687>:
  interf->bInterfaceProtocol   = 0x00;
    1f20:	1f 82       	std	Y+7, r1	; 0x07

00001f22 <.Loc.689>:
  interf->iInterface           = 0x00;
    1f22:	18 86       	std	Y+8, r1	; 0x08

00001f24 <.Loc.691>:
  _USBNAddToList((void*)interf, 0x09,INTERFACE,(uint8_t)configuration,0,index);
    1f24:	ec 2c       	mov	r14, r12
    1f26:	00 e0       	ldi	r16, 0x00	; 0
    1f28:	21 2f       	mov	r18, r17
    1f2a:	44 e0       	ldi	r20, 0x04	; 4
    1f2c:	69 e0       	ldi	r22, 0x09	; 9
    1f2e:	ce 01       	movw	r24, r28
    1f30:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <_USBNAddToList>

00001f34 <.LVL217>:
}
    1f34:	c6 01       	movw	r24, r12
    1f36:	df 91       	pop	r29
    1f38:	cf 91       	pop	r28

00001f3a <.Loc.694>:
    1f3a:	1f 91       	pop	r17
    1f3c:	0f 91       	pop	r16
    1f3e:	ef 90       	pop	r14
    1f40:	df 90       	pop	r13
    1f42:	cf 90       	pop	r12

00001f44 <.Loc.695>:
    1f44:	08 95       	ret

00001f46 <.L121>:
    values = (char*)ptr->data;	      
    1f46:	a0 81       	ld	r26, Z
    1f48:	b1 81       	ldd	r27, Z+1	; 0x01

00001f4a <.Loc.698>:
    if(values[5]==(char)configuration && ptr->type==0x02) // if descr = confi 
    1f4a:	15 96       	adiw	r26, 0x05	; 5
    1f4c:	8c 91       	ld	r24, X
    1f4e:	15 97       	sbiw	r26, 0x05	; 5
    1f50:	81 13       	cpse	r24, r17
    1f52:	0a c0       	rjmp	.+20     	; 0x1f68 <.L120>

00001f54 <.Loc.700>:
    1f54:	82 81       	ldd	r24, Z+2	; 0x02
    1f56:	82 30       	cpi	r24, 0x02	; 2
    1f58:	39 f4       	brne	.+14     	; 0x1f68 <.L120>

00001f5a <.Loc.701>:
      values[4]++;
    1f5a:	14 96       	adiw	r26, 0x04	; 4
    1f5c:	cc 90       	ld	r12, X
    1f5e:	14 97       	sbiw	r26, 0x04	; 4

00001f60 <.Loc.703>:
    1f60:	c3 94       	inc	r12
    1f62:	14 96       	adiw	r26, 0x04	; 4
    1f64:	cc 92       	st	X, r12

00001f66 <.Loc.704>:
      index =  values[4];
    1f66:	d1 2c       	mov	r13, r1

00001f68 <.L120>:
    ptr=ptr->next;
    1f68:	07 80       	ldd	r0, Z+7	; 0x07
    1f6a:	f0 85       	ldd	r31, Z+8	; 0x08
    1f6c:	e0 2d       	mov	r30, r0

00001f6e <.Loc.708>:
    1f6e:	c8 cf       	rjmp	.-112    	; 0x1f00 <.L119>

00001f70 <_USBNAddEndpoint>:
{
    1f70:	8f 92       	push	r8
    1f72:	9f 92       	push	r9
    1f74:	af 92       	push	r10
    1f76:	bf 92       	push	r11
    1f78:	cf 92       	push	r12
    1f7a:	ef 92       	push	r14
    1f7c:	ff 92       	push	r15
    1f7e:	0f 93       	push	r16
    1f80:	1f 93       	push	r17
    1f82:	cf 93       	push	r28
    1f84:	df 93       	push	r29
    1f86:	5c 01       	movw	r10, r24
    1f88:	4b 01       	movw	r8, r22
    1f8a:	12 2f       	mov	r17, r18

00001f8c <.Loc.711>:
  struct list_entry *ptr = DescriptorList;
    1f8c:	e0 91 ea 01 	lds	r30, 0x01EA	; 0x8001ea <DescriptorList>
    1f90:	f0 91 eb 01 	lds	r31, 0x01EB	; 0x8001eb <DescriptorList+0x1>

00001f94 <.L123>:
  while(ptr != NULL) {
    1f94:	30 97       	sbiw	r30, 0x00	; 0
    1f96:	11 f5       	brne	.+68     	; 0x1fdc <.L125>

00001f98 <.Loc.716>:
  endpoint = (struct usb_endpoint_descriptor*)malloc(sizeof(struct usb_endpoint_descriptor));
    1f98:	87 e0       	ldi	r24, 0x07	; 7
    1f9a:	90 e0       	ldi	r25, 0x00	; 0
    1f9c:	0e 94 89 11 	call	0x2312	; 0x2312 <malloc>

00001fa0 <.LVL227>:
    1fa0:	ec 01       	movw	r28, r24

00001fa2 <.Loc.720>:
  endpoint->bLength=sizeof(struct usb_endpoint_descriptor);
    1fa2:	87 e0       	ldi	r24, 0x07	; 7

00001fa4 <.Loc.722>:
    1fa4:	88 83       	st	Y, r24

00001fa6 <.Loc.723>:
  endpoint->bDescriptorType   = ENDPOINT;
    1fa6:	85 e0       	ldi	r24, 0x05	; 5
    1fa8:	89 83       	std	Y+1, r24	; 0x01

00001faa <.Loc.725>:
  endpoint->bEndpointAddress   = (unsigned char)epadr;
    1faa:	1a 83       	std	Y+2, r17	; 0x02

00001fac <.Loc.727>:
  endpoint->bmAttributes       = attr;
    1fac:	0b 83       	std	Y+3, r16	; 0x03

00001fae <.Loc.729>:
  endpoint->wMaxPacketSize    = (short int)fifosize;  
    1fae:	ec 82       	std	Y+4, r14	; 0x04
    1fb0:	fd 82       	std	Y+5, r15	; 0x05

00001fb2 <.Loc.731>:
  endpoint->bIntervall        = (unsigned char)intervall;  
    1fb2:	ce 82       	std	Y+6, r12	; 0x06

00001fb4 <.Loc.733>:
  _USBNAddToList((void*)endpoint, 0x07,ENDPOINT,
    1fb4:	e1 2c       	mov	r14, r1

00001fb6 <.Loc.734>:
    1fb6:	08 2d       	mov	r16, r8

00001fb8 <.Loc.735>:
    1fb8:	2a 2d       	mov	r18, r10
    1fba:	45 e0       	ldi	r20, 0x05	; 5
    1fbc:	67 e0       	ldi	r22, 0x07	; 7
    1fbe:	ce 01       	movw	r24, r28
    1fc0:	0e 94 aa 0e 	call	0x1d54	; 0x1d54 <_USBNAddToList>

00001fc4 <.LVL232>:
}
    1fc4:	df 91       	pop	r29
    1fc6:	cf 91       	pop	r28

00001fc8 <.Loc.737>:
    1fc8:	1f 91       	pop	r17
    1fca:	0f 91       	pop	r16
    1fcc:	ff 90       	pop	r15
    1fce:	ef 90       	pop	r14
    1fd0:	cf 90       	pop	r12

00001fd2 <.Loc.738>:
    1fd2:	bf 90       	pop	r11
    1fd4:	af 90       	pop	r10

00001fd6 <.Loc.739>:
    1fd6:	9f 90       	pop	r9
    1fd8:	8f 90       	pop	r8

00001fda <.Loc.740>:
    1fda:	08 95       	ret

00001fdc <.L125>:
    if(configuration==ptr->conf && ptr->index==interface && ptr->type==0x04) // if descr = confi 
    1fdc:	84 81       	ldd	r24, Z+4	; 0x04

00001fde <.Loc.744>:
    1fde:	8a 15       	cp	r24, r10
    1fe0:	1b 04       	cpc	r1, r11
    1fe2:	79 f4       	brne	.+30     	; 0x2002 <.L124>

00001fe4 <.Loc.745>:
    1fe4:	86 81       	ldd	r24, Z+6	; 0x06

00001fe6 <.Loc.746>:
    1fe6:	88 15       	cp	r24, r8
    1fe8:	19 04       	cpc	r1, r9
    1fea:	59 f4       	brne	.+22     	; 0x2002 <.L124>

00001fec <.Loc.747>:
    1fec:	82 81       	ldd	r24, Z+2	; 0x02
    1fee:	84 30       	cpi	r24, 0x04	; 4
    1ff0:	41 f4       	brne	.+16     	; 0x2002 <.L124>

00001ff2 <.Loc.748>:
    values = (char*)ptr->data;	      
    1ff2:	a0 81       	ld	r26, Z
    1ff4:	b1 81       	ldd	r27, Z+1	; 0x01

00001ff6 <.Loc.749>:
      values[4]++;
    1ff6:	14 96       	adiw	r26, 0x04	; 4
    1ff8:	8c 91       	ld	r24, X
    1ffa:	14 97       	sbiw	r26, 0x04	; 4
    1ffc:	8f 5f       	subi	r24, 0xFF	; 255
    1ffe:	14 96       	adiw	r26, 0x04	; 4
    2000:	8c 93       	st	X, r24

00002002 <.L124>:
    ptr=ptr->next;
    2002:	07 80       	ldd	r0, Z+7	; 0x07
    2004:	f0 85       	ldd	r31, Z+8	; 0x08
    2006:	e0 2d       	mov	r30, r0

00002008 <.Loc.753>:
    2008:	c5 cf       	rjmp	.-118    	; 0x1f94 <.L123>

0000200a <USBNAddOutEndpoint>:
{
    200a:	af 92       	push	r10
    200c:	bf 92       	push	r11
    200e:	cf 92       	push	r12
    2010:	df 92       	push	r13
    2012:	ef 92       	push	r14
    2014:	ff 92       	push	r15
    2016:	0f 93       	push	r16
    2018:	fa 01       	movw	r30, r20

0000201a <.Loc.756>:
  switch(epnr)
    201a:	42 30       	cpi	r20, 0x02	; 2
    201c:	51 05       	cpc	r21, r1
    201e:	c1 f0       	breq	.+48     	; 0x2050 <.L127>
    2020:	43 30       	cpi	r20, 0x03	; 3
    2022:	51 05       	cpc	r21, r1
    2024:	e9 f0       	breq	.+58     	; 0x2060 <.L128>
    2026:	41 30       	cpi	r20, 0x01	; 1
    2028:	51 05       	cpc	r21, r1
    202a:	39 f4       	brne	.+14     	; 0x203a <.L129>

0000202c <.Loc.757>:
    case 1: rxfifos.rx1=1; rxfifos.func1 = fkt; break;
    202c:	41 e0       	ldi	r20, 0x01	; 1

0000202e <.Loc.759>:
    202e:	40 93 02 02 	sts	0x0202, r20	; 0x800202 <rxfifos>

00002032 <.Loc.760>:
    2032:	a0 92 05 02 	sts	0x0205, r10	; 0x800205 <rxfifos+0x3>
    2036:	b0 92 06 02 	sts	0x0206, r11	; 0x800206 <rxfifos+0x4>

0000203a <.L129>:
  _USBNAddEndpoint(configuration,interface,epnr,epadr,attr,fifosize,intervall);
    203a:	af 01       	movw	r20, r30
    203c:	0e 94 b8 0f 	call	0x1f70	; 0x1f70 <_USBNAddEndpoint>

00002040 <.LVL242>:
}
    2040:	0f 91       	pop	r16

00002042 <.Loc.765>:
    2042:	ff 90       	pop	r15
    2044:	ef 90       	pop	r14

00002046 <.Loc.766>:
    2046:	df 90       	pop	r13
    2048:	cf 90       	pop	r12

0000204a <.Loc.767>:
    204a:	bf 90       	pop	r11
    204c:	af 90       	pop	r10

0000204e <.Loc.768>:
    204e:	08 95       	ret

00002050 <.L127>:
    case 2: rxfifos.rx2=1; rxfifos.func2 = fkt; break;
    2050:	41 e0       	ldi	r20, 0x01	; 1

00002052 <.Loc.771>:
    2052:	40 93 03 02 	sts	0x0203, r20	; 0x800203 <rxfifos+0x1>

00002056 <.Loc.772>:
    2056:	a0 92 07 02 	sts	0x0207, r10	; 0x800207 <rxfifos+0x5>
    205a:	b0 92 08 02 	sts	0x0208, r11	; 0x800208 <rxfifos+0x6>

0000205e <.Loc.774>:
    205e:	ed cf       	rjmp	.-38     	; 0x203a <.L129>

00002060 <.L128>:
    case 3: rxfifos.rx3=1; rxfifos.func3 = fkt; break;
    2060:	41 e0       	ldi	r20, 0x01	; 1

00002062 <.Loc.777>:
    2062:	40 93 04 02 	sts	0x0204, r20	; 0x800204 <rxfifos+0x2>

00002066 <.Loc.778>:
    2066:	a0 92 09 02 	sts	0x0209, r10	; 0x800209 <rxfifos+0x7>
    206a:	b0 92 0a 02 	sts	0x020A, r11	; 0x80020a <rxfifos+0x8>

0000206e <.Loc.780>:
    206e:	e5 cf       	rjmp	.-54     	; 0x203a <.L129>

00002070 <USBNAddInEndpoint>:
{
    2070:	af 92       	push	r10
    2072:	bf 92       	push	r11
    2074:	cf 92       	push	r12
    2076:	df 92       	push	r13
    2078:	ef 92       	push	r14
    207a:	ff 92       	push	r15
    207c:	0f 93       	push	r16
    207e:	cf 93       	push	r28
    2080:	df 93       	push	r29
    2082:	fa 01       	movw	r30, r20
    2084:	e9 01       	movw	r28, r18
    2086:	d5 01       	movw	r26, r10

00002088 <.Loc.783>:
  if(fkt!=NULL)
    2088:	ab 2b       	or	r26, r27
    208a:	81 f0       	breq	.+32     	; 0x20ac <.L131>

0000208c <.Loc.785>:
    switch(epnr)
    208c:	42 30       	cpi	r20, 0x02	; 2
    208e:	51 05       	cpc	r21, r1
    2090:	e9 f0       	breq	.+58     	; 0x20cc <.L132>
    2092:	43 30       	cpi	r20, 0x03	; 3
    2094:	51 05       	cpc	r21, r1
    2096:	11 f1       	breq	.+68     	; 0x20dc <.L133>
    2098:	41 30       	cpi	r20, 0x01	; 1
    209a:	51 05       	cpc	r21, r1
    209c:	39 f4       	brne	.+14     	; 0x20ac <.L131>

0000209e <.Loc.786>:
      case 1: txfifos.tx1=1; txfifos.func1 = fkt; break;
    209e:	21 e0       	ldi	r18, 0x01	; 1

000020a0 <.Loc.788>:
    20a0:	20 93 0d 02 	sts	0x020D, r18	; 0x80020d <txfifos>

000020a4 <.Loc.789>:
    20a4:	b0 92 11 02 	sts	0x0211, r11	; 0x800211 <txfifos+0x4>
    20a8:	a0 92 10 02 	sts	0x0210, r10	; 0x800210 <txfifos+0x3>

000020ac <.L131>:
  _USBNAddEndpoint(configuration,interface,epnr,epadr+0x80,attr,fifosize,intervall);
    20ac:	9e 01       	movw	r18, r28
    20ae:	20 58       	subi	r18, 0x80	; 128
    20b0:	3f 4f       	sbci	r19, 0xFF	; 255
    20b2:	af 01       	movw	r20, r30

000020b4 <.Loc.793>:
    20b4:	0e 94 b8 0f 	call	0x1f70	; 0x1f70 <_USBNAddEndpoint>

000020b8 <.LVL254>:
}
    20b8:	df 91       	pop	r29
    20ba:	cf 91       	pop	r28

000020bc <.Loc.795>:
    20bc:	0f 91       	pop	r16

000020be <.Loc.796>:
    20be:	ff 90       	pop	r15
    20c0:	ef 90       	pop	r14

000020c2 <.Loc.797>:
    20c2:	df 90       	pop	r13
    20c4:	cf 90       	pop	r12

000020c6 <.Loc.798>:
    20c6:	bf 90       	pop	r11
    20c8:	af 90       	pop	r10

000020ca <.Loc.799>:
    20ca:	08 95       	ret

000020cc <.L132>:
      case 2: txfifos.tx2=1; txfifos.func2 = fkt; break;
    20cc:	21 e0       	ldi	r18, 0x01	; 1

000020ce <.Loc.802>:
    20ce:	20 93 0e 02 	sts	0x020E, r18	; 0x80020e <txfifos+0x1>

000020d2 <.Loc.803>:
    20d2:	b0 92 13 02 	sts	0x0213, r11	; 0x800213 <txfifos+0x6>
    20d6:	a0 92 12 02 	sts	0x0212, r10	; 0x800212 <txfifos+0x5>

000020da <.Loc.805>:
    20da:	e8 cf       	rjmp	.-48     	; 0x20ac <.L131>

000020dc <.L133>:
      case 3: txfifos.tx3=1; txfifos.func3 = fkt; break;
    20dc:	21 e0       	ldi	r18, 0x01	; 1

000020de <.Loc.808>:
    20de:	20 93 0f 02 	sts	0x020F, r18	; 0x80020f <txfifos+0x2>

000020e2 <.Loc.809>:
    20e2:	b0 92 15 02 	sts	0x0215, r11	; 0x800215 <txfifos+0x8>
    20e6:	a0 92 14 02 	sts	0x0214, r10	; 0x800214 <txfifos+0x7>

000020ea <.Loc.811>:
    20ea:	e0 cf       	rjmp	.-64     	; 0x20ac <.L131>

000020ec <fifo_init>:
#include "fifo.h"

void fifo_init (fifo_t *f, char *buffer, const int size)
{
    20ec:	fc 01       	movw	r30, r24

000020ee <.Loc.2>:
  f->count = 0;
    20ee:	11 82       	std	Z+1, r1	; 0x01
    20f0:	10 82       	st	Z, r1

000020f2 <.Loc.4>:
  f->pread = f->pwrite = buffer;
    20f2:	66 83       	std	Z+6, r22	; 0x06
    20f4:	77 83       	std	Z+7, r23	; 0x07

000020f6 <.Loc.6>:
    20f6:	64 83       	std	Z+4, r22	; 0x04
    20f8:	75 83       	std	Z+5, r23	; 0x05

000020fa <.Loc.7>:
  f->read2end = f->write2end = f->size = size;
    20fa:	42 83       	std	Z+2, r20	; 0x02
    20fc:	53 83       	std	Z+3, r21	; 0x03

000020fe <.Loc.9>:
    20fe:	42 87       	std	Z+10, r20	; 0x0a
    2100:	53 87       	std	Z+11, r21	; 0x0b

00002102 <.Loc.10>:
    2102:	40 87       	std	Z+8, r20	; 0x08
    2104:	51 87       	std	Z+9, r21	; 0x09

00002106 <.Loc.11>:
  f->spinlock = 0xFF;
    2106:	8f ef       	ldi	r24, 0xFF	; 255

00002108 <.Loc.13>:
    2108:	84 87       	std	Z+12, r24	; 0x0c

0000210a <.Loc.14>:
}
    210a:	08 95       	ret

0000210c <fifo_put>:

int fifo_put (fifo_t *f, const char data)
{
    210c:	fc 01       	movw	r30, r24

0000210e <.LBB4>:
}

static inline int 
_inline_fifo_put (fifo_t *f, const char data)
{
	if (f->count >= f->size)
    210e:	20 81       	ld	r18, Z
    2110:	31 81       	ldd	r19, Z+1	; 0x01

00002112 <.Loc.21>:
    2112:	82 81       	ldd	r24, Z+2	; 0x02
    2114:	93 81       	ldd	r25, Z+3	; 0x03

00002116 <.Loc.22>:
    2116:	28 17       	cp	r18, r24
    2118:	39 07       	cpc	r19, r25
    211a:	bc f4       	brge	.+46     	; 0x214a <.L5>

0000211c <.Loc.23>:
		return 0;
		
	char * pwrite = f->pwrite;
	
	*(pwrite++) = data;
    211c:	a6 81       	ldd	r26, Z+6	; 0x06
    211e:	b7 81       	ldd	r27, Z+7	; 0x07

00002120 <.Loc.26>:
    2120:	6d 93       	st	X+, r22

00002122 <.Loc.27>:
	
	int write2end = f->write2end;
    2122:	82 85       	ldd	r24, Z+10	; 0x0a
    2124:	93 85       	ldd	r25, Z+11	; 0x0b

00002126 <.Loc.29>:
	
	if (--write2end == 0)
    2126:	01 97       	sbiw	r24, 0x01	; 1

00002128 <.Loc.31>:
    2128:	21 f4       	brne	.+8      	; 0x2132 <.L4>

0000212a <.Loc.32>:
	{
		write2end = f->size;
    212a:	82 81       	ldd	r24, Z+2	; 0x02
    212c:	93 81       	ldd	r25, Z+3	; 0x03

0000212e <.Loc.34>:
		pwrite -= write2end;
    212e:	a8 1b       	sub	r26, r24
    2130:	b9 0b       	sbc	r27, r25

00002132 <.L4>:
	}
	
	f->write2end = write2end;
    2132:	93 87       	std	Z+11, r25	; 0x0b
    2134:	82 87       	std	Z+10, r24	; 0x0a

00002136 <.Loc.38>:
	f->pwrite = pwrite;
    2136:	b7 83       	std	Z+7, r27	; 0x07
    2138:	a6 83       	std	Z+6, r26	; 0x06

0000213a <.Loc.40>:

	//uint8_t sreg = SREG;
	//cli();-
	//_inline_fifo_lock(f);
	f->count++;
    213a:	80 81       	ld	r24, Z
    213c:	91 81       	ldd	r25, Z+1	; 0x01

0000213e <.Loc.42>:
    213e:	01 96       	adiw	r24, 0x01	; 1
    2140:	91 83       	std	Z+1, r25	; 0x01
    2142:	80 83       	st	Z, r24

00002144 <.Loc.43>:
	//_inline_fifo_unlock(f);
	//SREG = sreg;
	
	return 1;
    2144:	81 e0       	ldi	r24, 0x01	; 1
    2146:	90 e0       	ldi	r25, 0x00	; 0
    2148:	08 95       	ret

0000214a <.L5>:
		return 0;
    214a:	80 e0       	ldi	r24, 0x00	; 0
    214c:	90 e0       	ldi	r25, 0x00	; 0

0000214e <.LBE4>:
  return _inline_fifo_put (f, data);
}
    214e:	08 95       	ret

00002150 <fifo_get_wait>:

char fifo_get_wait (fifo_t *f)
{
    2150:	fc 01       	movw	r30, r24

00002152 <.L7>:
  while (!f->count)
    2152:	80 81       	ld	r24, Z
    2154:	91 81       	ldd	r25, Z+1	; 0x01

00002156 <.Loc.53>:
    2156:	89 2b       	or	r24, r25
    2158:	e1 f3       	breq	.-8      	; 0x2152 <.L7>

0000215a <.LBB8>:

static inline int 
_inline_fifo_get (fifo_t *f)
{
	char *pread = f->pread;
	char data = *(pread++);
    215a:	a4 81       	ldd	r26, Z+4	; 0x04
    215c:	b5 81       	ldd	r27, Z+5	; 0x05

0000215e <.Loc.59>:
    215e:	8d 91       	ld	r24, X+

00002160 <.Loc.60>:
	int read2end = f->read2end;
    2160:	20 85       	ldd	r18, Z+8	; 0x08
    2162:	31 85       	ldd	r19, Z+9	; 0x09

00002164 <.Loc.62>:
	
	if (--read2end == 0)
    2164:	21 50       	subi	r18, 0x01	; 1
    2166:	30 40       	sbci	r19, 0x00	; 0

00002168 <.Loc.64>:
    2168:	21 f4       	brne	.+8      	; 0x2172 <.L8>

0000216a <.Loc.65>:
	{
		read2end = f->size;
    216a:	22 81       	ldd	r18, Z+2	; 0x02
    216c:	33 81       	ldd	r19, Z+3	; 0x03

0000216e <.Loc.67>:
		pread -= read2end;
    216e:	a2 1b       	sub	r26, r18
    2170:	b3 0b       	sbc	r27, r19

00002172 <.L8>:
	}
	
	f->pread = pread;
    2172:	b5 83       	std	Z+5, r27	; 0x05
    2174:	a4 83       	std	Z+4, r26	; 0x04

00002176 <.Loc.71>:
	f->read2end = read2end;
    2176:	31 87       	std	Z+9, r19	; 0x09
    2178:	20 87       	std	Z+8, r18	; 0x08

0000217a <.Loc.73>:
	
	//uint8_t sreg = SREG;
	//cli();
	//_inline_fifo_lock(f);
	f->count--;
    217a:	20 81       	ld	r18, Z
    217c:	31 81       	ldd	r19, Z+1	; 0x01

0000217e <.Loc.75>:
    217e:	21 50       	subi	r18, 0x01	; 1
    2180:	31 09       	sbc	r19, r1
    2182:	31 83       	std	Z+1, r19	; 0x01
    2184:	20 83       	st	Z, r18

00002186 <.LBE8>:
  ;
    return _inline_fifo_get (f);	
}
    2186:	08 95       	ret

00002188 <fifo_get_nowait>:

int fifo_get_nowait (fifo_t *f, char *entry)
{
    2188:	cf 93       	push	r28
    218a:	df 93       	push	r29
    218c:	fc 01       	movw	r30, r24
    218e:	eb 01       	movw	r28, r22

00002190 <.Loc.81>:
  if (f->count <=0) {
    2190:	80 81       	ld	r24, Z
    2192:	91 81       	ldd	r25, Z+1	; 0x01

00002194 <.Loc.83>:
    2194:	18 16       	cp	r1, r24
    2196:	19 06       	cpc	r1, r25
    2198:	d4 f4       	brge	.+52     	; 0x21ce <.L14>

0000219a <.LBB12>:
	char data = *(pread++);
    219a:	a4 81       	ldd	r26, Z+4	; 0x04
    219c:	b5 81       	ldd	r27, Z+5	; 0x05

0000219e <.Loc.89>:
    219e:	2d 91       	ld	r18, X+

000021a0 <.Loc.90>:
	int read2end = f->read2end;
    21a0:	80 85       	ldd	r24, Z+8	; 0x08
    21a2:	91 85       	ldd	r25, Z+9	; 0x09

000021a4 <.Loc.92>:
	if (--read2end == 0)
    21a4:	01 97       	sbiw	r24, 0x01	; 1

000021a6 <.Loc.94>:
    21a6:	21 f4       	brne	.+8      	; 0x21b0 <.L13>

000021a8 <.Loc.95>:
		read2end = f->size;
    21a8:	82 81       	ldd	r24, Z+2	; 0x02
    21aa:	93 81       	ldd	r25, Z+3	; 0x03

000021ac <.Loc.97>:
		pread -= read2end;
    21ac:	a8 1b       	sub	r26, r24
    21ae:	b9 0b       	sbc	r27, r25

000021b0 <.L13>:
	f->pread = pread;
    21b0:	b5 83       	std	Z+5, r27	; 0x05
    21b2:	a4 83       	std	Z+4, r26	; 0x04

000021b4 <.Loc.101>:
	f->read2end = read2end;
    21b4:	91 87       	std	Z+9, r25	; 0x09
    21b6:	80 87       	std	Z+8, r24	; 0x08

000021b8 <.Loc.103>:
	f->count--;
    21b8:	80 81       	ld	r24, Z
    21ba:	91 81       	ldd	r25, Z+1	; 0x01

000021bc <.Loc.105>:
    21bc:	01 97       	sbiw	r24, 0x01	; 1
    21be:	91 83       	std	Z+1, r25	; 0x01
    21c0:	80 83       	st	Z, r24

000021c2 <.LBE12>:
		return -1;
	}
	else {
  	entry[0] = _inline_fifo_get (f);	
    21c2:	28 83       	st	Y, r18

000021c4 <.Loc.109>:
		return 1;
    21c4:	81 e0       	ldi	r24, 0x01	; 1
    21c6:	90 e0       	ldi	r25, 0x00	; 0

000021c8 <.L11>:
	}
}
    21c8:	df 91       	pop	r29
    21ca:	cf 91       	pop	r28
    21cc:	08 95       	ret

000021ce <.L14>:
		return -1;
    21ce:	8f ef       	ldi	r24, 0xFF	; 255
    21d0:	9f ef       	ldi	r25, 0xFF	; 255
    21d2:	fa cf       	rjmp	.-12     	; 0x21c8 <.L11>

000021d4 <avrupdate_start>:
{
  //	eeprom_write_byte(&ee_version,0xFF); //force bootloader to start
  // uint8_t myByte=0x00;
  // while(myByte !=0xFF)
  // 	 myByte = eeprom_read_byte(&ee_version);
  PORTA |= (1 << PA4);
    21d4:	dc 9a       	sbi	0x1b, 4	; 27

000021d6 <.Loc.3>:

  cli();    // disable all interrupts
    21d6:	f8 94       	cli

000021d8 <.Loc.4>:
  avrupdate_jump_to_boot();
    21d8:	e0 91 60 00 	lds	r30, 0x0060	; 0x800060 <avrupdate_jump_to_boot>
    21dc:	f0 91 61 00 	lds	r31, 0x0061	; 0x800061 <avrupdate_jump_to_boot+0x1>
    21e0:	09 94       	ijmp

000021e2 <wait_ms>:
#include "wait.h"
void wait_ms(int ms)
{
    21e2:	9c 01       	movw	r18, r24

000021e4 <.Loc.2>:
  	int i;
    for(i=0;i<ms;i++)
    21e4:	80 e0       	ldi	r24, 0x00	; 0
    21e6:	90 e0       	ldi	r25, 0x00	; 0

000021e8 <.L2>:
    21e8:	82 17       	cp	r24, r18
    21ea:	93 07       	cpc	r25, r19
    21ec:	0c f0       	brlt	.+2      	; 0x21f0 <.L3>

000021ee <.Loc.6>:
		_delay_ms(1);
}
    21ee:	08 95       	ret

000021f0 <.L3>:
	__builtin_avr_delay_cycles(__ticks_dc);
    21f0:	ef e9       	ldi	r30, 0x9F	; 159
    21f2:	ff e0       	ldi	r31, 0x0F	; 15

000021f4 <.L1^B1>:
    21f4:	31 97       	sbiw	r30, 0x01	; 1
    21f6:	f1 f7       	brne	.-4      	; 0x21f4 <.L1^B1>
    21f8:	00 c0       	rjmp	.+0      	; 0x21fa <L0^A>

000021fa <L0^A>:
	...

000021fc <.LBE4>:
    for(i=0;i<ms;i++)
    21fc:	01 96       	adiw	r24, 0x01	; 1

000021fe <.Loc.17>:
    21fe:	f4 cf       	rjmp	.-24     	; 0x21e8 <.L2>

00002200 <main>:


int main(void)
{
    2200:	00 d0       	rcall	.+0      	; 0x2202 <L0^A>

00002202 <L0^A>:
    2202:	cd b7       	in	r28, 0x3d	; 61
    2204:	de b7       	in	r29, 0x3e	; 62

00002206 <.Loc.1105>:
  #if DEBUG_ON
  UARTInit();
  #endif


  spi_init();
    2206:	0e 94 18 01 	call	0x230	; 0x230 <spi_init>

0000220a <.LVL250>:
  spi_idle();
    220a:	0e 94 67 01 	call	0x2ce	; 0x2ce <spi_idle>

0000220e <.LVL251>:
  USBNInit();
    220e:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <USBNInit>

00002212 <.LVL252>:

  usbprog.longpackage = 0;
    2212:	10 92 d5 01 	sts	0x01D5, r1	; 0x8001d5 <usbprog+0x2>
    2216:	10 92 d4 01 	sts	0x01D4, r1	; 0x8001d4 <usbprog+0x1>

0000221a <.Loc.1111>:
  usbprog.avrstudio = 1;   // 1 no
    221a:	81 e0       	ldi	r24, 0x01	; 1
    221c:	90 e0       	ldi	r25, 0x00	; 0
    221e:	90 93 df 01 	sts	0x01DF, r25	; 0x8001df <usbprog+0xc>
    2222:	80 93 de 01 	sts	0x01DE, r24	; 0x8001de <usbprog+0xb>

00002226 <.Loc.1113>:
  usbprog.fragmentnumber = 0;  // read flash fragment
    2226:	10 92 dd 01 	sts	0x01DD, r1	; 0x8001dd <usbprog+0xa>
    222a:	10 92 dc 01 	sts	0x01DC, r1	; 0x8001dc <usbprog+0x9>

0000222e <.Loc.1115>:
  usbprog.reset_pol = 1;  // 1= avr 0 = at89
    222e:	90 93 e1 01 	sts	0x01E1, r25	; 0x8001e1 <usbprog+0xe>
    2232:	80 93 e0 01 	sts	0x01E0, r24	; 0x8001e0 <usbprog+0xd>

00002236 <.Loc.1117>:
  usbprog.datatogl=0; 
    2236:	10 92 d9 01 	sts	0x01D9, r1	; 0x8001d9 <usbprog+0x6>
    223a:	10 92 d8 01 	sts	0x01D8, r1	; 0x8001d8 <usbprog+0x5>

0000223e <.Loc.1119>:

  DDRA = (1 << PA4);
    223e:	80 e1       	ldi	r24, 0x10	; 16
    2240:	8a bb       	out	0x1a, r24	; 26

00002242 <.Loc.1121>:
  LED_off;
    2242:	dc 98       	cbi	0x1b, 4	; 27

00002244 <.Loc.1122>:
  RESET_high;
    2244:	c0 9a       	sbi	0x18, 0	; 24

00002246 <.Loc.1123>:

  USBNDeviceVendorID(0x03eb);  //atmel ids
    2246:	8b ee       	ldi	r24, 0xEB	; 235
    2248:	93 e0       	ldi	r25, 0x03	; 3
    224a:	0e 94 89 0b 	call	0x1712	; 0x1712 <USBNDeviceVendorID>

0000224e <.LVL253>:
  USBNDeviceProductID(0x2104); // atmel ids
    224e:	84 e0       	ldi	r24, 0x04	; 4
    2250:	91 e2       	ldi	r25, 0x21	; 33
    2252:	0e 94 8e 0b 	call	0x171c	; 0x171c <USBNDeviceProductID>

00002256 <.LVL254>:

  USBNDeviceBCDDevice(0x0200);
    2256:	80 e0       	ldi	r24, 0x00	; 0
    2258:	92 e0       	ldi	r25, 0x02	; 2
    225a:	0e 94 93 0b 	call	0x1726	; 0x1726 <USBNDeviceBCDDevice>

0000225e <.LVL255>:

  char lang[]={0x09,0x04};
    225e:	89 e0       	ldi	r24, 0x09	; 9
    2260:	94 e0       	ldi	r25, 0x04	; 4
    2262:	9a 83       	std	Y+2, r25	; 0x02
    2264:	89 83       	std	Y+1, r24	; 0x01

00002266 <.Loc.1128>:
  _USBNAddStringDescriptor(lang); // language descriptor
    2266:	ce 01       	movw	r24, r28
    2268:	01 96       	adiw	r24, 0x01	; 1
    226a:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <_USBNAddStringDescriptor>

0000226e <.LVL256>:

  USBNDeviceManufacture("B.Sauter");
    226e:	88 e6       	ldi	r24, 0x68	; 104
    2270:	90 e0       	ldi	r25, 0x00	; 0
    2272:	0e 94 42 0e 	call	0x1c84	; 0x1c84 <USBNDeviceManufacture>

00002276 <.LVL257>:
  USBNDeviceProduct("AVRISP mk2 Clone");
    2276:	81 e7       	ldi	r24, 0x71	; 113
    2278:	90 e0       	ldi	r25, 0x00	; 0
    227a:	0e 94 4d 0e 	call	0x1c9a	; 0x1c9a <USBNDeviceProduct>

0000227e <.LVL258>:
  USBNDeviceSerialNumber("0000A00128255");
    227e:	82 e8       	ldi	r24, 0x82	; 130
    2280:	90 e0       	ldi	r25, 0x00	; 0
    2282:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <USBNDeviceSerialNumber>

00002286 <.LVL259>:

  conf = USBNAddConfiguration();
    2286:	0e 94 f6 0e 	call	0x1dec	; 0x1dec <USBNAddConfiguration>

0000228a <.LVL260>:
    228a:	98 2e       	mov	r9, r24
    228c:	19 2f       	mov	r17, r25

0000228e <.LVL261>:

  USBNConfigurationPower(conf,50);
    228e:	62 e3       	ldi	r22, 0x32	; 50
    2290:	70 e0       	ldi	r23, 0x00	; 0
    2292:	0e 94 a1 0b 	call	0x1742	; 0x1742 <USBNConfigurationPower>

00002296 <.LVL262>:

  interf = USBNAddInterface(conf,0);
    2296:	60 e0       	ldi	r22, 0x00	; 0
    2298:	70 e0       	ldi	r23, 0x00	; 0
    229a:	89 2d       	mov	r24, r9
    229c:	91 2f       	mov	r25, r17
    229e:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <USBNAddInterface>

000022a2 <.LVL263>:
    22a2:	78 2e       	mov	r7, r24
    22a4:	89 2e       	mov	r8, r25

000022a6 <.LVL264>:
  USBNAlternateSetting(conf,interf,0);
    22a6:	40 e0       	ldi	r20, 0x00	; 0
    22a8:	50 e0       	ldi	r21, 0x00	; 0
    22aa:	68 2f       	mov	r22, r24
    22ac:	79 2f       	mov	r23, r25
    22ae:	89 2d       	mov	r24, r9
    22b0:	91 2f       	mov	r25, r17
    22b2:	0e 94 c0 0b 	call	0x1780	; 0x1780 <USBNAlternateSetting>

000022b6 <.LVL265>:

  USBNAddInEndpoint(conf,interf,1,0x02,BULK,64,0,&SendCompleteAnswer);
    22b6:	8c ef       	ldi	r24, 0xFC	; 252
    22b8:	a8 2e       	mov	r10, r24
    22ba:	81 e0       	ldi	r24, 0x01	; 1
    22bc:	b8 2e       	mov	r11, r24
    22be:	c1 2c       	mov	r12, r1
    22c0:	d1 2c       	mov	r13, r1
    22c2:	90 e4       	ldi	r25, 0x40	; 64
    22c4:	e9 2e       	mov	r14, r25
    22c6:	f1 2c       	mov	r15, r1
    22c8:	02 e0       	ldi	r16, 0x02	; 2
    22ca:	22 e0       	ldi	r18, 0x02	; 2
    22cc:	30 e0       	ldi	r19, 0x00	; 0
    22ce:	41 e0       	ldi	r20, 0x01	; 1
    22d0:	50 e0       	ldi	r21, 0x00	; 0
    22d2:	67 2d       	mov	r22, r7
    22d4:	78 2d       	mov	r23, r8
    22d6:	89 2d       	mov	r24, r9
    22d8:	91 2f       	mov	r25, r17
    22da:	0e 94 38 10 	call	0x2070	; 0x2070 <USBNAddInEndpoint>

000022de <.LVL266>:
  
  //USBNNackEvent(&NackEvent);


  USBNAddOutEndpoint(conf,interf,1,0x02,BULK,64,0,&USBFlash);
    22de:	29 e2       	ldi	r18, 0x29	; 41
    22e0:	a2 2e       	mov	r10, r18
    22e2:	25 e0       	ldi	r18, 0x05	; 5
    22e4:	b2 2e       	mov	r11, r18
    22e6:	22 e0       	ldi	r18, 0x02	; 2
    22e8:	30 e0       	ldi	r19, 0x00	; 0
    22ea:	41 e0       	ldi	r20, 0x01	; 1
    22ec:	50 e0       	ldi	r21, 0x00	; 0
    22ee:	67 2d       	mov	r22, r7
    22f0:	78 2d       	mov	r23, r8
    22f2:	89 2d       	mov	r24, r9
    22f4:	91 2f       	mov	r25, r17
    22f6:	0e 94 05 10 	call	0x200a	; 0x200a <USBNAddOutEndpoint>

000022fa <.LVL267>:

  USBNInitMC();
    22fa:	0e 94 17 0b 	call	0x162e	; 0x162e <USBNInitMC>

000022fe <.LVL268>:
  sei();
    22fe:	78 94       	sei

00002300 <.Loc.1142>:

  // start usb chip
  USBNStart();
    2300:	0e 94 68 0d 	call	0x1ad0	; 0x1ad0 <USBNStart>

00002304 <.L215>:

  while(1);
    2304:	ff cf       	rjmp	.-2      	; 0x2304 <.L215>

00002306 <__tablejump2__>:
    2306:	ee 0f       	add	r30, r30

00002308 <.Loc.1>:
    2308:	ff 1f       	adc	r31, r31

0000230a <.Loc.2>:
    230a:	05 90       	lpm	r0, Z+

0000230c <.Loc.3>:
    230c:	f4 91       	lpm	r31, Z

0000230e <.Loc.4>:
    230e:	e0 2d       	mov	r30, r0

00002310 <.Loc.5>:
    2310:	09 94       	ijmp

00002312 <malloc>:
    2312:	0f 93       	push	r16
    2314:	1f 93       	push	r17
    2316:	cf 93       	push	r28
    2318:	df 93       	push	r29
    231a:	9c 01       	movw	r18, r24
    231c:	02 97       	sbiw	r24, 0x02	; 2
    231e:	10 f4       	brcc	.+4      	; 0x2324 <.L2>
    2320:	22 e0       	ldi	r18, 0x02	; 2
    2322:	30 e0       	ldi	r19, 0x00	; 0

00002324 <.L2>:
    2324:	e0 91 2e 02 	lds	r30, 0x022E	; 0x80022e <__flp>
    2328:	f0 91 2f 02 	lds	r31, 0x022F	; 0x80022f <__flp+0x1>
    232c:	80 e0       	ldi	r24, 0x00	; 0
    232e:	90 e0       	ldi	r25, 0x00	; 0
    2330:	a0 e0       	ldi	r26, 0x00	; 0
    2332:	b0 e0       	ldi	r27, 0x00	; 0

00002334 <.L3>:
    2334:	30 97       	sbiw	r30, 0x00	; 0
    2336:	91 f4       	brne	.+36     	; 0x235c <.L9>
    2338:	00 97       	sbiw	r24, 0x00	; 0
    233a:	09 f4       	brne	.+2      	; 0x233e <L0^A+0x2>

0000233c <L0^A>:
    233c:	48 c0       	rjmp	.+144    	; 0x23ce <.L10>
    233e:	82 1b       	sub	r24, r18
    2340:	93 0b       	sbc	r25, r19
    2342:	84 30       	cpi	r24, 0x04	; 4
    2344:	91 05       	cpc	r25, r1
    2346:	d0 f5       	brcc	.+116    	; 0x23bc <.L11>
    2348:	8a 81       	ldd	r24, Y+2	; 0x02
    234a:	9b 81       	ldd	r25, Y+3	; 0x03
    234c:	61 15       	cp	r22, r1
    234e:	71 05       	cpc	r23, r1
    2350:	81 f1       	breq	.+96     	; 0x23b2 <.L12>
    2352:	fb 01       	movw	r30, r22
    2354:	93 83       	std	Z+3, r25	; 0x03
    2356:	82 83       	std	Z+2, r24	; 0x02

00002358 <.L13>:
    2358:	fe 01       	movw	r30, r28
    235a:	11 c0       	rjmp	.+34     	; 0x237e <.L19>

0000235c <.L9>:
    235c:	40 81       	ld	r20, Z
    235e:	51 81       	ldd	r21, Z+1	; 0x01
    2360:	02 81       	ldd	r16, Z+2	; 0x02
    2362:	13 81       	ldd	r17, Z+3	; 0x03
    2364:	42 17       	cp	r20, r18
    2366:	53 07       	cpc	r21, r19
    2368:	d8 f0       	brcs	.+54     	; 0x23a0 <.L16>
    236a:	42 17       	cp	r20, r18
    236c:	53 07       	cpc	r21, r19
    236e:	99 f4       	brne	.+38     	; 0x2396 <.L5>
    2370:	10 97       	sbiw	r26, 0x00	; 0
    2372:	61 f0       	breq	.+24     	; 0x238c <.L6>
    2374:	12 96       	adiw	r26, 0x02	; 2
    2376:	0c 93       	st	X, r16
    2378:	12 97       	sbiw	r26, 0x02	; 2
    237a:	13 96       	adiw	r26, 0x03	; 3
    237c:	1c 93       	st	X, r17

0000237e <.L19>:
    237e:	32 96       	adiw	r30, 0x02	; 2

00002380 <.L1>:
    2380:	cf 01       	movw	r24, r30
    2382:	df 91       	pop	r29
    2384:	cf 91       	pop	r28
    2386:	1f 91       	pop	r17
    2388:	0f 91       	pop	r16
    238a:	08 95       	ret

0000238c <.L6>:
    238c:	00 93 2e 02 	sts	0x022E, r16	; 0x80022e <__flp>
    2390:	10 93 2f 02 	sts	0x022F, r17	; 0x80022f <__flp+0x1>
    2394:	f4 cf       	rjmp	.-24     	; 0x237e <.L19>

00002396 <.L5>:
    2396:	00 97       	sbiw	r24, 0x00	; 0
    2398:	51 f0       	breq	.+20     	; 0x23ae <.L18>
    239a:	48 17       	cp	r20, r24
    239c:	59 07       	cpc	r21, r25
    239e:	38 f0       	brcs	.+14     	; 0x23ae <.L18>

000023a0 <.L16>:
    23a0:	ac 01       	movw	r20, r24
    23a2:	db 01       	movw	r26, r22

000023a4 <.L4>:
    23a4:	ca 01       	movw	r24, r20
    23a6:	bd 01       	movw	r22, r26
    23a8:	df 01       	movw	r26, r30
    23aa:	f8 01       	movw	r30, r16
    23ac:	c3 cf       	rjmp	.-122    	; 0x2334 <.L3>

000023ae <.L18>:
    23ae:	ef 01       	movw	r28, r30
    23b0:	f9 cf       	rjmp	.-14     	; 0x23a4 <.L4>

000023b2 <.L12>:
    23b2:	90 93 2f 02 	sts	0x022F, r25	; 0x80022f <__flp+0x1>
    23b6:	80 93 2e 02 	sts	0x022E, r24	; 0x80022e <__flp>
    23ba:	ce cf       	rjmp	.-100    	; 0x2358 <.L13>

000023bc <.L11>:
    23bc:	fe 01       	movw	r30, r28
    23be:	e8 0f       	add	r30, r24
    23c0:	f9 1f       	adc	r31, r25
    23c2:	21 93       	st	Z+, r18
    23c4:	31 93       	st	Z+, r19
    23c6:	02 97       	sbiw	r24, 0x02	; 2
    23c8:	99 83       	std	Y+1, r25	; 0x01
    23ca:	88 83       	st	Y, r24
    23cc:	d9 cf       	rjmp	.-78     	; 0x2380 <.L1>

000023ce <.L10>:
    23ce:	40 91 30 02 	lds	r20, 0x0230	; 0x800230 <__brkval>
    23d2:	50 91 31 02 	lds	r21, 0x0231	; 0x800231 <__brkval+0x1>
    23d6:	41 15       	cp	r20, r1
    23d8:	51 05       	cpc	r21, r1
    23da:	41 f4       	brne	.+16     	; 0x23ec <.L14>
    23dc:	40 91 64 00 	lds	r20, 0x0064	; 0x800064 <__malloc_heap_start>
    23e0:	50 91 65 00 	lds	r21, 0x0065	; 0x800065 <__malloc_heap_start+0x1>
    23e4:	50 93 31 02 	sts	0x0231, r21	; 0x800231 <__brkval+0x1>
    23e8:	40 93 30 02 	sts	0x0230, r20	; 0x800230 <__brkval>

000023ec <.L14>:
    23ec:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <__malloc_heap_end>
    23f0:	90 91 63 00 	lds	r25, 0x0063	; 0x800063 <__malloc_heap_end+0x1>
    23f4:	00 97       	sbiw	r24, 0x00	; 0
    23f6:	41 f4       	brne	.+16     	; 0x2408 <.L15>
    23f8:	8d b7       	in	r24, 0x3d	; 61
    23fa:	9e b7       	in	r25, 0x3e	; 62
    23fc:	60 91 66 00 	lds	r22, 0x0066	; 0x800066 <__malloc_margin>
    2400:	70 91 67 00 	lds	r23, 0x0067	; 0x800067 <__malloc_margin+0x1>
    2404:	86 1b       	sub	r24, r22
    2406:	97 0b       	sbc	r25, r23

00002408 <.L15>:
    2408:	48 17       	cp	r20, r24
    240a:	59 07       	cpc	r21, r25
    240c:	08 f0       	brcs	.+2      	; 0x2410 <L0^A+0x2>

0000240e <L0^A>:
    240e:	b8 cf       	rjmp	.-144    	; 0x2380 <.L1>
    2410:	84 1b       	sub	r24, r20
    2412:	95 0b       	sbc	r25, r21
    2414:	82 17       	cp	r24, r18
    2416:	93 07       	cpc	r25, r19
    2418:	08 f4       	brcc	.+2      	; 0x241c <L0^A+0x2>

0000241a <L0^A>:
    241a:	b2 cf       	rjmp	.-156    	; 0x2380 <.L1>
    241c:	b9 01       	movw	r22, r18
    241e:	6e 5f       	subi	r22, 0xFE	; 254
    2420:	7f 4f       	sbci	r23, 0xFF	; 255
    2422:	86 17       	cp	r24, r22
    2424:	97 07       	cpc	r25, r23
    2426:	08 f4       	brcc	.+2      	; 0x242a <L0^A+0x2>

00002428 <L0^A>:
    2428:	ab cf       	rjmp	.-170    	; 0x2380 <.L1>
    242a:	64 0f       	add	r22, r20
    242c:	75 1f       	adc	r23, r21
    242e:	70 93 31 02 	sts	0x0231, r23	; 0x800231 <__brkval+0x1>
    2432:	60 93 30 02 	sts	0x0230, r22	; 0x800230 <__brkval>
    2436:	fa 01       	movw	r30, r20
    2438:	21 93       	st	Z+, r18
    243a:	31 93       	st	Z+, r19
    243c:	a1 cf       	rjmp	.-190    	; 0x2380 <.L1>

0000243e <free>:
    243e:	cf 93       	push	r28
    2440:	df 93       	push	r29
    2442:	9c 01       	movw	r18, r24
    2444:	00 97       	sbiw	r24, 0x00	; 0
    2446:	e9 f0       	breq	.+58     	; 0x2482 <.L20>
    2448:	fc 01       	movw	r30, r24
    244a:	32 97       	sbiw	r30, 0x02	; 2
    244c:	13 82       	std	Z+3, r1	; 0x03
    244e:	12 82       	std	Z+2, r1	; 0x02
    2450:	c0 91 2e 02 	lds	r28, 0x022E	; 0x80022e <__flp>
    2454:	d0 91 2f 02 	lds	r29, 0x022F	; 0x80022f <__flp+0x1>
    2458:	de 01       	movw	r26, r28
    245a:	80 e0       	ldi	r24, 0x00	; 0
    245c:	90 e0       	ldi	r25, 0x00	; 0
    245e:	20 97       	sbiw	r28, 0x00	; 0
    2460:	a1 f4       	brne	.+40     	; 0x248a <.L23>
    2462:	80 81       	ld	r24, Z
    2464:	91 81       	ldd	r25, Z+1	; 0x01
    2466:	28 0f       	add	r18, r24
    2468:	39 1f       	adc	r19, r25
    246a:	80 91 30 02 	lds	r24, 0x0230	; 0x800230 <__brkval>
    246e:	90 91 31 02 	lds	r25, 0x0231	; 0x800231 <__brkval+0x1>
    2472:	82 17       	cp	r24, r18
    2474:	93 07       	cpc	r25, r19
    2476:	09 f0       	breq	.+2      	; 0x247a <L0^A+0x2>

00002478 <L0^A>:
    2478:	68 c0       	rjmp	.+208    	; 0x254a <.L36>
    247a:	f0 93 31 02 	sts	0x0231, r31	; 0x800231 <__brkval+0x1>
    247e:	e0 93 30 02 	sts	0x0230, r30	; 0x800230 <__brkval>

00002482 <.L20>:
    2482:	df 91       	pop	r29
    2484:	cf 91       	pop	r28
    2486:	08 95       	ret

00002488 <.L34>:
    2488:	da 01       	movw	r26, r20

0000248a <.L23>:
    248a:	ae 17       	cp	r26, r30
    248c:	bf 07       	cpc	r27, r31
    248e:	08 f0       	brcs	.+2      	; 0x2492 <L0^A+0x2>

00002490 <L0^A>:
    2490:	42 c0       	rjmp	.+132    	; 0x2516 <.L25>
    2492:	12 96       	adiw	r26, 0x02	; 2
    2494:	4d 91       	ld	r20, X+
    2496:	5c 91       	ld	r21, X
    2498:	13 97       	sbiw	r26, 0x03	; 3
    249a:	cd 01       	movw	r24, r26
    249c:	41 15       	cp	r20, r1
    249e:	51 05       	cpc	r21, r1
    24a0:	99 f7       	brne	.-26     	; 0x2488 <.L34>

000024a2 <.L26>:
    24a2:	dc 01       	movw	r26, r24
    24a4:	13 96       	adiw	r26, 0x03	; 3
    24a6:	fc 93       	st	X, r31
    24a8:	ee 93       	st	-X, r30
    24aa:	12 97       	sbiw	r26, 0x02	; 2
    24ac:	4d 91       	ld	r20, X+
    24ae:	5d 91       	ld	r21, X+
    24b0:	9d 01       	movw	r18, r26
    24b2:	24 0f       	add	r18, r20
    24b4:	35 1f       	adc	r19, r21
    24b6:	e2 17       	cp	r30, r18
    24b8:	f3 07       	cpc	r31, r19
    24ba:	81 f4       	brne	.+32     	; 0x24dc <.L28>
    24bc:	20 81       	ld	r18, Z
    24be:	31 81       	ldd	r19, Z+1	; 0x01
    24c0:	2e 5f       	subi	r18, 0xFE	; 254
    24c2:	3f 4f       	sbci	r19, 0xFF	; 255
    24c4:	24 0f       	add	r18, r20
    24c6:	35 1f       	adc	r19, r21
    24c8:	dc 01       	movw	r26, r24
    24ca:	11 96       	adiw	r26, 0x01	; 1
    24cc:	3c 93       	st	X, r19
    24ce:	2e 93       	st	-X, r18
    24d0:	22 81       	ldd	r18, Z+2	; 0x02
    24d2:	33 81       	ldd	r19, Z+3	; 0x03
    24d4:	13 96       	adiw	r26, 0x03	; 3
    24d6:	3c 93       	st	X, r19
    24d8:	2e 93       	st	-X, r18
    24da:	12 97       	sbiw	r26, 0x02	; 2

000024dc <.L28>:
    24dc:	e0 e0       	ldi	r30, 0x00	; 0
    24de:	f0 e0       	ldi	r31, 0x00	; 0

000024e0 <.L29>:
    24e0:	8a 81       	ldd	r24, Y+2	; 0x02
    24e2:	9b 81       	ldd	r25, Y+3	; 0x03
    24e4:	00 97       	sbiw	r24, 0x00	; 0
    24e6:	b1 f5       	brne	.+108    	; 0x2554 <.L35>
    24e8:	de 01       	movw	r26, r28
    24ea:	8d 91       	ld	r24, X+
    24ec:	9d 91       	ld	r25, X+
    24ee:	8a 0f       	add	r24, r26
    24f0:	9b 1f       	adc	r25, r27
    24f2:	20 91 30 02 	lds	r18, 0x0230	; 0x800230 <__brkval>
    24f6:	30 91 31 02 	lds	r19, 0x0231	; 0x800231 <__brkval+0x1>
    24fa:	28 17       	cp	r18, r24
    24fc:	39 07       	cpc	r19, r25
    24fe:	09 f6       	brne	.-126    	; 0x2482 <.L20>
    2500:	30 97       	sbiw	r30, 0x00	; 0
    2502:	59 f5       	brne	.+86     	; 0x255a <.L31>
    2504:	10 92 2f 02 	sts	0x022F, r1	; 0x80022f <__flp+0x1>
    2508:	10 92 2e 02 	sts	0x022E, r1	; 0x80022e <__flp>

0000250c <.L32>:
    250c:	d0 93 31 02 	sts	0x0231, r29	; 0x800231 <__brkval+0x1>
    2510:	c0 93 30 02 	sts	0x0230, r28	; 0x800230 <__brkval>
    2514:	b6 cf       	rjmp	.-148    	; 0x2482 <.L20>

00002516 <.L25>:
    2516:	b3 83       	std	Z+3, r27	; 0x03
    2518:	a2 83       	std	Z+2, r26	; 0x02
    251a:	40 81       	ld	r20, Z
    251c:	51 81       	ldd	r21, Z+1	; 0x01
    251e:	24 0f       	add	r18, r20
    2520:	35 1f       	adc	r19, r21
    2522:	a2 17       	cp	r26, r18
    2524:	b3 07       	cpc	r27, r19
    2526:	71 f4       	brne	.+28     	; 0x2544 <.L27>
    2528:	4e 5f       	subi	r20, 0xFE	; 254
    252a:	5f 4f       	sbci	r21, 0xFF	; 255
    252c:	2d 91       	ld	r18, X+
    252e:	3c 91       	ld	r19, X
    2530:	11 97       	sbiw	r26, 0x01	; 1
    2532:	24 0f       	add	r18, r20
    2534:	35 1f       	adc	r19, r21
    2536:	31 83       	std	Z+1, r19	; 0x01
    2538:	20 83       	st	Z, r18
    253a:	12 96       	adiw	r26, 0x02	; 2
    253c:	2d 91       	ld	r18, X+
    253e:	3c 91       	ld	r19, X
    2540:	33 83       	std	Z+3, r19	; 0x03
    2542:	22 83       	std	Z+2, r18	; 0x02

00002544 <.L27>:
    2544:	00 97       	sbiw	r24, 0x00	; 0
    2546:	09 f0       	breq	.+2      	; 0x254a <.L36>

00002548 <L0^A>:
    2548:	ac cf       	rjmp	.-168    	; 0x24a2 <.L26>

0000254a <.L36>:
    254a:	f0 93 2f 02 	sts	0x022F, r31	; 0x80022f <__flp+0x1>
    254e:	e0 93 2e 02 	sts	0x022E, r30	; 0x80022e <__flp>
    2552:	97 cf       	rjmp	.-210    	; 0x2482 <.L20>

00002554 <.L35>:
    2554:	fe 01       	movw	r30, r28
    2556:	ec 01       	movw	r28, r24
    2558:	c3 cf       	rjmp	.-122    	; 0x24e0 <.L29>

0000255a <.L31>:
    255a:	13 82       	std	Z+3, r1	; 0x03
    255c:	12 82       	std	Z+2, r1	; 0x02
    255e:	d6 cf       	rjmp	.-84     	; 0x250c <.L32>

00002560 <memcpy>:
    2560:	fb 01       	movw	r30, r22
    2562:	dc 01       	movw	r26, r24
    2564:	02 c0       	rjmp	.+4      	; 0x256a <.L_memcpy_start>

00002566 <.L_memcpy_loop>:
    2566:	01 90       	ld	r0, Z+
    2568:	0d 92       	st	X+, r0

0000256a <.L_memcpy_start>:
    256a:	41 50       	subi	r20, 0x01	; 1
    256c:	50 40       	sbci	r21, 0x00	; 0
    256e:	d8 f7       	brcc	.-10     	; 0x2566 <.L_memcpy_loop>
    2570:	08 95       	ret

00002572 <eeprom_read_byte>:
    2572:	e1 99       	sbic	0x1c, 1	; 28
    2574:	fe cf       	rjmp	.-4      	; 0x2572 <eeprom_read_byte>
    2576:	9f bb       	out	0x1f, r25	; 31
    2578:	8e bb       	out	0x1e, r24	; 30
    257a:	e0 9a       	sbi	0x1c, 0	; 28
    257c:	99 27       	eor	r25, r25
    257e:	8d b3       	in	r24, 0x1d	; 29
    2580:	08 95       	ret

00002582 <eeprom_write_byte>:
    2582:	26 2f       	mov	r18, r22

00002584 <eeprom_write_r18>:
    2584:	e1 99       	sbic	0x1c, 1	; 28
    2586:	fe cf       	rjmp	.-4      	; 0x2584 <eeprom_write_r18>
    2588:	9f bb       	out	0x1f, r25	; 31
    258a:	8e bb       	out	0x1e, r24	; 30
    258c:	2d bb       	out	0x1d, r18	; 29
    258e:	0f b6       	in	r0, 0x3f	; 63
    2590:	f8 94       	cli
    2592:	e2 9a       	sbi	0x1c, 2	; 28
    2594:	e1 9a       	sbi	0x1c, 1	; 28
    2596:	0f be       	out	0x3f, r0	; 63
    2598:	01 96       	adiw	r24, 0x01	; 1
    259a:	08 95       	ret

0000259c <_exit>:
    259c:	f8 94       	cli

0000259e <__stop_program>:
    259e:	ff cf       	rjmp	.-2      	; 0x259e <__stop_program>

000025a0 <L0^A>:
    25a0:	50 01       	movw	r10, r0
    25a2:	55 01       	movw	r10, r10
    25a4:	57 01       	movw	r10, r14
    25a6:	59 01       	movw	r10, r18
    25a8:	5d 01       	movw	r10, r26
    25aa:	5f 01       	movw	r10, r30
    25ac:	61 01       	movw	r12, r2

000025ae <.L158>:
    25ae:	61 05       	cpc	r22, r1
    25b0:	90 05       	cpc	r25, r0
    25b2:	c7 05       	cpc	r28, r7
    25b4:	4d 06       	cpc	r4, r29
    25b6:	e5 05       	cpc	r30, r5
    25b8:	01 06       	cpc	r0, r17
    25ba:	40 06       	cpc	r4, r16
    25bc:	4d 06       	cpc	r4, r29
    25be:	4d 06       	cpc	r4, r29
    25c0:	48 06       	cpc	r4, r24
    25c2:	4d 06       	cpc	r4, r29
    25c4:	4d 06       	cpc	r4, r29
    25c6:	4d 06       	cpc	r4, r29
    25c8:	4d 06       	cpc	r4, r29
    25ca:	4d 06       	cpc	r4, r29
    25cc:	54 06       	cpc	r5, r20
    25ce:	5f 06       	cpc	r5, r31
    25d0:	7c 06       	cpc	r7, r28
    25d2:	8e 06       	cpc	r8, r30
    25d4:	cb 06       	cpc	r12, r27
    25d6:	77 07       	cpc	r23, r23
    25d8:	ad 07       	cpc	r26, r29
    25da:	07 08       	sbc	r0, r7
    25dc:	15 08       	sbc	r1, r5
    25de:	65 07       	cpc	r22, r21
    25e0:	58 07       	cpc	r21, r24
    25e2:	22 08       	sbc	r2, r2
    25e4:	eb 05       	cpc	r30, r11
    25e6:	2f 08       	sbc	r2, r15

000025e8 <.L51>:
    25e8:	1d 0a       	sbc	r1, r29
    25ea:	03 0a       	sbc	r0, r19
    25ec:	34 0a       	sbc	r3, r20
    25ee:	29 0a       	sbc	r2, r25
    25f0:	34 0a       	sbc	r3, r20
    25f2:	2c 0a       	sbc	r2, r28
    25f4:	19 0a       	sbc	r1, r25
    25f6:	34 0a       	sbc	r3, r20
    25f8:	00 0a       	sbc	r0, r16
    25fa:	30 0a       	sbc	r3, r16
    25fc:	03 0a       	sbc	r0, r19
    25fe:	29 0a       	sbc	r2, r25
