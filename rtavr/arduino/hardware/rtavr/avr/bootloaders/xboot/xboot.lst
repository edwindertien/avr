   1               		.file	"xboot.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 100               		.section	.text.eeprom_read_byte,"ax",@progbits
 103               	eeprom_read_byte:
 105               	.Ltext1:
   1:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /* Copyright (c) 2002, 2003, 2004, 2007 Marek Michalkiewicz
   2:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****    Copyright (c) 2005, 2006 Bjoern Haase
   3:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****    Copyright (c) 2008 Atmel Corporation
   4:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****    Copyright (c) 2008 Wouter van Gulik
   5:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****    All rights reserved.
   6:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
   7:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****    Redistribution and use in source and binary forms, with or without
   8:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****    modification, are permitted provided that the following conditions are met:
   9:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  10:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****    * Redistributions of source code must retain the above copyright
  11:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****      notice, this list of conditions and the following disclaimer.
  12:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****    * Redistributions in binary form must reproduce the above copyright
  13:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****      notice, this list of conditions and the following disclaimer in
  14:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****      the documentation and/or other materials provided with the
  15:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****      distribution.
  16:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****    * Neither the name of the copyright holders nor the names of
  17:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****      contributors may be used to endorse or promote products derived
  18:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****      from this software without specific prior written permission.
  19:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  20:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  32:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /* $Id: eeprom.h,v 1.21.2.6 2008/08/19 22:10:39 arcanum Exp $ */
  33:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  34:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #ifndef _AVR_EEPROM_H_
  35:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #define _AVR_EEPROM_H_ 1
  36:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  37:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #include <avr/io.h>
  38:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #include <stddef.h>	/* size_t */
  39:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #include <stdint.h>
  40:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  41:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #ifdef __cplusplus
  42:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** extern "C" {
  43:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
  44:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  45:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #ifndef	__ATTR_PURE__
  46:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # ifdef	 __DOXYGEN__
  47:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #  define __ATTR_PURE__
  48:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # else
  49:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #  define __ATTR_PURE__  __attribute__((__pure__))
  50:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # endif
  51:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
  52:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  53:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
  54:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** uint16_t __eerd_word (const uint16_t *, uint8_t (*)(const uint8_t *))
  55:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     __ATTR_PURE__;
  56:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** uint32_t __eerd_dword (const uint32_t *, uint8_t (*)(const uint8_t *))
  57:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     __ATTR_PURE__;
  58:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** void __eerd_block (void *, const void *, size_t, uint8_t (*)(const uint8_t *));
  59:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  60:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** void __eewr_word (uint16_t *, uint16_t, void (*)(uint8_t *, uint8_t));
  61:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** void __eewr_dword (uint32_t *, uint32_t, void (*)(uint8_t *, uint8_t));
  62:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** void __eewr_block (void *, const void *, size_t, void (*)(uint8_t *, uint8_t));
  63:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif /* (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) ) */
  64:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  65:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if !E2END && !defined(__DOXYGEN__)
  66:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # ifndef __COMPILING_AVR_LIBC__
  67:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #  warning "Device does not have EEPROM available."
  68:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # endif
  69:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****   /* Omit below for chips without EEPROM. */
  70:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  71:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #else
  72:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  73:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /** \defgroup avr_eeprom <avr/eeprom.h>: EEPROM handling
  74:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     \code #include <avr/eeprom.h> \endcode
  75:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  76:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     This header file declares the interface to some simple library
  77:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     routines suitable for handling the data EEPROM contained in the
  78:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     AVR microcontrollers.  The implementation uses a simple polled
  79:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     mode interface.  Applications that require interrupt-controlled
  80:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     EEPROM access to ensure that no time will be wasted in spinloops
  81:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     will have to deploy their own implementation.
  82:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  83:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     \note All of the read/write functions first make sure the EEPROM
  84:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     is ready to be accessed.  Since this may cause long delays if a
  85:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     write operation is still pending, time-critical applications
  86:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     should first poll the EEPROM e. g. using eeprom_is_ready() before
  87:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     attempting any actual I/O.  But this functions are not wait until
  88:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     SELFPRGEN in SPMCSR becomes zero.  Do this manually, if your
  89:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     softwate contains the Flash burning.
  90:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  91:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     \note As these functions modify IO registers, they are known to be
  92:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     non-reentrant.  If any of these functions are used from both,
  93:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     standard and interrupt context, the applications must ensure
  94:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     proper protection (e.g. by disabling interrupts before accessing
  95:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     them).
  96:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
  97:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     \note All write functions force erase_and_write programming mode.
  98:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****  */
  99:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 100:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /** \def EEMEM
 101:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     \ingroup avr_eeprom
 102:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     Attribute expression causing a variable to be allocated within the
 103:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     .eeprom section.	*/
 104:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #define EEMEM __attribute__((section(".eeprom")))
 105:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 106:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 107:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /* Register definitions */
 108:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 109:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /* Check for aliases. */
 110:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if	!defined(EEWE) && defined(EEPE)
 111:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EEWE EEPE
 112:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 113:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 114:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if	!defined(EEMWE) && defined(EEMPE)
 115:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EEMWE EEMPE
 116:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 117:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 118:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if	!defined(EECR) && defined(DEECR)
 119:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /* AT86RF401 */
 120:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EECR  DEECR
 121:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EEAR  DEEAR
 122:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EEARL DEEAR
 123:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EEDR  DEEDR
 124:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EERE  EER
 125:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EEWE  EEL
 126:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EEMWE EEU
 127:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 128:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 129:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 130:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if	!defined(EECR) || !defined(EEDR) || !defined(EEARL)
 131:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 132:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # if	 !defined(__EEPROM_REG_LOCATIONS__) \
 133:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****       && !defined(EEPROM_REG_LOCATIONS_OVERRIDE)
 134:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****    /* 6-byte string denoting where to find the EEPROM registers in memory
 135:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****       space.  Adresses denoted in hex syntax with uppercase letters. Used
 136:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****       by the EEPROM subroutines.
 137:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 	First two letters:  EECR address.
 138:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 	Second two letters: EEDR address.
 139:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 	Last two letters:   EEAR address.
 140:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     */
 141:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #  error "Unknown EEPROM register(s) location."
 142:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # endif
 143:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 144:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /* If needed, override the locations defined in the IO headers. */
 145:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # ifdef  EEPROM_REG_LOCATIONS_OVERRIDE
 146:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #  undef  __EEPROM_REG_LOCATIONS__
 147:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #  define __EEPROM_REG_LOCATIONS__ EEPROM_REG_LOCATIONS_OVERRIDE
 148:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # endif
 149:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 150:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define CONCAT1(a, b) CONCAT2(a, b)
 151:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define CONCAT2(a, b) a ## b
 152:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define HEXNR CONCAT1(0x, __EEPROM_REG_LOCATIONS__)
 153:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 154:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # undef EECR
 155:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EECR _SFR_IO8((HEXNR >> 16) & 0xFF)
 156:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 157:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # undef EEDR
 158:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EEDR _SFR_IO8((HEXNR >> 8) & 0xFF)
 159:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 160:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # undef EEAR
 161:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EEAR _SFR_IO8(HEXNR & 0xFF)
 162:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 163:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # undef EEARH
 164:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 165:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # undef EEARL
 166:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define EEARL EEAR
 167:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 168:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 169:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 170:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 171:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /** \def eeprom_is_ready
 172:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     \ingroup avr_eeprom
 173:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     \returns 1 if EEPROM is ready for a new read/write operation, 0 if not.
 174:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****  */
 175:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if	defined(__DOXYGEN__)
 176:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define eeprom_is_ready()
 177:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #elif	defined(DEECR)
 178:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define eeprom_is_ready() bit_is_clear(DEECR, BSY)
 179:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #else
 180:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # define eeprom_is_ready() bit_is_clear(EECR, EEWE)
 181:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 182:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 183:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 184:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /** \def eeprom_busy_wait
 185:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     \ingroup avr_eeprom
 186:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     Loops until the eeprom is no longer busy.
 187:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     \returns Nothing.
 188:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****  */ 	 
 189:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #define eeprom_busy_wait() do {} while (!eeprom_is_ready())
 190:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 191:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 192:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /** \ingroup avr_eeprom
 193:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     Read one byte from EEPROM address \a __p.
 194:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****  */
 195:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** __ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
 196:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** {
 106               	,.LM0-.LFBB1
 107               	.LM0:
 108               	.LFBB1:
 109               	/* prologue: function */
 110               	/* frame size = 0 */
 111 0000 9C01      		movw r18,r24
 112               	.L2:
 197:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****  EEAR = (uint16_t)__p;
 113               		68,0,197,.LM1-.LFBB1
 114               	.LM1:
 115 0002 F999      		sbic 63-32,1
 116 0004 00C0      		rjmp .L2
 198:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** endif
 199:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     /* Use inline assembly below as some AVRs have problems with accessing
 200:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     EECR with STS instructions. For example, see errata for ATmega64. 
 201:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     The code below also assumes that EECR and EEDR are in the I/O space.
 117               	abn	68,0,201,.LM2-.LFBB1
 118               	.LM2:
 119 0006 32BD      		out (65)+1-32,r19
 120 0008 21BD      		out 65-32,r18
 202:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** */
 203:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     uint8_t __result;
 204:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     __asm__ __volatile__
 205:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     (
 206:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         "/* START EEPROM READ CRITICAL SECTION */ \n\t"
 207:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         "sbi %1, %2 \n\t"
 208:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         "in %0, %3 \n\t"
 121               	abn	68,0,208,.LM3-.LFBB1
 122               	.LM3:
 123               	/* #APP */
 124               	 ;  208 "d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h" 1
 125               		/* START EEPROM READ CRITICAL SECTION */ 
 126 000a F89A      		sbi 31, 0 
 127 000c 80B5      		in r24, 32 
 128               		/* END EEPROM READ CRITICAL SECTION */ 
 129               		
 130               	 ;  0 "" 2
 131               	/* epilogue start */
 209:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****  "/* END EEPROM READ CRITICAL SECTION */ \n\t"
 210:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         : "=r" (__result)
 211:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         : "i" (_SFR_IO_ADDR(EECR)),
 212:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****           "i" (EERE),
 213:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****           "i" (_SFR_IO_ADDR(EEDR))
 214:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     );
 215:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     return __result;
 216:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** }
 217:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 218:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /** \ingroup avr_eeprom
 219:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     Read one 16-bit word (little endian) from EEPROM address \a __p.
 220:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****  */
 132               	0,220,.LM4-.LFBB1
 133               	.LM4:
 134               	/* #NOAPP */
 135 000e 0895      		ret
 140               	.Lscope1:
 141               		.section	.text.eeprom_write_byte,"ax",@progbits
 145               	eeprom_write_byte:
 221:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** _ static __inline__ uint16_t eeprom_read_word (const uint16_t *__p)
 222:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** {
 223:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
 224:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     return __eerd_word (__p, eeprom_read_byte);
 225:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #else
 226:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     /* If ATmega256x device, do not call function. */
 227:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     union
 228:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     {
 229:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         uint16_t word;
 230:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         struct
 231:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         {
 232:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****             uint8_t lo;
 233:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****             uint8_t hi;
 234:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         } byte;
 235:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     } x;
 236:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 237:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     x.byte.lo = eeprom_read_byte ((const uint8_t *)__p);
 238:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     x.byte.hi = eeprom_read_byte ((const uint8_t *)__p + 1);
 239:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     return x.word;
 240:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 241:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** }
 242:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 243:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /** \ingroup avr_eeprom
 244:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     Read one 32-bit double word (little endian) from EEPROM address \a __p.
 245:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****  */
 246:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** __ATTR_PURE__ static __inline__
 247:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** uint32_t eeprom_read_dword (const uint32_t *__p)
 248:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** {
 249:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
 250:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     return __eerd_dword (__p, eeprom_read_byte);
 251:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #else
 252:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     /* If ATmega256x device, do not call function. */
 253:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     union
 254:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     {
 255:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         uint32_t dword;
 256:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         struct
 257:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         {
 258:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****             uint8_t byte0;
 259:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****             uint8_t byte1;
 260:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****             uint8_t byte2;
 261:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****             uint8_t byte3;
 262:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         } byte;
 263:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     } x;
 264:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 265:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     x.byte.byte0 = eeprom_read_byte ((const uint8_t *)__p);
 266:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     x.byte.byte1 = eeprom_read_byte ((const uint8_t *)__p + 1);
 267:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     x.byte.byte2 = eeprom_read_byte ((const uint8_t *)__p + 2);
 268:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     x.byte.byte3 = eeprom_read_byte ((const uint8_t *)__p + 3);
 269:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     return x.dword;
 270:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 271:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** }
 272:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 273:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /** \ingroup avr_eeprom
 274:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     Read a block of \a __n bytes from EEPROM address \a __src to SRAM
 275:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     \a __dst.
 276:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****  */
 277:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** static __inline__ void
 278:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** eeprom_read_block (void *__dst, const void *__src, size_t __n)
 279:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** {
 280:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
 281:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     __eerd_block (__dst, __src, __n, eeprom_read_byte);
 282:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #else
 283:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     /* If ATmega256x device, do not call function. */
 284:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 	char	*_myDstPtr;
 285:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 	char	*_mySrcPtr;
 286:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 	
 287:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 	_myDstPtr	=	(char *)__dst;
 288:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 	_mySrcPtr	=	(char *)__src;
 289:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 	while (__n--)
 290:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     {
 291:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     //*	Jul  6,	2010	modifed by Mark Sproul to work with the 2560
 292:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 	//	*(char *)__dst++	=	eeprom_read_byte((const uint8_t *)__src++);
 293:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 		*_myDstPtr			=	eeprom_read_byte((const uint8_t *)_mySrcPtr);
 294:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 		_myDstPtr++;
 295:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 		_mySrcPtr++;
 296:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     }
 297:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 298:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** }
 299:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 300:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /** \ingroup avr_eeprom
 301:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     Write a byte \a __value to EEPROM address \a __p.
 302:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****  */
 303:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
 304:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** {
 305:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     do {} while (!eeprom_is_ready ());
 306:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 307:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if	defined(EEPM0) && defined(EEPM1)
 308:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     EECR = 0;		/* Set programming mode: erase and write.	*/
 146               	08,.LM5-.LFBB2
 147               	.LM5:
 148               	.LFBB2:
 149               	/* prologue: function */
 150               	/* frame size = 0 */
 151 0000 9C01      		movw r18,r24
 152               	.L6:
 309:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** te() has become outdated."
 153               		68,0,309,.LM6-.LFBB2
 154               	.LM6:
 155 0002 F999      		sbic 63-32,1
 156 0004 00C0      		rjmp .L6
 310:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** nd write.	*/
 311:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #elif	defined(EEPM0) || defined(EEPM1)
 312:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # warning "Unknown EECR register, eeprom_write_byte() has become outdated."
 157               	abn	68,0,312,.LM7-.LFBB2
 158               	.LM7:
 159 0006 1FBA      		out 63-32,__zero_reg__
 313:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** nd write.	*/
 314:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #elif	defined(EEPM0) || defined(EEPM1)
 315:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # warning "Unknown EECR register, eeprom_write_byte() has become outdated."
 316:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 317:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 318:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if	E2END <= 0xFF
 319:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     EEARL = (unsigned)__p;
 320:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #else
 160               	tabn	68,0,320,.LM8-.LFBB2
 161               	.LM8:
 162 0008 32BD      		out (65)+1-32,r19
 163 000a 21BD      		out 65-32,r18
 321:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** nknown EECR register, eeprom_write_byte() has become outdated."
 322:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 164               	abn	68,0,322,.LM9-.LFBB2
 165               	.LM9:
 166 000c 60BD      		out 64-32,r22
 323:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** .	*/
 324:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #elif	defined(EEPM0) || defined(EEPM1)
 167               	tabn	68,0,324,.LM10-.LFBB2
 168               	.LM10:
 169               	/* #APP */
 170               	 ;  324 "d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h" 1
 171               		/* START EEPROM WRITE CRITICAL SECTION */
 172 000e 0FB6      		in	r0, 63		
 173 0010 F894      		cli				
 174 0012 FA9A      		sbi	31, 2	
 175 0014 F99A      		sbi	31, 1	
 176 0016 0FBE      		out	63, r0		
 177               		/* END EEPROM WRITE CRITICAL SECTION */
 178               	 ;  0 "" 2
 179               	/* epilogue start */
 325:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** ined(EEPM0) && defined(EEPM1)
 326:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     EECR = 0;		/* Set programming mode: erase and write.	*/
 327:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #elif	defined(EEPM0) || defined(EEPM1)
 328:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** # warning "Unknown EECR register, eeprom_write_byte() has become outdated."
 329:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 330:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 331:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if	E2END <= 0xFF
 332:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     EEARL = (unsigned)__p;
 333:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #else
 334:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     EEAR = (unsigned)__p;
 335:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 336:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     EEDR = __value;
 337:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 338:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     __asm__ __volatile__ (
 339:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         "/* START EEPROM WRITE CRITICAL SECTION */\n\t"
 180               	339,.LM11-.LFBB2
 181               	.LM11:
 182               	/* #NOAPP */
 183 0018 0895      		ret
 185               	.Lscope2:
 186               		.section	.text.get_char,"ax",@progbits
 188               	.global	get_char
 190               	get_char:
 192               	.Ltext2:
   1:xboot.c       **** /************************************************************************/
   2:xboot.c       **** /* XBoot Extensible AVR Bootloader                                      */
   3:xboot.c       **** /*                                                                      */
   4:xboot.c       **** /* tested with ATXMEGA64A3, ATXMEGA128A1, ATXMEGA256A1, ATXMEGA32A4     */
   5:xboot.c       **** /*                                                                      */
   6:xboot.c       **** /* xboot.c                                                              */
   7:xboot.c       **** /*                                                                      */
   8:xboot.c       **** /* Alex Forencich <alex@alexforencich.com>                              */
   9:xboot.c       **** /*                                                                      */
  10:xboot.c       **** /* Copyright (c) 2010 Alex Forencich                                    */
  11:xboot.c       **** /*                                                                      */
  12:xboot.c       **** /* Permission is hereby granted, free of charge, to any person          */
  13:xboot.c       **** /* obtaining a copy of this software and associated documentation       */
  14:xboot.c       **** /* files(the "Software"), to deal in the Software without restriction,  */
  15:xboot.c       **** /* including without limitation the rights to use, copy, modify, merge, */
  16:xboot.c       **** /* publish, distribute, sublicense, and/or sell copies of the Software, */
  17:xboot.c       **** /* and to permit persons to whom the Software is furnished to do so,    */
  18:xboot.c       **** /* subject to the following conditions:                                 */
  19:xboot.c       **** /*                                                                      */
  20:xboot.c       **** /* The above copyright notice and this permission notice shall be       */
  21:xboot.c       **** /* included in all copies or substantial portions of the Software.      */
  22:xboot.c       **** /*                                                                      */
  23:xboot.c       **** /* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,      */
  24:xboot.c       **** /* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF   */
  25:xboot.c       **** /* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                */
  26:xboot.c       **** /* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  */
  27:xboot.c       **** /* BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN   */
  28:xboot.c       **** /* ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN    */
  29:xboot.c       **** /* CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE     */
  30:xboot.c       **** /* SOFTWARE.                                                            */
  31:xboot.c       **** /*                                                                      */
  32:xboot.c       **** /************************************************************************/
  33:xboot.c       **** 
  34:xboot.c       **** #include "xboot.h"
  35:xboot.c       **** 
  36:xboot.c       **** #ifdef USE_INTERRUPTS
  37:xboot.c       **** volatile unsigned char comm_mode;
  38:xboot.c       **** 
  39:xboot.c       **** volatile unsigned char rx_buff0;
  40:xboot.c       **** volatile unsigned char rx_buff1;
  41:xboot.c       **** volatile unsigned char rx_char_cnt;
  42:xboot.c       **** 
  43:xboot.c       **** volatile unsigned char tx_buff0;
  44:xboot.c       **** volatile unsigned char tx_char_cnt;
  45:xboot.c       **** #else
  46:xboot.c       **** unsigned char comm_mode;
  47:xboot.c       **** #endif // USE_INTERRUPTS
  48:xboot.c       **** 
  49:xboot.c       **** unsigned char buffer[SPM_PAGESIZE];
  50:xboot.c       **** 
  51:xboot.c       **** #ifdef NEED_CODE_PROTECTION
  52:xboot.c       **** unsigned char protected;
  53:xboot.c       **** #endif // NEED_CODE_PROTECTION
  54:xboot.c       **** 
  55:xboot.c       **** // Main code
  56:xboot.c       **** int main(void)
  57:xboot.c       **** {
  58:xboot.c       ****         ADDR_T address = 0;
  59:xboot.c       ****         unsigned char in_bootloader = 0;
  60:xboot.c       ****         unsigned char val = 0;
  61:xboot.c       ****         int i = 0;
  62:xboot.c       ****         uint32_t j;
  63:xboot.c       ****         uint8_t k;
  64:xboot.c       ****         
  65:xboot.c       ****         #ifdef NEED_CODE_PROTECTION
  66:xboot.c       ****         protected = 1;
  67:xboot.c       ****         #endif // NEED_CODE_PROTECTION
  68:xboot.c       ****         
  69:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
  70:xboot.c       ****         unsigned short devid_bit;
  71:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
  72:xboot.c       ****         
  73:xboot.c       ****         comm_mode = MODE_UNDEF;
  74:xboot.c       ****         
  75:xboot.c       ****         #ifdef USE_INTERRUPTS
  76:xboot.c       ****         rx_char_cnt = 0;
  77:xboot.c       ****         tx_char_cnt = 0;
  78:xboot.c       ****         #endif // USE_INTERRUPTS
  79:xboot.c       ****         
  80:xboot.c       ****         // Initialization section
  81:xboot.c       ****         // Entry point and communication methods are initialized here
  82:xboot.c       ****         // --------------------------------------------------
  83:xboot.c       ****         
  84:xboot.c       ****         
  85:xboot.c       **** #ifdef __AVR_XMEGA__
  86:xboot.c       ****         
  87:xboot.c       ****         #ifdef USE_32MHZ_RC
  88:xboot.c       ****         #if (F_CPU != 32000000L)
  89:xboot.c       ****         #error F_CPU must match oscillator setting!
  90:xboot.c       ****         #endif // F_CPU
  91:xboot.c       ****         OSC.CTRL |= OSC_RC32MEN_bm; // turn on 32 MHz oscillator
  92:xboot.c       ****         while (!(OSC.STATUS & OSC_RC32MRDY_bm)) { }; // wait for it to start
  93:xboot.c       ****         CCP = CCP_IOREG_gc;
  94:xboot.c       ****         CLK.CTRL = CLK_SCLKSEL_RC32M_gc;
  95:xboot.c       ****         #ifdef USE_DFLL
  96:xboot.c       ****         DFLLRC32M.CTRL = DFLL_ENABLE_bm;
  97:xboot.c       ****         #endif // USE_DFLL
  98:xboot.c       ****         #else // USE_32MHZ_RC
  99:xboot.c       ****         #if (F_CPU != 2000000L)
 100:xboot.c       ****         #error F_CPU must match oscillator setting!
 101:xboot.c       ****         #endif // F_CPU
 102:xboot.c       ****         #ifdef USE_DFLL
 103:xboot.c       ****         DFLLRC2M.CTRL = DFLL_ENABLE_bm;
 104:xboot.c       ****         #endif // USE_DFLL
 105:xboot.c       ****         #endif // USE_32MHZ_RC
 106:xboot.c       ****         
 107:xboot.c       **** #else // __AVR_XMEGA__
 108:xboot.c       ****         
 109:xboot.c       ****         // nothing special for ATmega
 110:xboot.c       ****         
 111:xboot.c       **** #endif // __AVR_XMEGA__
 112:xboot.c       ****         
 113:xboot.c       ****         // interrupts
 114:xboot.c       ****         
 115:xboot.c       **** #ifdef __AVR_XMEGA__
 116:xboot.c       ****         
 117:xboot.c       ****         #ifdef NEED_INTERRUPTS
 118:xboot.c       ****         // remap interrupts to boot section
 119:xboot.c       ****         CCP = CCP_IOREG_gc;
 120:xboot.c       ****         #ifdef USE_INTERRUPTS
 121:xboot.c       ****         PMIC.CTRL = PMIC_IVSEL_bm | PMIC_LOLVLEN_bm | PMIC_MEDLVLEN_bm;
 122:xboot.c       ****         #else
 123:xboot.c       ****         PMIC.CTRL = PMIC_IVSEL_bm;
 124:xboot.c       ****         #endif // USE_INTERRUPTS
 125:xboot.c       ****         #endif // NEED_INTERRUPTS
 126:xboot.c       ****         
 127:xboot.c       **** #else // __AVR_XMEGA__
 128:xboot.c       ****         
 129:xboot.c       ****         // nothing special for ATmega
 130:xboot.c       ****         
 131:xboot.c       **** #endif // __AVR_XMEGA__
 132:xboot.c       ****         
 133:xboot.c       ****         // LED
 134:xboot.c       ****         
 135:xboot.c       **** #ifdef __AVR_XMEGA__
 136:xboot.c       ****         
 137:xboot.c       ****         #ifdef USE_LED
 138:xboot.c       ****         // Initialize LED pin
 139:xboot.c       ****         LED_PORT.DIRSET = (1 << LED_PIN);
 140:xboot.c       ****         #if LED_PIN_INV
 141:xboot.c       ****         LED_PORT.OUTCLR = (1 << LED_PIN);
 142:xboot.c       ****         #else
 143:xboot.c       ****         LED_PORT.OUTSET = (1 << LED_PIN);
 144:xboot.c       ****         #endif // LED_PIN_INV
 145:xboot.c       ****         #endif // USE_LED
 146:xboot.c       ****         
 147:xboot.c       **** #else // __AVR_XMEGA__
 148:xboot.c       ****         
 149:xboot.c       ****         #ifdef USE_LED
 150:xboot.c       ****         // Initialize LED pin
 151:xboot.c       ****         LED_PORT_DDR |= (1 << LED_PIN);
 152:xboot.c       ****         #if LED_PIN_INV
 153:xboot.c       ****         LED_PORT &= ~(1 << LED_PIN);
 154:xboot.c       ****         #else
 155:xboot.c       ****         LED_PORT |= (1 << LED_PIN);
 156:xboot.c       ****         #endif // LED_PIN_INV
 157:xboot.c       ****         #endif // USE_LED
 158:xboot.c       ****         
 159:xboot.c       **** #endif // __AVR_XMEGA__
 160:xboot.c       ****         
 161:xboot.c       ****         // I2C Attach LED_PIN
 162:xboot.c       ****         
 163:xboot.c       **** #ifdef __AVR_XMEGA__
 164:xboot.c       ****         
 165:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
 166:xboot.c       ****         #ifdef USE_ATTACH_LED
 167:xboot.c       ****         // Initialize ATTACH_LED
 168:xboot.c       ****         ATTACH_LED_PORT.DIRSET = (1 << ATTACH_LED_PIN);
 169:xboot.c       ****         #if ATTACH_LED_INV
 170:xboot.c       ****         ATTACH_LED_PORT.OUTSET = (1 << ATTACH_LED_PIN);
 171:xboot.c       ****         #else
 172:xboot.c       ****         ATTACH_LED_PORT.OUTCLR = (1 << ATTACH_LED_PIN);
 173:xboot.c       ****         #endif // ATTACH_LED_INV
 174:xboot.c       ****         #endif // USE_ATTACH_LED
 175:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
 176:xboot.c       ****         
 177:xboot.c       **** #else // __AVR_XMEGA__
 178:xboot.c       ****         
 179:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
 180:xboot.c       ****         #ifdef USE_ATTACH_LED
 181:xboot.c       ****         // Initialize ATTACH_LED
 182:xboot.c       ****         ATTACH_LED_PORT_DDR |= (1 << ATTACH_LED_PIN);
 183:xboot.c       ****         #if ATTACH_LED_INV
 184:xboot.c       ****         ATTACH_LED_PORT |= (1 << ATTACH_LED_PIN);
 185:xboot.c       ****         #else
 186:xboot.c       ****         ATTACH_LED_PORT &= ~(1 << ATTACH_LED_PIN);
 187:xboot.c       ****         #endif // ATTACH_LED_INV
 188:xboot.c       ****         #endif // USE_ATTACH_LED
 189:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
 190:xboot.c       ****         
 191:xboot.c       **** #endif // __AVR_XMEGA__
 192:xboot.c       ****         
 193:xboot.c       ****         // Enter pin
 194:xboot.c       ****         
 195:xboot.c       **** #ifdef __AVR_XMEGA__
 196:xboot.c       ****         
 197:xboot.c       ****         #ifdef USE_ENTER_PIN
 198:xboot.c       ****         // Make sure it's an input
 199:xboot.c       ****         ENTER_PORT.DIRCLR = (1 << ENTER_PIN);
 200:xboot.c       ****         #if ENTER_PIN_PUEN
 201:xboot.c       ****         // Enable bootloader entry pin pullup
 202:xboot.c       ****         ENTER_PIN_CTRL = 0x18;
 203:xboot.c       ****         #endif // ENTER_PIN_PUEN
 204:xboot.c       ****         #endif // USE_ENTER_PIN
 205:xboot.c       ****         
 206:xboot.c       **** #else // __AVR_XMEGA__
 207:xboot.c       ****         
 208:xboot.c       ****         #ifdef USE_ENTER_PIN
 209:xboot.c       ****         // Make sure it's an input
 210:xboot.c       ****         ENTER_PORT_DDR &= ~(1 << ENTER_PIN);
 211:xboot.c       ****         #if ENTER_PIN_PUEN
 212:xboot.c       ****         // Enable bootloader entry pin pullup
 213:xboot.c       ****         ENTER_PORT |= (1 << ENTER_PIN);
 214:xboot.c       ****         #else // ENER_PIN_PUEN
 215:xboot.c       ****         // Disable bootloader entry pin pullup
 216:xboot.c       ****         ENTER_PORT &= ~(1 << ENTER_PIN);
 217:xboot.c       ****         #endif // ENTER_PIN_PUEN
 218:xboot.c       ****         #endif // USE_ENTER_PIN
 219:xboot.c       ****         
 220:xboot.c       **** #endif // __AVR_XMEGA__
 221:xboot.c       ****         
 222:xboot.c       ****         #ifdef USE_UART
 223:xboot.c       ****         // Initialize UART
 224:xboot.c       ****         uart_init();
 225:xboot.c       ****         
 226:xboot.c       ****         // Initialize RX pin pull-up
 227:xboot.c       ****         
 228:xboot.c       **** #ifdef __AVR_XMEGA__
 229:xboot.c       ****         
 230:xboot.c       ****         #ifdef UART_RX_PUEN
 231:xboot.c       ****         // Enable RX pin pullup
 232:xboot.c       ****         UART_RX_PIN_CTRL = 0x18;
 233:xboot.c       ****         #endif // UART_RX_PUEN
 234:xboot.c       ****         
 235:xboot.c       **** #else // __AVR_XMEGA__
 236:xboot.c       ****         
 237:xboot.c       ****         #ifdef UART_RX_PUEN
 238:xboot.c       ****         // Enable RX pin pullup
 239:xboot.c       ****         UART_PORT |= (1 << UART_RX_PIN);
 240:xboot.c       ****         #endif // UART_RX_PUEN
 241:xboot.c       ****         
 242:xboot.c       **** #endif // __AVR_XMEGA__
 243:xboot.c       ****         
 244:xboot.c       ****         // Initialize UART EN pin
 245:xboot.c       ****         
 246:xboot.c       **** #ifdef __AVR_XMEGA__
 247:xboot.c       ****         
 248:xboot.c       ****         #ifdef USE_UART_EN_PIN
 249:xboot.c       ****         UART_EN_PORT.DIRSET = (1 << UART_EN_PIN);
 250:xboot.c       ****         #if UART_EN_INV
 251:xboot.c       ****         UART_EN_PORT.OUTSET = (1 << UART_EN_PIN);
 252:xboot.c       ****         #else // UART_PIN_INV
 253:xboot.c       ****         UART_EN_PORT.OUTCLR = (1 << UART_EN_PIN);
 254:xboot.c       ****         #endif // UART_PIN_INV
 255:xboot.c       ****         #endif // USE_UART_EN_PIN
 256:xboot.c       ****         
 257:xboot.c       **** #else // __AVR_XMEGA__
 258:xboot.c       ****         
 259:xboot.c       ****         #ifdef USE_UART_EN_PIN
 260:xboot.c       ****         UART_EN_PORT_DDR |= (1 << UART_EN_PIN);
 261:xboot.c       ****         #if UART_EN_INV
 262:xboot.c       ****         UART_EN_PORT |= (1 << UART_EN_PIN);
 263:xboot.c       ****         #else // UART_PIN_INV
 264:xboot.c       ****         UART_EN_PORT &= ~(1 << UART_EN_PIN);
 265:xboot.c       ****         #endif // UART_PIN_INV
 266:xboot.c       ****         #endif // USE_UART_EN_PIN
 267:xboot.c       ****         
 268:xboot.c       **** #endif // __AVR_XMEGA__
 269:xboot.c       ****         
 270:xboot.c       ****         #endif // USE_UART
 271:xboot.c       ****         
 272:xboot.c       ****         #ifdef USE_I2C
 273:xboot.c       ****         // Initialize I2C interface
 274:xboot.c       ****         i2c_init();
 275:xboot.c       ****         
 276:xboot.c       **** #ifdef __AVR_XMEGA__
 277:xboot.c       ****         
 278:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
 279:xboot.c       ****         I2C_AUTONEG_PORT.DIRCLR = (1 << I2C_AUTONEG_PIN);
 280:xboot.c       ****         I2C_AUTONEG_PORT.OUTCLR = (1 << I2C_AUTONEG_PIN);
 281:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
 282:xboot.c       ****         
 283:xboot.c       **** #else // __AVR_XMEGA__
 284:xboot.c       ****         
 285:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
 286:xboot.c       ****         I2C_AUTONEG_PORT_DDR &= ~(1 << I2C_AUTONEG_PIN);
 287:xboot.c       ****         I2C_AUTONEG_PORT &= ~(1 << I2C_AUTONEG_PIN);
 288:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
 289:xboot.c       ****         
 290:xboot.c       **** #endif // __AVR_XMEGA__
 291:xboot.c       ****         
 292:xboot.c       ****         #endif // USE_I2C
 293:xboot.c       ****         
 294:xboot.c       ****         #ifdef USE_FIFO
 295:xboot.c       ****         // Initialize FIFO
 296:xboot.c       ****         fifo_init();
 297:xboot.c       ****         #endif // USE_FIFO
 298:xboot.c       ****         
 299:xboot.c       **** #ifndef __AVR_XMEGA__
 300:xboot.c       ****         // ATMEGA must reset via watchdog, so turn it off
 301:xboot.c       ****         MCUSR = 0;
 302:xboot.c       ****         wdt_disable();
 303:xboot.c       **** #endif
 304:xboot.c       ****         
 305:xboot.c       ****         // --------------------------------------------------
 306:xboot.c       ****         // End initialization section
 307:xboot.c       ****         
 308:xboot.c       ****         // One time trigger section
 309:xboot.c       ****         // Triggers that are checked once, regardless of
 310:xboot.c       ****         // whether or not USE_ENTER_DELAY is selected
 311:xboot.c       ****         // --------------------------------------------------
 312:xboot.c       ****         
 313:xboot.c       ****         
 314:xboot.c       ****         
 315:xboot.c       ****         // --------------------------------------------------
 316:xboot.c       ****         // End one time trigger section
 317:xboot.c       ****         
 318:xboot.c       **** #ifdef USE_ENTER_DELAY
 319:xboot.c       ****         k = ENTER_BLINK_COUNT*2;
 320:xboot.c       ****         j = ENTER_BLINK_WAIT;
 321:xboot.c       ****         while (!in_bootloader && k > 0)
 322:xboot.c       ****         {
 323:xboot.c       ****                 if (j-- <= 0)
 324:xboot.c       ****                 {
 325:xboot.c       ****                         #ifdef USE_LED
 326:xboot.c       **** #ifdef __AVR_XMEGA__
 327:xboot.c       ****                         LED_PORT.OUTTGL = (1 << LED_PIN);
 328:xboot.c       **** #else // __AVR_XMEGA__
 329:xboot.c       ****                         LED_PORT ^= (1 << LED_PIN);
 330:xboot.c       **** #endif // __AVR_XMEGA__
 331:xboot.c       ****                         #endif // USE_LED
 332:xboot.c       ****                         j = ENTER_BLINK_WAIT;
 333:xboot.c       ****                         k--;
 334:xboot.c       ****                 }
 335:xboot.c       **** #else // USE_ENTER_DELAY
 336:xboot.c       ****                 // Need a small delay when not running loop
 337:xboot.c       ****                 // so we don't accidentally enter the bootloader
 338:xboot.c       ****                 // on power-up with USE_ENTER_PIN selected
 339:xboot.c       ****                 asm("nop");
 340:xboot.c       ****                 asm("nop");
 341:xboot.c       ****                 asm("nop");
 342:xboot.c       ****                 asm("nop");
 343:xboot.c       **** #endif // USE_ENTER_DELAY
 344:xboot.c       ****                 
 345:xboot.c       ****                 // Main trigger section
 346:xboot.c       ****                 // Set in_bootloader here to enter the bootloader
 347:xboot.c       ****                 // Checked when USE_ENTER_DELAY is selected
 348:xboot.c       ****                 // --------------------------------------------------
 349:xboot.c       ****                 
 350:xboot.c       ****                 #ifdef USE_ENTER_PIN
 351:xboot.c       ****                 // Check entry pin state
 352:xboot.c       **** #ifdef __AVR_XMEGA__
 353:xboot.c       ****                 if ((ENTER_PORT.IN & (1 << ENTER_PIN)) == (ENTER_PIN_STATE ? (1 << ENTER_PIN) : 0))
 354:xboot.c       ****                         in_bootloader = 1;
 355:xboot.c       **** #else // __AVR_XMEGA__
 356:xboot.c       ****                 if ((ENTER_PORT_PIN & (1 << ENTER_PIN)) == (ENTER_PIN_STATE ? (1 << ENTER_PIN) : 0)
 357:xboot.c       ****                         in_bootloader = 1;
 358:xboot.c       **** #endif // __AVR_XMEGA__
 359:xboot.c       ****                 #endif // USE_ENTER_PIN
 360:xboot.c       ****                 
 361:xboot.c       ****                 #ifdef USE_ENTER_UART
 362:xboot.c       ****                 // Check for received character
 363:xboot.c       ****                 #ifdef ENTER_UART_NEED_SYNC
 364:xboot.c       ****                 if (uart_char_received() && (uart_cur_char() == CMD_SYNC))
 365:xboot.c       ****                 #else // ENTER_UART_NEED_SYNC
 366:xboot.c       ****                 if (uart_char_received())
 367:xboot.c       ****                 #endif // ENTER_UART_NEED_SYNC
 368:xboot.c       ****                 {
 369:xboot.c       ****                         in_bootloader = 1;
 370:xboot.c       ****                         comm_mode = MODE_UART;
 371:xboot.c       ****                 }
 372:xboot.c       ****                 
 373:xboot.c       ****                 #endif // USE_ENTER_UART
 374:xboot.c       ****                 
 375:xboot.c       ****                 #ifdef USE_ENTER_I2C
 376:xboot.c       ****                 // Check for address match condition
 377:xboot.c       ****                 if (i2c_address_match())
 378:xboot.c       ****                 {
 379:xboot.c       ****                         in_bootloader = 1;
 380:xboot.c       ****                         comm_mode = MODE_I2C;
 381:xboot.c       ****                 }
 382:xboot.c       ****                 #endif // USE_ENTER_I2C
 383:xboot.c       ****                 
 384:xboot.c       ****                 #ifdef USE_ENTER_FIFO
 385:xboot.c       ****                 // Check for received character
 386:xboot.c       ****                 #ifdef ENTER_FIFO_NEED_SYNC
 387:xboot.c       ****                 if (fifo_char_received() && (fifo_cur_char() == CMD_SYNC))
 388:xboot.c       ****                 #else // ENTER_FIFO_NEED_SYNC
 389:xboot.c       ****                 if (fifo_char_received())
 390:xboot.c       ****                 #endif // ENTER_FIFO_NEED_SYNC
 391:xboot.c       ****                 {
 392:xboot.c       ****                         in_bootloader = 1;
 393:xboot.c       ****                         comm_mode = MODE_FIFO;
 394:xboot.c       ****                 }
 395:xboot.c       ****                 
 396:xboot.c       ****                 #endif // USE_ENTER_FIFO
 397:xboot.c       ****                 
 398:xboot.c       ****                 // --------------------------------------------------
 399:xboot.c       ****                 // End main trigger section
 400:xboot.c       ****                 
 401:xboot.c       **** #ifdef __AVR_XMEGA__
 402:xboot.c       ****                 WDT_Reset();
 403:xboot.c       **** #else // __AVR_XMEGA__
 404:xboot.c       ****                 wdt_reset();
 405:xboot.c       **** #endif // __AVR_XMEGA__
 406:xboot.c       ****                 
 407:xboot.c       **** #ifdef USE_ENTER_DELAY
 408:xboot.c       ****         }
 409:xboot.c       **** #endif // USE_ENTER_DELAY
 410:xboot.c       ****         
 411:xboot.c       ****         #ifdef USE_INTERRUPTS
 412:xboot.c       ****         // Enable interrupts
 413:xboot.c       ****         sei();
 414:xboot.c       ****         #endif // USE_INTERRUPTS
 415:xboot.c       ****         
 416:xboot.c       ****         #ifdef USE_WATCHDOG
 417:xboot.c       ****         WDT_EnableAndSetTimeout();
 418:xboot.c       ****         #endif // USE_WATCHDOG
 419:xboot.c       ****         
 420:xboot.c       ****         // Main bootloader        
 421:xboot.c       ****         while (in_bootloader) {
 422:xboot.c       ****                 #ifdef USE_LED
 423:xboot.c       **** #ifdef __AVR_XMEGA__
 424:xboot.c       ****                 LED_PORT.OUTTGL = (1 << LED_PIN);
 425:xboot.c       **** #else // __AVR_XMEGA__
 426:xboot.c       ****                 LED_PORT ^= (1 << LED_PIN);
 427:xboot.c       **** #endif // __AVR_XMEGA__
 428:xboot.c       ****                 #endif // USE_LED
 429:xboot.c       ****                 
 430:xboot.c       ****                 val = get_char();
 431:xboot.c       ****                 
 432:xboot.c       ****                 #ifdef USE_WATCHDOG
 433:xboot.c       ****                 WDT_Reset();
 434:xboot.c       ****                 #endif // USE_WATCHDOG
 435:xboot.c       ****                 
 436:xboot.c       ****                 // Main bootloader parser
 437:xboot.c       ****                 // check autoincrement status
 438:xboot.c       ****                 if (val == CMD_CHECK_AUTOINCREMENT)
 439:xboot.c       ****                 {
 440:xboot.c       ****                         // yes, it is supported
 441:xboot.c       ****                         send_char(REPLY_YES);
 442:xboot.c       ****                 }
 443:xboot.c       ****                 // Set address
 444:xboot.c       ****                 else if (val == CMD_SET_ADDRESS)
 445:xboot.c       ****                 {
 446:xboot.c       ****                         // Read address high then low
 447:xboot.c       ****                         address = get_2bytes();
 448:xboot.c       ****                         // acknowledge
 449:xboot.c       ****                         send_char(REPLY_ACK);
 450:xboot.c       ****                 }
 451:xboot.c       ****                 // Extended address
 452:xboot.c       ****                 else if (val == CMD_SET_EXT_ADDRESS)
 453:xboot.c       ****                 {
 454:xboot.c       ****                         // Read address high then low
 455:xboot.c       ****                         //address = ((ADDR_T)get_char() << 16) | get_2bytes();
 456:xboot.c       ****                         asm volatile (
 457:xboot.c       ****                                 "call get_char"    "\n\t"
 458:xboot.c       ****                                 "mov  %C0,r24"     "\n\t"
 459:xboot.c       ****                                 "call get_2bytes"  "\n\t"
 460:xboot.c       ****                                 "clr  %D0"         "\n\t"
 461:xboot.c       ****                                 : "=r" (address)
 462:xboot.c       ****                                 :
 463:xboot.c       ****                         );
 464:xboot.c       ****                         
 465:xboot.c       ****                         // acknowledge
 466:xboot.c       ****                         send_char(REPLY_ACK);
 467:xboot.c       ****                 }
 468:xboot.c       ****                 // Chip erase
 469:xboot.c       ****                 else if (val == CMD_CHIP_ERASE)
 470:xboot.c       ****                 {
 471:xboot.c       ****                         // Erase the application section
 472:xboot.c       ****                         Flash_EraseApplicationSection();
 473:xboot.c       ****                         // Wait for completion
 474:xboot.c       **** #ifdef __AVR_XMEGA__
 475:xboot.c       ****                         #ifdef USE_WATCHDOG
 476:xboot.c       ****                         while (NVM_STATUS & NVM_NVMBUSY_bp)
 477:xboot.c       ****                         {
 478:xboot.c       ****                                 // reset watchdog while waiting for erase completion
 479:xboot.c       ****                                 WDT_Reset();
 480:xboot.c       ****                         }
 481:xboot.c       ****                         #else // USE_WATCHDOG
 482:xboot.c       ****                         SP_WaitForSPM();
 483:xboot.c       ****                         #endif // USE_WATCHDOG
 484:xboot.c       **** #endif // __AVR_XMEGA__
 485:xboot.c       ****                         
 486:xboot.c       ****                         // Erase EEPROM
 487:xboot.c       ****                         EEPROM_erase_all();
 488:xboot.c       ****                         
 489:xboot.c       ****                         // turn off read protection
 490:xboot.c       ****                         #ifdef NEED_CODE_PROTECTION
 491:xboot.c       ****                         protected = 0;
 492:xboot.c       ****                         #endif // NEED_CODE_PROTECTION
 493:xboot.c       ****                         
 494:xboot.c       ****                         // acknowledge
 495:xboot.c       ****                         send_char(REPLY_ACK);
 496:xboot.c       ****                 }
 497:xboot.c       ****                 #ifdef ENABLE_BLOCK_SUPPORT
 498:xboot.c       ****                 // Check block load support
 499:xboot.c       ****                 else if (val == CMD_CHECK_BLOCK_SUPPORT )
 500:xboot.c       ****                 {
 501:xboot.c       ****                         // yes, it is supported
 502:xboot.c       ****                         send_char(REPLY_YES);
 503:xboot.c       ****                         // Send block size (page size)
 504:xboot.c       ****                         send_char((SPM_PAGESIZE >> 8) & 0xFF);
 505:xboot.c       ****                         send_char(SPM_PAGESIZE & 0xFF);
 506:xboot.c       ****                 }
 507:xboot.c       ****                 // Block load
 508:xboot.c       ****                 else if (val == CMD_BLOCK_LOAD)
 509:xboot.c       ****                 {
 510:xboot.c       ****                         // Block size
 511:xboot.c       ****                         i = get_2bytes();
 512:xboot.c       ****                         // Memory type
 513:xboot.c       ****                         val = get_char();
 514:xboot.c       ****                         // Load it
 515:xboot.c       ****                         send_char(BlockLoad(i, val, &address));
 516:xboot.c       ****                 }
 517:xboot.c       ****                 // Block read
 518:xboot.c       ****                 else if (val == CMD_BLOCK_READ)
 519:xboot.c       ****                 {
 520:xboot.c       ****                         // Block size
 521:xboot.c       ****                         i = get_2bytes();
 522:xboot.c       ****                         // Memory type
 523:xboot.c       ****                         val = get_char();
 524:xboot.c       ****                         // Read it
 525:xboot.c       ****                         BlockRead(i, val, &address);
 526:xboot.c       ****                 }
 527:xboot.c       ****                 #endif // ENABLE_BLOCK_SUPPORT
 528:xboot.c       ****                 #ifdef ENABLE_FLASH_BYTE_SUPPORT
 529:xboot.c       ****                 // Read program memory byte
 530:xboot.c       ****                 else if (val == CMD_READ_BYTE)
 531:xboot.c       ****                 {
 532:xboot.c       ****                         unsigned int w = Flash_ReadWord((address << 1));
 533:xboot.c       ****                         
 534:xboot.c       ****                         #ifdef ENABLE_CODE_PROTECTION
 535:xboot.c       ****                         if (protected)
 536:xboot.c       ****                                 w = 0xffff;
 537:xboot.c       ****                         #endif // ENABLE_CODE_PROTECTION
 538:xboot.c       ****                         
 539:xboot.c       ****                         send_char(w >> 8);
 540:xboot.c       ****                         send_char(w);
 541:xboot.c       ****                         
 542:xboot.c       ****                         address++;
 543:xboot.c       ****                 }
 544:xboot.c       ****                 // Write program memory low byte
 545:xboot.c       ****                 else if (val == CMD_WRITE_LOW_BYTE)
 546:xboot.c       ****                 {
 547:xboot.c       ****                         // get low byte
 548:xboot.c       ****                         i = get_char();
 549:xboot.c       ****                         send_char(REPLY_ACK);
 550:xboot.c       ****                 }
 551:xboot.c       ****                 // Write program memory high byte
 552:xboot.c       ****                 else if (val == CMD_WRITE_HIGH_BYTE)
 553:xboot.c       ****                 {
 554:xboot.c       ****                         // get high byte; combine
 555:xboot.c       ****                         i |= (get_char() << 8);
 556:xboot.c       ****                         Flash_LoadFlashWord((address << 1), i);
 557:xboot.c       ****                         address++;
 558:xboot.c       ****                         send_char(REPLY_ACK);
 559:xboot.c       ****                 }
 560:xboot.c       ****                 // Write page
 561:xboot.c       ****                 else if (val == CMD_WRITE_PAGE)
 562:xboot.c       ****                 {
 563:xboot.c       ****                         if (address >= (APP_SECTION_SIZE>>1))
 564:xboot.c       ****                         {
 565:xboot.c       ****                                 // don't allow bootloader overwrite
 566:xboot.c       ****                                 send_char(REPLY_ERROR);
 567:xboot.c       ****                         }
 568:xboot.c       ****                         else
 569:xboot.c       ****                         {
 570:xboot.c       ****                                 Flash_WriteApplicationPage( address << 1);
 571:xboot.c       ****                                 send_char(REPLY_ACK);
 572:xboot.c       ****                         }
 573:xboot.c       ****                 }
 574:xboot.c       ****                 #endif // ENABLE_FLASH_BYTE_SUPPORT
 575:xboot.c       ****                 #ifdef ENABLE_EEPROM_BYTE_SUPPORT
 576:xboot.c       ****                 // Write EEPROM memory
 577:xboot.c       ****                 else if (val == CMD_WRITE_EEPROM_BYTE)
 578:xboot.c       ****                 {
 579:xboot.c       ****                         EEPROM_write_byte(address, get_char());
 580:xboot.c       ****                         address++;
 581:xboot.c       ****                 }
 582:xboot.c       ****                 // Read EEPROM memory
 583:xboot.c       ****                 else if (val == CMD_READ_EEPROM_BYTE)
 584:xboot.c       ****                 {
 585:xboot.c       ****                         char c = EEPROM_read_byte(address);
 586:xboot.c       ****                         
 587:xboot.c       ****                         #ifdef ENABLE_EEPROM_PROTECTION
 588:xboot.c       ****                         if (protected)
 589:xboot.c       ****                                 c = 0xff;
 590:xboot.c       ****                         #endif // ENABLE_EEPROM_PROTECTION
 591:xboot.c       ****                         
 592:xboot.c       ****                         send_char(c);
 593:xboot.c       ****                         address++;
 594:xboot.c       ****                 }
 595:xboot.c       ****                 #endif // ENABLE_EEPROM_BYTE_SUPPORT
 596:xboot.c       ****                 #ifdef ENABLE_LOCK_BITS
 597:xboot.c       **** #ifdef __AVR_XMEGA__
 598:xboot.c       ****                 // Write lockbits
 599:xboot.c       ****                 else if (val == CMD_WRITE_LOCK_BITS)
 600:xboot.c       ****                 {
 601:xboot.c       ****                         SP_WriteLockBits( get_char() );
 602:xboot.c       ****                         send_char(REPLY_ACK);
 603:xboot.c       ****                 }
 604:xboot.c       ****                 // Read lockbits
 605:xboot.c       ****                 else if (val == CMD_READ_LOCK_BITS)
 606:xboot.c       ****                 {
 607:xboot.c       ****                         send_char(SP_ReadLockBits());
 608:xboot.c       ****                 }
 609:xboot.c       **** #endif // __AVR_XMEGA__
 610:xboot.c       ****                 #endif // ENABLE_LOCK_BITS
 611:xboot.c       ****                 #ifdef ENABLE_FUSE_BITS
 612:xboot.c       **** #ifdef __AVR_XMEGA__
 613:xboot.c       ****                 // Read low fuse bits
 614:xboot.c       ****                 else if (val == CMD_READ_LOW_FUSE_BITS)
 615:xboot.c       ****                 {
 616:xboot.c       ****                         send_char(SP_ReadFuseByte(0));
 617:xboot.c       ****                 }
 618:xboot.c       ****                 // Read high fuse bits
 619:xboot.c       ****                 else if (val == CMD_READ_HIGH_FUSE_BITS)
 620:xboot.c       ****                 {
 621:xboot.c       ****                         send_char(SP_ReadFuseByte(1));
 622:xboot.c       ****                 }
 623:xboot.c       ****                 // Read extended fuse bits
 624:xboot.c       ****                 else if (val == CMD_READ_EXT_FUSE_BITS)
 625:xboot.c       ****                 {
 626:xboot.c       ****                         send_char(SP_ReadFuseByte(2));
 627:xboot.c       ****                 }
 628:xboot.c       **** #endif // __AVR_XMEGA__
 629:xboot.c       ****                 #endif // ENABLE_FUSE_BITS
 630:xboot.c       ****                 // Enter and leave programming mode
 631:xboot.c       ****                 else if ((val == CMD_ENTER_PROG_MODE) || (val == CMD_LEAVE_PROG_MODE))
 632:xboot.c       ****                 {
 633:xboot.c       ****                         // just acknowledge
 634:xboot.c       ****                         send_char(REPLY_ACK);
 635:xboot.c       ****                 }
 636:xboot.c       ****                 // Exit bootloader
 637:xboot.c       ****                 else if (val == CMD_EXIT_BOOTLOADER)
 638:xboot.c       ****                 {
 639:xboot.c       ****                         in_bootloader = 0;
 640:xboot.c       ****                         send_char(REPLY_ACK);
 641:xboot.c       ****                 }
 642:xboot.c       ****                 // Get programmer type
 643:xboot.c       ****                 else if (val == CMD_PROGRAMMER_TYPE)
 644:xboot.c       ****                 {
 645:xboot.c       ****                         // serial
 646:xboot.c       ****                         send_char('S');
 647:xboot.c       ****                 }
 648:xboot.c       ****                 // Return supported device codes
 649:xboot.c       ****                 else if (val == CMD_DEVICE_CODE)
 650:xboot.c       ****                 {
 651:xboot.c       ****                         // send only this device
 652:xboot.c       ****                         send_char(123); // TODO
 653:xboot.c       ****                         // terminator
 654:xboot.c       ****                         send_char(0);
 655:xboot.c       ****                 }
 656:xboot.c       ****                 // Set LED, clear LED, and set device type
 657:xboot.c       ****                 else if ((val == CMD_SET_LED) || (val == CMD_CLEAR_LED) || (val == CMD_SET_TYPE))
 658:xboot.c       ****                 {
 659:xboot.c       ****                         // discard parameter
 660:xboot.c       ****                         get_char();
 661:xboot.c       ****                         send_char(REPLY_ACK);
 662:xboot.c       ****                 }
 663:xboot.c       ****                 // Return program identifier
 664:xboot.c       ****                 else if (val == CMD_PROGRAM_ID)
 665:xboot.c       ****                 {
 666:xboot.c       ****                         send_char('X');
 667:xboot.c       ****                         send_char('B');
 668:xboot.c       ****                         send_char('o');
 669:xboot.c       ****                         send_char('o');
 670:xboot.c       ****                         send_char('t');
 671:xboot.c       ****                         send_char('+');
 672:xboot.c       ****                         send_char('+');
 673:xboot.c       ****                 }
 674:xboot.c       ****                 // Read software version
 675:xboot.c       ****                 else if (val == CMD_VERSION)
 676:xboot.c       ****                 {
 677:xboot.c       ****                         send_char('0' + XBOOT_VERSION_MAJOR);
 678:xboot.c       ****                         send_char('0' + XBOOT_VERSION_MINOR);
 679:xboot.c       ****                 }
 680:xboot.c       ****                 // Read signature bytes
 681:xboot.c       ****                 else if (val == CMD_READ_SIGNATURE)
 682:xboot.c       ****                 {
 683:xboot.c       ****                         send_char(SIGNATURE_2);
 684:xboot.c       ****                         send_char(SIGNATURE_1);
 685:xboot.c       ****                         send_char(SIGNATURE_0);
 686:xboot.c       ****                 }
 687:xboot.c       ****                 #ifdef ENABLE_CRC_SUPPORT
 688:xboot.c       ****                 else if (val == CMD_CRC)
 689:xboot.c       ****                 {
 690:xboot.c       ****                         uint32_t start = 0;
 691:xboot.c       ****                         uint32_t length = 0;
 692:xboot.c       ****                         uint16_t crc;
 693:xboot.c       ****                         
 694:xboot.c       ****                         val = get_char();
 695:xboot.c       ****                         
 696:xboot.c       ****                         switch (val)
 697:xboot.c       ****                         {
 698:xboot.c       ****                                 case SECTION_FLASH:
 699:xboot.c       ****                                         length = PROGMEM_SIZE;
 700:xboot.c       ****                                         break;
 701:xboot.c       ****                                 case SECTION_APPLICATION:
 702:xboot.c       ****                                         length = APP_SECTION_SIZE;
 703:xboot.c       ****                                         break;
 704:xboot.c       ****                                 case SECTION_BOOT:
 705:xboot.c       ****                                         start = BOOT_SECTION_START;
 706:xboot.c       ****                                         length = BOOT_SECTION_SIZE;
 707:xboot.c       ****                                         break;
 708:xboot.c       ****                                 #ifdef ENABLE_API
 709:xboot.c       ****                                 case SECTION_APP:
 710:xboot.c       ****                                         length = XB_APP_SIZE;
 711:xboot.c       ****                                         break;
 712:xboot.c       ****                                 case SECTION_APP_TEMP:
 713:xboot.c       ****                                         start = XB_APP_TEMP_START;
 714:xboot.c       ****                                         length = XB_APP_TEMP_SIZE;
 715:xboot.c       ****                                         break;
 716:xboot.c       ****                                 #endif // ENABLE_API
 717:xboot.c       ****                                 default:
 718:xboot.c       ****                                         send_char(REPLY_ERROR);
 719:xboot.c       ****                                         continue;
 720:xboot.c       ****                         }
 721:xboot.c       ****                         
 722:xboot.c       ****                         crc = crc16_block(start, length);
 723:xboot.c       ****                         
 724:xboot.c       ****                         send_char((crc >> 8) & 0xff);
 725:xboot.c       ****                         send_char(crc & 0xff);
 726:xboot.c       ****                 }
 727:xboot.c       ****                 #endif // ENABLE_CRC_SUPPORT
 728:xboot.c       ****                 #ifdef USE_I2C
 729:xboot.c       ****                 #ifdef USE_I2C_ADDRESS_NEGOTIATION
 730:xboot.c       ****                 // Enter autonegotiate mode
 731:xboot.c       ****                 else if (val == CMD_AUTONEG_START)
 732:xboot.c       ****                 {
 733:xboot.c       ****                         // The address autonegotiation protocol is borrowed from the
 734:xboot.c       ****                         // OneWire address detection method.  The algorthim Utilizes
 735:xboot.c       ****                         // one extra shared wire, pulled up by resistors just like the
 736:xboot.c       ****                         // main I2C bus, a OneWire bus, or a wired-AND IRQ line.
 737:xboot.c       ****                         // The protocol involves intelligently guessing all of the
 738:xboot.c       ****                         // connected devices' 88 bit unique hardware ID numbers, stored
 739:xboot.c       ****                         // permanently in the production signature row during manufacture
 740:xboot.c       ****                         // (see XMega series datasheet for details)
 741:xboot.c       ****                         #ifdef __AVR_XMEGA__
 742:xboot.c       ****                         // k is temp
 743:xboot.c       ****                         // devid is pointer to current bit, init to first bit
 744:xboot.c       ****                         // of the hardware ID in the production signature row
 745:xboot.c       ****                         devid_bit = 0x08 << 3;
 746:xboot.c       ****                         // read first byte of hardware ID into temporary location
 747:xboot.c       ****                         k = SP_ReadCalibrationByte(0x08);
 748:xboot.c       ****                         
 749:xboot.c       ****                         // main negotiation loop
 750:xboot.c       ****                         while (1)
 751:xboot.c       ****                         {
 752:xboot.c       ****                                 // wait for incoming data
 753:xboot.c       ****                                 while (1)
 754:xboot.c       ****                                 {
 755:xboot.c       ****                                         // check for bit read command
 756:xboot.c       ****                                         if (!(I2C_AUTONEG_PORT.IN & (1 << I2C_AUTONEG_PIN)))
 757:xboot.c       ****                                         {
 758:xboot.c       ****                                                 // write current bit of hardware ID
 759:xboot.c       ****                                                 ow_slave_write_bit(k & 1);  // write bit
 760:xboot.c       ****                                                 break;
 761:xboot.c       ****                                         }
 762:xboot.c       ****                                         // check for I2C bus activity
 763:xboot.c       ****                                         else if (I2C_DEVICE.SLAVE.STATUS & (TWI_SLAVE_APIF_bm | TWI
 764:xboot.c       ****                                         {
 765:xboot.c       ****                                                 // grab a byte
 766:xboot.c       ****                                                 // (there will be no I2C bus activity while
 767:xboot.c       ****                                                 // the autonegotiation is taking place,
 768:xboot.c       ****                                                 // so it's OK to block)
 769:xboot.c       ****                                                 val = get_char();
 770:xboot.c       ****                                                 // Is this an address byte for me?
 771:xboot.c       ****                                                 if (val == CMD_AUTONEG_DONE)
 772:xboot.c       ****                                                 {
 773:xboot.c       ****                                                         // If so, we're now attached, so light
 774:xboot.c       ****                                                         // the LED and update the I2C bus
 775:xboot.c       ****                                                         // controller accordingly
 776:xboot.c       ****                                                         
 777:xboot.c       ****                                                         // turn on attach LED
 778:xboot.c       ****                                                         #ifdef USE_ATTACH_LED
 779:xboot.c       ****                                                         #if ATTACH_LED_INV
 780:xboot.c       ****                                                         ATTACH_LED_PORT.OUTCLR = (1 << ATTACH_LED_P
 781:xboot.c       ****                                                         #else
 782:xboot.c       ****                                                         ATTACH_LED_PORT.OUTSET = (1 << ATTACH_LED_P
 783:xboot.c       ****                                                         #endif // ATTACH_LED_INV
 784:xboot.c       ****                                                         #endif // USE_ATTACH_LED
 785:xboot.c       ****                                                         
 786:xboot.c       ****                                                         // get new address
 787:xboot.c       ****                                                         #if I2C_AUTONEG_DIS_GC
 788:xboot.c       ****                                                         I2C_DEVICE.SLAVE.ADDR = get_char() << 1;
 789:xboot.c       ****                                                         #else
 790:xboot.c       ****                                                         I2C_DEVICE.SLAVE.ADDR = (get_char() << 1) |
 791:xboot.c       ****                                                         #endif // I2C_AUTONEG_DIS_GC
 792:xboot.c       ****                                                         
 793:xboot.c       ****                                                         #if I2C_AUTONEG_DIS_PROMISC
 794:xboot.c       ****                                                         // turn off promiscuous mode
 795:xboot.c       ****                                                         I2C_DEVICE.SLAVE.CTRLA = TWI_SLAVE_ENABLE_b
 796:xboot.c       ****                                                         #endif // I2C_AUTONEG_DIS_PROMISC
 797:xboot.c       ****                                                         
 798:xboot.c       ****                                                         // we're done here
 799:xboot.c       ****                                                         goto autoneg_done;
 800:xboot.c       ****                                                 }
 801:xboot.c       ****                                                 // Check for sync command
 802:xboot.c       ****                                                 else if (val == CMD_SYNC)
 803:xboot.c       ****                                                 {
 804:xboot.c       ****                                                         // break out to main bootloader on sync
 805:xboot.c       ****                                                         goto autoneg_done;
 806:xboot.c       ****                                                 }
 807:xboot.c       ****                                         }
 808:xboot.c       ****                                 }
 809:xboot.c       ****                                 // Already wrote normal bit, so write the inverted one
 810:xboot.c       ****                                 ow_slave_write_bit(~k & 1); // write inverted bit
 811:xboot.c       ****                                 // Now read master's guess
 812:xboot.c       ****                                 i = ow_slave_read_bit();
 813:xboot.c       ****                                 // Does the guess agree with the current bit?
 814:xboot.c       ****                                 if ((k & 1 && i) || (~k & 1 && !i))
 815:xboot.c       ****                                 {
 816:xboot.c       ****                                         // look at next bit
 817:xboot.c       ****                                         devid_bit++;
 818:xboot.c       ****                                         k >>= 1;
 819:xboot.c       ****                                         
 820:xboot.c       ****                                         // time for next byte?
 821:xboot.c       ****                                         if (!(devid_bit & 7))
 822:xboot.c       ****                                         {
 823:xboot.c       ****                                                 // Out of bits?
 824:xboot.c       ****                                                 if (devid_bit > (0x15 << 3))
 825:xboot.c       ****                                                 {
 826:xboot.c       ****                                                         // Can't break here (need to wait
 827:xboot.c       ****                                                         // to see if the master sends along
 828:xboot.c       ****                                                         // an address) so wrap around instead
 829:xboot.c       ****                                                         devid_bit = 0x08 << 3;
 830:xboot.c       ****                                                 }
 831:xboot.c       ****                                                 // there are some holes in the signature row,
 832:xboot.c       ****                                                 // so skip over them
 833:xboot.c       ****                                                 if (devid_bit == (0x0E << 3))
 834:xboot.c       ****                                                         devid_bit += 0x02 << 3;
 835:xboot.c       ****                                                 if (devid_bit == (0x11 << 3))
 836:xboot.c       ****                                                         devid_bit += 0x01 << 3;
 837:xboot.c       ****                                                 // Read next byte
 838:xboot.c       ****                                                 k = SP_ReadCalibrationByte(devid_bit >> 3);
 839:xboot.c       ****                                         }
 840:xboot.c       ****                                 }
 841:xboot.c       ****                                 else
 842:xboot.c       ****                                 {
 843:xboot.c       ****                                         // No match, we're done here
 844:xboot.c       ****                                         break;
 845:xboot.c       ****                                 }
 846:xboot.c       ****                         }
 847:xboot.c       ****                         
 848:xboot.c       **** autoneg_done:
 849:xboot.c       ****                         // dummy to avoid error message
 850:xboot.c       ****                         // this actually produces code 4 bytes smaller than either
 851:xboot.c       ****                         // an asm nop, a continue, or a bare semicolon
 852:xboot.c       ****                         i = 0;
 853:xboot.c       ****                         
 854:xboot.c       ****                         #endif // __AVR_XMEGA__
 855:xboot.c       ****                 }
 856:xboot.c       ****                 // out-of-order autonegotiate address message
 857:xboot.c       ****                 else if (val == CMD_AUTONEG_DONE)
 858:xboot.c       ****                 {
 859:xboot.c       ****                         // ignore it
 860:xboot.c       ****                         // (blocking to send a ? will cause trouble)
 861:xboot.c       ****                 }
 862:xboot.c       ****                 #endif // USE_I2C_ADDRESS_NEGOTIATION
 863:xboot.c       ****                 #endif // USE_I2C
 864:xboot.c       ****                 // ESC (0x1b) to sync
 865:xboot.c       ****                 // otherwise, error
 866:xboot.c       ****                 else if (val != CMD_SYNC)
 867:xboot.c       ****                 {
 868:xboot.c       ****                         send_char(REPLY_ERROR);
 869:xboot.c       ****                 }
 870:xboot.c       ****                 
 871:xboot.c       ****                 // Wait for any lingering SPM instructions to finish
 872:xboot.c       ****                 Flash_WaitForSPM();
 873:xboot.c       ****                 
 874:xboot.c       ****                 // End of bootloader main loop
 875:xboot.c       ****         }
 876:xboot.c       ****         
 877:xboot.c       ****         #ifdef NEED_INTERRUPTS
 878:xboot.c       ****         // Disable interrupts
 879:xboot.c       ****         cli();
 880:xboot.c       ****         #endif // NEED_INTERRUPTS
 881:xboot.c       ****         
 882:xboot.c       ****         // Bootloader exit section
 883:xboot.c       ****         // Code here runs after the bootloader has exited,
 884:xboot.c       ****         // but before the application code has started
 885:xboot.c       ****         // --------------------------------------------------
 886:xboot.c       ****         
 887:xboot.c       ****         #ifdef ENABLE_API
 888:xboot.c       ****         #ifdef ENABLE_API_FIRMWARE_UPDATE
 889:xboot.c       ****         // Update firmware if needed
 890:xboot.c       ****         install_firmware();
 891:xboot.c       ****         #endif // ENABLE_API_FIRMWARE_UPDATE
 892:xboot.c       ****         #endif // ENABLE_API
 893:xboot.c       ****         
 894:xboot.c       ****         #ifdef USE_FIFO
 895:xboot.c       ****         // Shut down FIFO
 896:xboot.c       ****         fifo_deinit();
 897:xboot.c       ****         #endif // USE_FIFO
 898:xboot.c       ****         
 899:xboot.c       ****         #ifdef USE_I2C
 900:xboot.c       ****         // Shut down I2C interface
 901:xboot.c       ****         i2c_deinit();
 902:xboot.c       ****         #endif // USE_I2C
 903:xboot.c       ****         
 904:xboot.c       ****         #ifdef USE_UART
 905:xboot.c       ****         // Shut down UART
 906:xboot.c       ****         uart_deinit();
 907:xboot.c       ****         
 908:xboot.c       ****         // Disable RX pin pull-up
 909:xboot.c       **** #ifdef __AVR_XMEGA__
 910:xboot.c       ****         #ifdef UART_RX_PUEN
 911:xboot.c       ****         // Disable RX pin pullup
 912:xboot.c       ****         UART_RX_PIN_CTRL = 0;
 913:xboot.c       ****         #endif // UART_RX_PUEN
 914:xboot.c       **** #else // __AVR_XMEGA__
 915:xboot.c       ****         #ifdef UART_RX_PUEN
 916:xboot.c       ****         // Disable RX pin pullup
 917:xboot.c       ****         UART_PORT &= ~(1 << UART_RX_PIN);
 918:xboot.c       ****         #endif // UART_RX_PUEN
 919:xboot.c       **** #endif // __AVR_XMEGA__
 920:xboot.c       ****         
 921:xboot.c       ****         // Shut down UART EN pin
 922:xboot.c       ****         #ifdef USE_UART_EN_PIN
 923:xboot.c       **** #ifdef __AVR_XMEGA__
 924:xboot.c       ****         UART_EN_PORT.DIRCLR = (1 << UART_EN_PIN);
 925:xboot.c       ****         UART_EN_PORT.OUTCLR = (1 << UART_EN_PIN);
 926:xboot.c       **** #else // __AVR_XMEGA__
 927:xboot.c       ****         UART_EN_PORT_DDR &= ~(1 << UART_EN_PIN);
 928:xboot.c       ****         UART_EN_PORT &= ~(1 << UART_EN_PIN);
 929:xboot.c       **** #endif // __AVR_XMEGA__
 930:xboot.c       ****         #endif // USE_UART_EN_PIN
 931:xboot.c       ****         #endif // USE_UART
 932:xboot.c       ****         
 933:xboot.c       **** #ifdef __AVR_XMEGA__
 934:xboot.c       ****         #ifdef LOCK_SPM_ON_EXIT
 935:xboot.c       ****         // Lock SPM writes
 936:xboot.c       ****         SP_LockSPM();
 937:xboot.c       ****         #endif // LOCK_SPM_ON_EXIT
 938:xboot.c       **** #endif // __AVR_XMEGA__
 939:xboot.c       ****         
 940:xboot.c       ****         // Disable bootloader entry pin
 941:xboot.c       **** #ifdef __AVR_XMEGA__
 942:xboot.c       ****         #ifdef USE_ENTER_PIN
 943:xboot.c       ****         #if ENTER_PIN_PUEN
 944:xboot.c       ****         // Disable bootloader entry pin pullup
 945:xboot.c       ****         ENTER_PIN_CTRL = 0;
 946:xboot.c       ****         #endif // ENTER_PIN_PUEN
 947:xboot.c       ****         #endif // USE_ENTER_PIN
 948:xboot.c       **** #else // __AVR_XMEGA__
 949:xboot.c       ****         #ifdef USE_ENTER_PIN
 950:xboot.c       ****         #if ENTER_PIN_PUEN
 951:xboot.c       ****         // Disable bootloader entry pin pullup
 952:xboot.c       ****         ENTER_PORT &= ~(1 << ENTER_PIN);
 953:xboot.c       ****         #endif // ENTER_PIN_PUEN
 954:xboot.c       ****         #endif // USE_ENTER_PIN
 955:xboot.c       **** #endif // __AVR_XMEGA__
 956:xboot.c       ****         
 957:xboot.c       ****         // LED
 958:xboot.c       **** #ifdef __AVR_XMEGA__
 959:xboot.c       ****         #ifdef USE_LED
 960:xboot.c       ****         // Turn off LED on exit
 961:xboot.c       ****         LED_PORT.DIRCLR = (1 << LED_PIN);
 962:xboot.c       ****         LED_PORT.OUTCLR = (1 << LED_PIN);
 963:xboot.c       ****         #endif // USE_LED
 964:xboot.c       **** #else // __AVR_XMEGA__
 965:xboot.c       ****         #ifdef USE_LED
 966:xboot.c       ****         // Turn off LED on exit
 967:xboot.c       ****         LED_PORT_DDR &= ~(1 << LED_PIN);
 968:xboot.c       ****         LED_PORT &= ~(1 << LED_PIN);
 969:xboot.c       ****         #endif // USE_LED
 970:xboot.c       **** #endif //__AVR_XMEGA__
 971:xboot.c       ****         
 972:xboot.c       ****         // Attach LED
 973:xboot.c       **** #ifdef __AVR_XMEGA__
 974:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
 975:xboot.c       ****         #ifdef USE_ATTACH_LED
 976:xboot.c       ****         // Disable ATTACH_LED
 977:xboot.c       ****         ATTACH_LED_PORT.DIRCLR = (1 << ATTACH_LED_PIN);
 978:xboot.c       ****         ATTACH_LED_PORT.OUTCLR = (1 << ATTACH_LED_PIN);
 979:xboot.c       ****         #endif // USE_ATTACH_LED
 980:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
 981:xboot.c       **** #else // __AVR_XMEGA__
 982:xboot.c       ****         #ifdef USE_I2C_ADDRESS_NEGOTIATION
 983:xboot.c       ****         #ifdef USE_ATTACH_LED
 984:xboot.c       ****         // Disable ATTACH_LED
 985:xboot.c       ****         ATTACH_LED_PORT_DDR &= ~(1 << ATTACH_LED_PIN);
 986:xboot.c       ****         ATTACH_LED_PORT &= ~(1 << ATTACH_LED_PIN);
 987:xboot.c       ****         #endif // USE_ATTACH_LED
 988:xboot.c       ****         #endif // USE_I2C_ADDRESS_NEGOTIATION
 989:xboot.c       **** #endif // __AVR_XMEGA__
 990:xboot.c       ****         
 991:xboot.c       **** #ifdef __AVR_XMEGA__
 992:xboot.c       ****         #ifdef NEED_INTERRUPTS
 993:xboot.c       ****         // remap interrupts back to application section
 994:xboot.c       ****         CCP = CCP_IOREG_gc;
 995:xboot.c       ****         PMIC.CTRL = 0;
 996:xboot.c       ****         #endif // NEED_INTERRUPTS
 997:xboot.c       **** #endif // __AVR_XMEGA__
 998:xboot.c       ****         
 999:xboot.c       ****         #ifdef USE_WATCHDOG
1000:xboot.c       ****         WDT_Disable();
1001:xboot.c       ****         #endif // USE_WATCHDOG
1002:xboot.c       ****         
1003:xboot.c       ****         // --------------------------------------------------
1004:xboot.c       ****         // End bootloader exit section
1005:xboot.c       ****         
1006:xboot.c       ****         // Jump into main code
1007:xboot.c       ****         asm("jmp 0");
1008:xboot.c       ****         
1009:xboot.c       ****         #ifdef __builtin_unreachable
1010:xboot.c       ****         // Size optimization as the asm jmp will not return
1011:xboot.c       ****         // However, it seems it is not available on older versions of gcc
1012:xboot.c       ****         __builtin_unreachable();
1013:xboot.c       ****         #endif
1014:xboot.c       **** }
1015:xboot.c       **** 
1016:xboot.c       **** #ifdef USE_I2C_ADDRESS_NEGOTIATION
1017:xboot.c       **** 
1018:xboot.c       **** #ifdef __AVR_XMEGA__
1019:xboot.c       **** #define ow_assert()             I2C_AUTONEG_PORT.DIRSET = (1 << I2C_AUTONEG_PIN)
1020:xboot.c       **** #define ow_deassert()           I2C_AUTONEG_PORT.DIRCLR = (1 << I2C_AUTONEG_PIN)
1021:xboot.c       **** #define ow_read()               (I2C_AUTONEG_PORT.IN & (1 << I2C_AUTONEG_PIN))
1022:xboot.c       **** #define ow_is_asserted()        (!ow_read())
1023:xboot.c       **** #else
1024:xboot.c       **** #define ow_assert()             I2C_AUTONEG_PORT_DDR |= (1 << 0)
1025:xboot.c       **** #define ow_deassert()           I2C_AUTONEG_PORT_DDR &= ~(1 << 0)
1026:xboot.c       **** #define ow_read()               (I2C_AUTONEG_PORT_PIN & (1 << 0))
1027:xboot.c       **** #define ow_is_asserted()        (!ow_read())
1028:xboot.c       **** #endif // __AVR_XMEGA__
1029:xboot.c       **** 
1030:xboot.c       **** unsigned char __attribute__ ((noinline)) ow_slave_read_bit(void)
1031:xboot.c       **** {
1032:xboot.c       ****         unsigned char ret;
1033:xboot.c       ****         ow_slave_wait_bit();
1034:xboot.c       ****         _delay_us(12);
1035:xboot.c       ****         ret = ow_read();
1036:xboot.c       ****         _delay_us(8);
1037:xboot.c       ****         return ret;
1038:xboot.c       **** }
1039:xboot.c       **** 
1040:xboot.c       **** void __attribute__ ((noinline)) ow_slave_write_bit(unsigned char b)
1041:xboot.c       **** {
1042:xboot.c       ****         ow_slave_wait_bit();
1043:xboot.c       ****         if (!b)
1044:xboot.c       ****         {
1045:xboot.c       ****                 ow_assert();
1046:xboot.c       ****         }
1047:xboot.c       ****         _delay_us(20);
1048:xboot.c       ****         ow_deassert();
1049:xboot.c       **** }
1050:xboot.c       **** 
1051:xboot.c       **** void ow_slave_wait_bit(void)
1052:xboot.c       **** {
1053:xboot.c       ****         while (ow_read()) { };
1054:xboot.c       **** }
1055:xboot.c       **** 
1056:xboot.c       **** #endif // USE_I2C_ADDRESS_NEGOTIATION
1057:xboot.c       **** 
1058:xboot.c       **** #ifdef USE_INTERRUPTS
1059:xboot.c       **** unsigned char __attribute__ ((noinline)) get_char(void)
1060:xboot.c       **** {
1061:xboot.c       ****         unsigned char ret;
1062:xboot.c       ****         
1063:xboot.c       ****         while (rx_char_cnt == 0) { };
1064:xboot.c       ****         
1065:xboot.c       ****         cli();
1066:xboot.c       ****         
1067:xboot.c       ****         ret = rx_buff0;
1068:xboot.c       ****         rx_buff0 = rx_buff1;
1069:xboot.c       ****         rx_char_cnt--;
1070:xboot.c       ****         
1071:xboot.c       ****         sei();
1072:xboot.c       ****         
1073:xboot.c       ****         return ret;
1074:xboot.c       **** }
1075:xboot.c       **** 
1076:xboot.c       **** void __attribute__ ((noinline)) send_char(unsigned char c)
1077:xboot.c       **** {
1078:xboot.c       ****         while (1)
1079:xboot.c       ****         {
1080:xboot.c       ****                 cli();
1081:xboot.c       ****                 
1082:xboot.c       ****                 if (tx_char_cnt == 0)
1083:xboot.c       ****                 {
1084:xboot.c       ****                         tx_buff0 = c;
1085:xboot.c       ****                         tx_char_cnt = 1;
1086:xboot.c       ****                         
1087:xboot.c       ****                         #ifdef USE_UART
1088:xboot.c       ****                         if (comm_mode == MODE_UART)
1089:xboot.c       ****                         {
1090:xboot.c       ****                                 uart_send_char(c);
1091:xboot.c       ****                         }
1092:xboot.c       ****                         #endif // USE_UART
1093:xboot.c       ****                         
1094:xboot.c       ****                         #ifdef USE_I2C
1095:xboot.c       ****                         #error I2C interrupts are not yet implemented
1096:xboot.c       ****                         #endif
1097:xboot.c       ****                         
1098:xboot.c       ****                         #ifdef USE_FIFO
1099:xboot.c       ****                         if (comm_mode == MODE_FIFO)
1100:xboot.c       ****                         {
1101:xboot.c       ****                                 fifo_send_char(c);
1102:xboot.c       ****                         }
1103:xboot.c       ****                         #endif // USE_FIFO
1104:xboot.c       ****                         
1105:xboot.c       ****                         sei();
1106:xboot.c       ****                         return;
1107:xboot.c       ****                 }
1108:xboot.c       ****                 
1109:xboot.c       ****                 sei();
1110:xboot.c       ****         }
1111:xboot.c       **** }
1112:xboot.c       **** 
1113:xboot.c       **** #else
1114:xboot.c       **** 
1115:xboot.c       **** unsigned char __attribute__ ((noinline)) get_char(void)
1116:xboot.c       **** {
 193               	1116,.LM12-.LFBB3
 194               	.LM12:
 195               	.LFBB3:
 196               	/* prologue: function */
 197               	/* frame size = 0 */
1117:xboot.c       ****      
1118:xboot.c       ****         while (1)
1119:xboot.c       ****         {
1120:xboot.c       ****                 #ifdef USE_UART
1121:xboot.c       ****                 // Get next character
1122:xboot.c       ****                 if (comm_mode == MODE_UNDEF || comm_mode == MODE_UART)
1123:xboot.c       ****                 {
 198               	bn	68,0,1123,.LM13-.LFBB3
 199               	.LM13:
 200 0000 9091 0000 		lds r25,comm_mode
 201               	.L11:
 202 0004 9230      		cpi r25,lo8(2)
 203 0006 00F4      		brsh .L10
1124:xboot.c       ****                  if (uart_char_received())
1125:xboot.c       ****                         {
 204               	n	68,0,1125,.LM14-.LFBB3
 205               	.LM14:
 206 0008 8091 C000 		lds r24,192
 207 000c 87FF      		sbrs r24,7
 208 000e 00C0      		rjmp .L11
1126:xboot.c       ****                               comm_mode = MODE_UART;
1127:xboot.c       ****                                 return uart_cur_char();
 209               	bn	68,0,1127,.LM15-.LFBB3
 210               	.LM15:
 211 0010 81E0      		ldi r24,lo8(1)
 212 0012 8093 0000 		sts comm_mode,r24
1128:xboot.c       ****                       }
 213               	abn	68,0,1128,.LM16-.LFBB3
 214               	.LM16:
 215 0016 8091 C600 		lds r24,198
 216               	/* epilogue start */
1129:xboot.c       ****                }
1130:xboot.c       ****                 #endif // USE_UART
1131:xboot.c       ****                 
1132:xboot.c       ****                 #ifdef USE_I2C
1133:xboot.c       ****                 // Get next character
1134:xboot.c       ****                 if (comm_mode == MODE_UNDEF || comm_mode == MODE_I2C)
1135:xboot.c       ****                 {
1136:xboot.c       **** #ifdef __AVR_XMEGA__
1137:xboot.c       ****                         if (i2c_address_match())
1138:xboot.c       ****                         {
1139:xboot.c       ****                                 // Address match, send ACK
1140:xboot.c       ****                                 i2c_send_ack();
1141:xboot.c       ****                                 comm_mode = MODE_I2C;
1142:xboot.c       ****                                 first_byte = 1;
1143:xboot.c       ****                         }
1144:xboot.c       ****                         if (i2c_char_received())
1145:xboot.c       ****                         {
1146:xboot.c       ****                                 // Data has arrived
1147:xboot.c       ****                                 ret = i2c_cur_char();
1148:xboot.c       ****                                 i2c_send_ack();
1149:xboot.c       ****                                 return ret;
1150:xboot.c       ****                         }
1151:xboot.c       ****                         if (i2c_ready_data())
1152:xboot.c       ****                         {
1153:xboot.c       ****                                 if (!first_byte && i2c_got_ack())
1154:xboot.c       ****                                 {
1155:xboot.c       ****                                         i2c_end_transmission(); // end transaction
1156:xboot.c       ****                                 }
1157:xboot.c       ****                                 else
1158:xboot.c       ****                                 {
1159:xboot.c       ****                                         first_byte = 0;
1160:xboot.c       ****                                         // Wants data, but there is no data to send...
1161:xboot.c       ****                                         // also include NAK
1162:xboot.c       ****                                         i2c_send_char(REPLY_ERROR);
1163:xboot.c       ****                                         i2c_send_nak();
1164:xboot.c       ****                                 }
1165:xboot.c       ****                         }
1166:xboot.c       **** #else // __AVR_XMEGA__
1167:xboot.c       ****                         #error Not implemented!
1168:xboot.c       **** #endif // __AVR_XMEGA__
1169:xboot.c       ****                 }
1170:xboot.c       ****                 #endif // USE_I2C
1171:xboot.c       **** 
1172:xboot.c       ****                 #ifdef USE_FIFO
1173:xboot.c       ****                 // Get next character
1174:xboot.c       ****                 if (comm_mode == MODE_UNDEF || comm_mode == MODE_FIFO)
1175:xboot.c       ****                 {
1176:xboot.c       ****                         if (fifo_char_received())
1177:xboot.c       ****                         {
1178:xboot.c       ****                                 comm_mode = MODE_FIFO;
1179:xboot.c       ****                                 return fifo_cur_char();
1180:xboot.c       ****                         }
1181:xboot.c       ****                 }
1182:xboot.c       ****                 #endif // USE_FIFO
1183:xboot.c       ****                 
1184:xboot.c       ****         }
1185:xboot.c       ****         
1186:xboot.c       ****         return ret;
1187:xboot.c       **** }
1188:xboot.c       **** 
 217               	abn	68,0,1188,.LM17-.LFBB3
 218               	.LM17:
 219 001a 0895      		ret
 220               	.L10:
 221               	.L14:
 222 001c 00C0      		rjmp .L14
 224               	.Lscope3:
 225               		.section	.text.send_char,"ax",@progbits
 228               	.global	send_char
 230               	send_char:
1189:xboot.c       **** 
1190:xboot.c       ****         #ifdef USE_I2C
1191:xboot.c       ****         unsigned char tmp;
 231               	191,.LM18-.LFBB4
 232               	.LM18:
 233               	.LFBB4:
 234               	/* prologue: function */
 235               	/* frame size = 0 */
 236 0000 982F      		mov r25,r24
1192:xboot.c       ****       #endif
1193:xboot.c       ****         
1194:xboot.c       ****         #ifdef USE_UART
1195:xboot.c       ****         // Send character
1196:xboot.c       ****         if (comm_mode == MODE_UNDEF || comm_mode == MODE_UART)
1197:xboot.c       ****         {
1198:xboot.c       **** #ifdef __AVR_XMEGA__
 237               	n	68,0,1198,.LM19-.LFBB4
 238               	.LM19:
 239 0002 8091 0000 		lds r24,comm_mode
 240 0006 8230      		cpi r24,lo8(2)
 241 0008 00F4      		brsh .L18
1199:xboot.c       ****          #ifdef USE_UART_EN_PIN
1200:xboot.c       ****                 #if UART_EN_INV
1201:xboot.c       ****                 UART_EN_PORT.OUTCLR = (1 << UART_EN_PIN);
1202:xboot.c       ****                 #else // UART_PIN_INV
1203:xboot.c       ****                 UART_EN_PORT.OUTSET = (1 << UART_EN_PIN);
1204:xboot.c       ****                 #endif // UART_PIN_INV
1205:xboot.c       ****                 #endif // USE_UART_EN_PIN
1206:xboot.c       **** #else // __AVR_XMEGA__
1207:xboot.c       ****                 #ifdef USE_UART_EN_PIN
1208:xboot.c       ****                 #if UART_EN_INV
1209:xboot.c       ****                 UART_EN_PORT &= ~(1 << UART_EN_PIN);
1210:xboot.c       ****                 #else // UART_PIN_INV
1211:xboot.c       ****                 UART_EN_PORT |= (1 << UART_EN_PIN);
1212:xboot.c       ****                 #endif // UART_PIN_INV
1213:xboot.c       ****                 #endif // USE_UART_EN_PIN
 242               	bn	68,0,1213,.LM20-.LFBB4
 243               	.LM20:
 244 000a 5A9A      		sbi 43-32,2
1214:xboot.c       **** _XMEGA__
1215:xboot.c       ****                 uart_send_char_blocking(c);
1216:xboot.c       **** #ifdef __AVR_XMEGA__
1217:xboot.c       ****                 #ifdef USE_UART_EN_PIN
 245               	tabn	68,0,1217,.LM21-.LFBB4
 246               	.LM21:
 247 000c 9093 C600 		sts 198,r25
 248               	.L17:
 249 0010 8091 C000 		lds r24,192
 250 0014 86FF      		sbrs r24,6
 251 0016 00C0      		rjmp .L17
 252 0018 8091 C000 		lds r24,192
 253 001c 8064      		ori r24,lo8(64)
 254 001e 8093 C000 		sts 192,r24
1218:xboot.c       ****             #if UART_EN_INV
1219:xboot.c       ****                 UART_EN_PORT.OUTSET = (1 << UART_EN_PIN);
1220:xboot.c       ****                 #else // UART_PIN_INV
1221:xboot.c       ****                 UART_EN_PORT.OUTCLR = (1 << UART_EN_PIN);
1222:xboot.c       ****                 #endif // UART_PIN_INV
1223:xboot.c       ****                 #endif // USE_UART_EN_PIN
1224:xboot.c       **** #else // __AVR_XMEGA__
1225:xboot.c       ****                 #ifdef USE_UART_EN_PIN
1226:xboot.c       ****                 #if UART_EN_INV
1227:xboot.c       ****                 UART_EN_PORT |= (1 << UART_EN_PIN);
1228:xboot.c       ****                 #else // UART_PIN_INV
1229:xboot.c       ****                 UART_EN_PORT &= ~(1 << UART_EN_PIN);
1230:xboot.c       ****                 #endif // UART_PIN_INV
1231:xboot.c       ****                 #endif // USE_UART_EN_PIN
 255               	,0,1231,.LM22-.LFBB4
 256               	.LM22:
 257 0022 5A98      		cbi 43-32,2
 258               	.L18:
 259 0024 0895      		ret
 261               	.Lscope4:
 262               		.section	.text.get_2bytes,"ax",@progbits
 264               	.global	get_2bytes
 266               	get_2bytes:
1232:xboot.c       **** R_XMEGA__
1233:xboot.c       ****                 
1234:xboot.c       ****         }
1235:xboot.c       ****         #endif // USE_UART
1236:xboot.c       ****         
1237:xboot.c       ****         #ifdef USE_I2C
1238:xboot.c       ****         // Send character
1239:xboot.c       ****         if (comm_mode == MODE_UNDEF || comm_mode == MODE_I2C)
1240:xboot.c       ****         {
1241:xboot.c       ****                 while (1)
1242:xboot.c       ****                 {
1243:xboot.c       **** #ifdef __AVR_XMEGA__
1244:xboot.c       ****                         if (i2c_address_match())
1245:xboot.c       ****                         {
1246:xboot.c       ****                                 // Address match, send ACK
1247:xboot.c       ****                                 i2c_send_ack();
1248:xboot.c       ****                                 first_byte = 1;
1249:xboot.c       ****                         }
1250:xboot.c       ****                         if (i2c_char_received())
1251:xboot.c       ****                         {
1252:xboot.c       ****                                 // Data has arrived, ignore it
1253:xboot.c       ****                                 tmp = i2c_cur_char();
1254:xboot.c       ****                                 i2c_send_ack();
1255:xboot.c       ****                         }
1256:xboot.c       ****                         if (i2c_ready_data())
1257:xboot.c       ****                         {
1258:xboot.c       ****                                 if (!first_byte && i2c_got_ack())
1259:xboot.c       ****                                 {
1260:xboot.c       ****                                         i2c_end_transmission(); // end transaction
1261:xboot.c       ****                                 }
1262:xboot.c       ****                                 else
1263:xboot.c       ****                                 {
1264:xboot.c       ****                                         first_byte = 0;
1265:xboot.c       ****                                         // Send data along
1266:xboot.c       ****                                         i2c_send_char(c);
1267:xboot.c       ****                                         i2c_send_ack();
1268:xboot.c       ****                                 }
1269:xboot.c       ****                                 return;
1270:xboot.c       ****                         }
1271:xboot.c       **** #else // __AVR_XMEGA__
1272:xboot.c       ****                         #error Not implemented!
1273:xboot.c       **** #endif // __AVR_XMEGA__
1274:xboot.c       ****                 }
1275:xboot.c       ****         }
1276:xboot.c       ****         #endif // USE_I2C
1277:xboot.c       **** 
1278:xboot.c       ****         #ifdef USE_FIFO
1279:xboot.c       ****         // Send character
1280:xboot.c       ****         if (comm_mode == MODE_UNDEF || comm_mode == MODE_FIFO)
1281:xboot.c       ****         {
1282:xboot.c       ****                 fifo_send_char_blocking(c);
1283:xboot.c       ****                 
1284:xboot.c       ****         }
1285:xboot.c       ****         #endif // USE_FIFO
1286:xboot.c       ****         
1287:xboot.c       **** }
1288:xboot.c       **** 
1289:xboot.c       **** #endif // USE_INTERRUPTS
1290:xboot.c       **** 
1291:xboot.c       **** unsigned int __attribute__ ((noinline)) get_2bytes()
1292:xboot.c       **** {
1293:xboot.c       ****         // return (get_char() << 8) | get_char();
1294:xboot.c       ****         unsigned int result;
 267               	,1294,.LM23-.LFBB5
 268               	.LM23:
 269               	.LFBB5:
 270               	/* prologue: function */
 271               	/* frame size = 0 */
1295:xboot.c       **** "
1296:xboot.c       ****                 "mov  %B0,r24"     "\n\t"
1297:xboot.c       ****                 "call get_char"    "\n\t"
 272               	bn	68,0,1297,.LM24-.LFBB5
 273               	.LM24:
 274               	/* #APP */
 275               	 ;  1297 "xboot.c" 1
 276 0000 0E94 0000 		call get_char
 277 0004 382F      		mov  r19,r24
 278 0006 0E94 0000 		call get_char
 279 000a 282F      		mov  r18,r24
 280               		
 281               	 ;  0 "" 2
1298:xboot.c       ****              "mov  %A0,r24"     "\n\t"
1299:xboot.c       ****                 : "=r" (result)
1300:xboot.c       ****                 :
1301:xboot.c       ****         );
1302:xboot.c       ****         return result;
1303:xboot.c       **** }
1304:xboot.c       **** 
1305:xboot.c       **** void clear_buffer(void)
1306:xboot.c       **** {
 282               	,0,1306,.LM25-.LFBB5
 283               	.LM25:
 284               	/* #NOAPP */
 285 000c C901      		movw r24,r18
 286               	/* epilogue start */
 287 000e 0895      		ret
 292               	.Lscope5:
 293               		.section	.text.clear_buffer,"ax",@progbits
 295               	.global	clear_buffer
 297               	clear_buffer:
1307:xboot.c       **** nsigned char *ptr = buffer;
1308:xboot.c       ****         for (long i = 0; i < SPM_PAGESIZE; i++)
1309:xboot.c       ****         {
 298               	9,.LM26-.LFBB6
 299               	.LM26:
 300               	.LFBB6:
 301               	/* prologue: function */
 302               	/* frame size = 0 */
 304               	.LM27:
 305 0000 E0E0      		ldi r30,lo8(buffer)
 306 0002 F0E0      		ldi r31,hi8(buffer)
 307               	.LBB25:
1310:xboot.c       ****              *(ptr++) = 0xff;
1311:xboot.c       ****         }
1312:xboot.c       **** }
1313:xboot.c       **** 
 308               	,0,1313,.LM28-.LFBB6
 309               	.LM28:
 310 0004 8FEF      		ldi r24,lo8(-1)
 311               	.L23:
 312 0006 8193      		st Z+,r24
 314               	.LM29:
 315 0008 90E0      		ldi r25,hi8(buffer+128)
 316 000a E030      		cpi r30,lo8(buffer+128)
 317 000c F907      		cpc r31,r25
 318 000e 01F4      		brne .L23
 319               	/* epilogue start */
 320               	.LBE25:
1314:xboot.c       **** gned char BlockLoad(unsigned int size, unsigned char mem, ADDR_T *address)
1315:xboot.c       **** {
 321               	1315,.LM30-.LFBB6
 322               	.LM30:
 323 0010 0895      		ret
 328               	.Lscope6:
 329               		.section	.text.crc16_block,"ax",@progbits
 333               	.global	crc16_block
 335               	crc16_block:
1316:xboot.c       ****       ADDR_T tempaddress;
1317:xboot.c       ****         
1318:xboot.c       ****         #ifdef USE_WATCHDOG
1319:xboot.c       ****         WDT_Reset();
1320:xboot.c       ****         #endif // USE_WATCHDOG
1321:xboot.c       ****         
1322:xboot.c       ****         // fill up buffer
1323:xboot.c       ****         for (int i = 0; i < SPM_PAGESIZE; i++)
1324:xboot.c       ****         {
1325:xboot.c       ****                 char c = 0xff;
1326:xboot.c       ****                 
1327:xboot.c       ****                 if (i < size)
1328:xboot.c       ****                         c = get_char();
1329:xboot.c       ****                 
1330:xboot.c       ****                 buffer[i] = c;
1331:xboot.c       ****         }
1332:xboot.c       ****         
1333:xboot.c       ****         // EEPROM memory type.
1334:xboot.c       ****         if(mem == MEM_EEPROM)
1335:xboot.c       ****         {
1336:xboot.c       ****                 EEPROM_write_block(*address, buffer, size);
1337:xboot.c       ****                 (*address) += size;
1338:xboot.c       ****                 
1339:xboot.c       ****                 return REPLY_ACK; // Report programming OK
1340:xboot.c       ****         } 
1341:xboot.c       ****         
1342:xboot.c       ****         // Flash memory type
1343:xboot.c       **** #ifdef __AVR_XMEGA__
1344:xboot.c       ****         else if (mem == MEM_FLASH || mem == MEM_USERSIG)
1345:xboot.c       **** #else // __AVR_XMEGA__
1346:xboot.c       ****         else if (mem == MEM_FLASH)
1347:xboot.c       **** #endif // __AVR_XMEGA__
1348:xboot.c       ****         {
1349:xboot.c       ****                 // NOTE: For flash programming, 'address' is given in words.
1350:xboot.c       ****                 tempaddress = (*address) << 1;  // Store address in page.
1351:xboot.c       ****                 
1352:xboot.c       ****                 (*address) += size >> 1;
1353:xboot.c       ****                 
1354:xboot.c       **** #ifdef __AVR_XMEGA__
1355:xboot.c       ****                 
1356:xboot.c       ****                 if (mem == MEM_FLASH)
1357:xboot.c       ****                 {
1358:xboot.c       ****                         #ifdef ENABLE_FLASH_ERASE_WRITE
1359:xboot.c       ****                         Flash_ProgramPage(tempaddress, buffer, 1);
1360:xboot.c       ****                         #else
1361:xboot.c       ****                         Flash_ProgramPage(tempaddress, buffer, 0);
1362:xboot.c       ****                         #endif
1363:xboot.c       ****                 }
1364:xboot.c       ****                 else if (mem == MEM_USERSIG)
1365:xboot.c       ****                 {
1366:xboot.c       ****                         Flash_LoadFlashPage(buffer);
1367:xboot.c       ****                         Flash_EraseUserSignatureRow();
1368:xboot.c       ****                         Flash_WaitForSPM();
1369:xboot.c       ****                         Flash_WriteUserSignatureRow();
1370:xboot.c       ****                         Flash_WaitForSPM();
1371:xboot.c       ****                 }
1372:xboot.c       ****                 
1373:xboot.c       **** #else // __AVR_XMEGA__
1374:xboot.c       ****                 #ifdef ENABLE_FLASH_ERASE_WRITE
1375:xboot.c       ****                 Flash_ProgramPage(tempaddress, buffer, 1);
1376:xboot.c       ****                 #else
1377:xboot.c       ****                 Flash_ProgramPage(tempaddress, buffer, 0);
1378:xboot.c       ****                 #endif
1379:xboot.c       **** #endif // __AVR_XMEGA__
1380:xboot.c       ****                 
1381:xboot.c       ****                 return REPLY_ACK; // Report programming OK
1382:xboot.c       ****         }
1383:xboot.c       ****         
1384:xboot.c       ****         // Invalid memory type?
1385:xboot.c       ****         else
1386:xboot.c       ****         {
1387:xboot.c       ****                 return REPLY_ERROR;
1388:xboot.c       ****         }
1389:xboot.c       **** }
1390:xboot.c       **** 
1391:xboot.c       **** 
1392:xboot.c       **** 
1393:xboot.c       **** void BlockRead(unsigned int size, unsigned char mem, ADDR_T *address)
1394:xboot.c       **** {
1395:xboot.c       ****         int offset = 0;
1396:xboot.c       ****         int size2 = size;
1397:xboot.c       ****         
1398:xboot.c       ****         // EEPROM memory type.
1399:xboot.c       ****         
1400:xboot.c       ****         if (mem == MEM_EEPROM) // Read EEPROM
1401:xboot.c       ****         {
1402:xboot.c       ****                 EEPROM_read_block(*address, buffer, size);
1403:xboot.c       ****                 (*address) += size;
1404:xboot.c       ****         }
1405:xboot.c       ****         
1406:xboot.c       ****         // Flash memory type.
1407:xboot.c       **** #ifdef __AVR_XMEGA__
1408:xboot.c       ****         else if (mem == MEM_FLASH || mem == MEM_USERSIG || mem == MEM_PRODSIG)
1409:xboot.c       **** #else // __AVR_XMEGA__
1410:xboot.c       ****         else if (mem == MEM_FLASH)
1411:xboot.c       **** #endif // __AVR_XMEGA__
1412:xboot.c       ****         {
1413:xboot.c       ****                 (*address) <<= 1; // Convert address to bytes temporarily.
1414:xboot.c       ****                 
1415:xboot.c       ****                 do
1416:xboot.c       ****                 {
1417:xboot.c       **** #ifdef __AVR_XMEGA__
1418:xboot.c       ****                         if (mem == MEM_FLASH)
1419:xboot.c       ****                         {
1420:xboot.c       ****                                 buffer[offset++] = Flash_ReadByte(*address);
1421:xboot.c       ****                         }
1422:xboot.c       ****                         else if (mem == MEM_USERSIG)
1423:xboot.c       ****                         {
1424:xboot.c       ****                                 buffer[offset++] = SP_ReadUserSignatureByte(*address);
1425:xboot.c       ****                         }
1426:xboot.c       ****                         else if (mem == MEM_PRODSIG)
1427:xboot.c       ****                         {
1428:xboot.c       ****                                 buffer[offset++] = SP_ReadCalibrationByte(*address);
1429:xboot.c       ****                         }
1430:xboot.c       **** #else // __AVR_XMEGA__
1431:xboot.c       ****                         buffer[offset++] = Flash_ReadByte(*address);
1432:xboot.c       **** #endif // __AVR_XMEGA__
1433:xboot.c       ****                         
1434:xboot.c       ****                         Flash_WaitForSPM();
1435:xboot.c       ****                         
1436:xboot.c       ****                         (*address)++;    // Select next word in memory.
1437:xboot.c       ****                         size--;          // Subtract two bytes from number of bytes to read
1438:xboot.c       ****                 } while (size);         // Repeat until all block has been read
1439:xboot.c       ****                 
1440:xboot.c       ****                 (*address) >>= 1;       // Convert address back to Flash words again.
1441:xboot.c       ****         }
1442:xboot.c       ****         else
1443:xboot.c       ****         {
1444:xboot.c       ****                 // bad memory type
1445:xboot.c       ****                 return;
1446:xboot.c       ****         }
1447:xboot.c       ****         
1448:xboot.c       ****         // code protection
1449:xboot.c       ****         if (
1450:xboot.c       ****         #ifdef ENABLE_CODE_PROTECTION
1451:xboot.c       ****                 (protected && mem == MEM_FLASH) ||
1452:xboot.c       ****         #endif // ENABLE_CODE_PROTECTION
1453:xboot.c       ****         #ifdef ENABLE_EEPROM_PROTECTION
1454:xboot.c       ****                 (protected && mem == MEM_EEPROM) ||
1455:xboot.c       ****         #endif // ENABLE_EEPROM_PROTECTION
1456:xboot.c       ****         #ifdef ENABLE_BOOTLOADER_PROTECTION
1457:xboot.c       ****                 (*address >= (BOOT_SECTION_START >> 1) && mem == MEM_FLASH) ||
1458:xboot.c       ****         #endif // ENABLE_BOOTLOADER_PROTECTION
1459:xboot.c       ****                 0
1460:xboot.c       ****         )
1461:xboot.c       ****                 clear_buffer();
1462:xboot.c       ****         
1463:xboot.c       ****         // send bytes
1464:xboot.c       ****         for (int i = 0; i < size2; i++)
1465:xboot.c       ****         {
1466:xboot.c       ****                 send_char(buffer[i]);
1467:xboot.c       ****         }
1468:xboot.c       ****         
1469:xboot.c       **** }
1470:xboot.c       **** 
1471:xboot.c       **** uint16_t crc16_block(uint32_t start, uint32_t length)
1472:xboot.c       **** {
1473:xboot.c       ****         uint16_t crc = 0;
1474:xboot.c       ****         
1475:xboot.c       ****         int bc = SPM_PAGESIZE;
 336               	75,.LM31-.LFBB7
 337               	.LM31:
 338               	.LFBB7:
 339 0000 AF92      		push r10
 340 0002 BF92      		push r11
 341 0004 CF92      		push r12
 342 0006 DF92      		push r13
 343 0008 EF92      		push r14
 344 000a FF92      		push r15
 345 000c 0F93      		push r16
 346 000e 1F93      		push r17
 347 0010 CF93      		push r28
 348 0012 DF93      		push r29
 349               	/* prologue: function */
 350               	/* frame size = 0 */
 351 0014 5B01      		movw r10,r22
 352 0016 6C01      		movw r12,r24
 353 0018 7901      		movw r14,r18
 354 001a 8A01      		movw r16,r20
 356               	.LM32:
 357 001c C0E0      		ldi r28,lo8(0)
 358 001e D0E0      		ldi r29,hi8(0)
 359 0020 20E8      		ldi r18,lo8(128)
 360 0022 30E0      		ldi r19,hi8(128)
 361 0024 00C0      		rjmp .L27
 362               	.L29:
1476:xboot.c       **** {
1477:xboot.c       ****         uint16_t crc = 0;
1478:xboot.c       ****         
1479:xboot.c       ****         int bc = SPM_PAGESIZE;
1480:xboot.c       ****         
1481:xboot.c       ****         for ( ; length > 0; length--)
1482:xboot.c       ****         {
 363               	BB7
 364               	.LM33:
 365 0026 2038      		cpi r18,128
 366 0028 3105      		cpc r19,__zero_reg__
 367 002a 01F4      		brne .L28
1483:xboot.c       **** GESIZE;
1484:xboot.c       ****         
 368               	bn	68,0,1484,.LM34-.LFBB7
 369               	.LM34:
 370 002c 80E0      		ldi r24,lo8(buffer)
 371 002e 90E0      		ldi r25,hi8(buffer)
 372 0030 B601      		movw r22,r12
 373 0032 A501      		movw r20,r10
 374 0034 0E94 0000 		call Flash_ReadFlashPage
1485:xboot.c       **** uint16_t crc = 0;
 375               		68,0,1485,.LM35-.LFBB7
 376               	.LM35:
 377 0038 80E8      		ldi r24,lo8(128)
 378 003a 90E0      		ldi r25,hi8(128)
 379 003c A0E0      		ldi r26,hlo8(128)
 380 003e B0E0      		ldi r27,hhi8(128)
 381 0040 A80E      		add r10,r24
 382 0042 B91E      		adc r11,r25
 383 0044 CA1E      		adc r12,r26
 384 0046 DB1E      		adc r13,r27
 385 0048 20E0      		ldi r18,lo8(0)
 386 004a 30E0      		ldi r19,hi8(0)
 387               	.L28:
 388               	.LBB26:
 389               	.LBB27:
 391               	.Ltext3:
   1:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** /* Copyright (c) 2002, 2003, 2004  Marek Michalkiewicz
   2:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****    Copyright (c) 2005, 2007 Joerg Wunsch
   3:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****    All rights reserved.
   4:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
   5:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****    Redistribution and use in source and binary forms, with or without
   6:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****    modification, are permitted provided that the following conditions are met:
   7:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
   8:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****    * Redistributions of source code must retain the above copyright
   9:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer.
  10:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  11:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****    * Redistributions in binary form must reproduce the above copyright
  12:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****      notice, this list of conditions and the following disclaimer in
  13:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****      the documentation and/or other materials provided with the
  14:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****      distribution.
  15:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  16:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****    * Neither the name of the copyright holders nor the names of
  17:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****      contributors may be used to endorse or promote products derived
  18:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****      from this software without specific prior written permission.
  19:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  20:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  32:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** /* $Id: crc16.h,v 1.4 2007/01/23 15:32:48 joerg_wunsch Exp $ */
  33:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  34:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** #ifndef _UTIL_CRC16_H_
  35:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** #define _UTIL_CRC16_H_
  36:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  37:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** #include <stdint.h>
  38:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  39:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** /** \file */
  40:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** /** \defgroup util_crc <util/crc16.h>: CRC Computations
  41:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     \code#include <util/crc16.h>\endcode
  42:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  43:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     This header file provides a optimized inline functions for calculating
  44:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     cyclic redundancy checks (CRC) using common polynomials.
  45:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  46:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     \par References:
  47:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  48:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     \par
  49:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  50:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     See the Dallas Semiconductor app note 27 for 8051 assembler example and
  51:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     general CRC optimization suggestions. The table on the last page of the
  52:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     app note is the key to understanding these implementations.
  53:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  54:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     \par
  55:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  56:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     Jack Crenshaw's "Implementing CRCs" article in the January 1992 isue of \e
  57:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     Embedded \e Systems \e Programming. This may be difficult to find, but it
  58:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     explains CRC's in very clear and concise terms. Well worth the effort to
  59:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     obtain a copy.
  60:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  61:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     A typical application would look like:
  62:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  63:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     \code
  64:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     // Dallas iButton test vector.
  65:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };
  66:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  67:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     int
  68:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     checkcrc(void)
  69:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     {
  70:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	uint8_t crc = 0, i;
  71:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  72:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	for (i = 0; i < sizeof serno / sizeof serno[0]; i++)
  73:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	    crc = _crc_ibutton_update(crc, serno[i]);
  74:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  75:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	return crc; // must be 0
  76:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     }
  77:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     \endcode
  78:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** */
  79:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  80:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** /** \ingroup util_crc
  81:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     Optimized CRC-16 calculation.
  82:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  83:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     Polynomial: x^16 + x^15 + x^2 + 1 (0xa001)<br>
  84:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     Initial value: 0xffff
  85:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  86:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     This CRC is normally used in disk-drive controllers.
  87:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  88:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     The following is the equivalent functionality written in C.
  89:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  90:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     \code
  91:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     uint16_t
  92:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     crc16_update(uint16_t crc, uint8_t a)
  93:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     {
  94:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	int i;
  95:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
  96:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	crc ^= a;
  97:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	for (i = 0; i < 8; ++i)
  98:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	{
  99:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	    if (crc & 1)
 100:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 		crc = (crc >> 1) ^ 0xA001;
 101:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	    else
 102:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 		crc = (crc >> 1);
 103:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	}
 104:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
 105:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	return crc;
 106:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     }
 107:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
 108:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h ****     \endcode */
 109:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
 110:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** static __inline__ uint16_t
 111:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** _crc16_update(uint16_t __crc, uint8_t __data)
 112:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** {
 113:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	uint8_t __tmp;
 114:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	uint16_t __ret;
 115:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 
 116:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h **** 	__asm__ __volatile__ (
 392               	.LM36-.LFBB7
 393               	.LM36:
 394 004c F901      		movw r30,r18
 395 004e E050      		subi r30,lo8(-(buffer))
 396 0050 F040      		sbci r31,hi8(-(buffer))
 397 0052 8081      		ld r24,Z
 398               	/* #APP */
 399               	 ;  116 "d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h" 1
 400 0054 C827      		eor r28,r24
 401 0056 8C2F      		mov r24,r28
 402 0058 8295      		swap r24
 403 005a 8C27      		eor r24,r28
 404 005c 082E      		mov __tmp_reg__,r24
 405 005e 8695      		lsr r24
 406 0060 8695      		lsr r24
 407 0062 8025      		eor r24,__tmp_reg__
 408 0064 082E      		mov __tmp_reg__,r24
 409 0066 8695      		lsr r24
 410 0068 8025      		eor r24,__tmp_reg__
 411 006a 8770      		andi r24,0x07
 412 006c 0C2E      		mov __tmp_reg__,r28
 413 006e CD2F      		mov r28,r29
 414 0070 8695      		lsr r24
 415 0072 0794      		ror __tmp_reg__
 416 0074 8795      		ror r24
 417 0076 D02D      		mov r29,__tmp_reg__
 418 0078 C827      		eor r28,r24
 419 007a 0694      		lsr __tmp_reg__
 420 007c 8795      		ror r24
 421 007e D025      		eor r29,__tmp_reg__
 422 0080 C827      		eor r28,r24
 423               	 ;  0 "" 2
 424               	/* #NOAPP */
 425               	.LBE27:
 426               	.LBE26:
 428               	.Ltext4:
1486:xboot.c       **** 16_block(uint32_t start, uint32_t length)
1487:xboot.c       **** {
1488:xboot.c       ****         uint16_t crc = 0;
1489:xboot.c       ****         
1490:xboot.c       ****         int bc = SPM_PAGESIZE;
1491:xboot.c       ****         
 429               	
 430               		subi r18,lo8(-(1))
 431 0082 2F5F      		sbci r19,hi8(-(1))
 433               	.LM38:
 434               		sec
 435 0086 0894      		sbc r14,__zero_reg__
 436 0088 E108      		sbc r15,__zero_reg__
 437 008a F108      		sbc r16,__zero_reg__
 438 008c 0109      		sbc r17,__zero_reg__
 439 008e 1109      	.L27:
 440               		cp r14,__zero_reg__
 441 0090 E114      		cpc r15,__zero_reg__
 442 0092 F104      		cpc r16,__zero_reg__
 443 0094 0105      		cpc r17,__zero_reg__
 444 0096 1105      		breq .+2
 445 0098 01F0      		rjmp .L29
1492:xboot.c       **** uint16_t crc = 0;
1493:xboot.c       ****         
1494:xboot.c       ****         int bc = SPM_PAGESIZE;
1495:xboot.c       ****         
 447               	r28
 448               	/* epilogue start */
 449 009c CE01      		pop r29
 450               		pop r28
 451 009e DF91      		pop r17
 452 00a0 CF91      		pop r16
 453 00a2 1F91      		pop r15
 454 00a4 0F91      		pop r14
 455 00a6 FF90      		pop r13
 456 00a8 EF90      		pop r12
 457 00aa DF90      		pop r11
 458 00ac CF90      		pop r10
 459 00ae BF90      		ret
 465               	.Lscope7:
 466               		.section	.text.install_firmware,"ax",@progbits
 468               	.global	install_firmware
 470               	install_firmware:
 472               	.LM40:
1496:xboot.c       **** uint16_t crc = 0;
1497:xboot.c       ****         
1498:xboot.c       ****         int bc = SPM_PAGESIZE;
 473               	3
 474               		push r14
 475               		push r15
 476 0000 CF92      		push r16
 477 0002 DF92      		push r17
 478 0004 EF92      	/* prologue: function */
 479 0006 FF92      	/* frame size = 0 */
 481 000a 1F93      	.LM41:
 482               		ldi r24,lo8(buffer)
 483               		ldi r25,hi8(buffer)
1499:xboot.c       **** {
1500:xboot.c       ****         uint16_t crc = 0;
1501:xboot.c       ****         
1502:xboot.c       ****         int bc = SPM_PAGESIZE;
1503:xboot.c       ****         
 484               	8(28544)
 485               		ldi r21,hi8(28544)
 486 000c 80E0      		ldi r22,hlo8(28544)
 487 000e 90E0      		ldi r23,hhi8(28544)
 488 0010 40E8      		call Flash_ReadFlashPage
 490 0014 60E0      	.LM42:
 491 0016 70E0      		lds r24,buffer+122
 492 0018 0E94 0000 		cpi r24,lo8(88)
1504:xboot.c       **** uint16_t crc = 0;
1505:xboot.c       ****         
1506:xboot.c       ****         int bc = SPM_PAGESIZE;
 493               	
 494               		rjmp .L36
 495 001c 8091 0000 		lds r24,buffer+123
 496 0020 8835      		cpi r24,lo8(66)
 497 0022 01F0      		breq .+2
 498 0024 00C0      		rjmp .L36
 499 0026 8091 0000 		lds r24,buffer+124
 500 002a 8234      		cpi r24,lo8(73)
 501 002c 01F0      		breq .+2
 502 002e 00C0      		rjmp .L36
 503 0030 8091 0000 		lds r24,buffer+125
 504 0034 8934      		cpi r24,lo8(70)
 505 0036 01F0      		breq .+2
 506 0038 00C0      		rjmp .L36
 508 003e 8634      	.LM43:
 509 0040 01F0      		lds r15,buffer+126
 510 0042 00C0      		lds r16,buffer+127
1507:xboot.c       **** {
1508:xboot.c       ****         uint16_t crc = 0;
1509:xboot.c       ****         
 511               	,.LM44-.LFBB8
 512               	.LM44:
 513 0044 F090 0000 		ldi r22,lo8(14336)
 514 0048 0091 0000 		ldi r23,hi8(14336)
1510:xboot.c       **** int32_t start, uint32_t length)
1511:xboot.c       **** {
1512:xboot.c       ****         uint16_t crc = 0;
 515               	 r24,hlo8(14336)
 516               		ldi r25,hhi8(14336)
 517 004c 60E0      		ldi r18,lo8(14330)
 518 004e 78E3      		ldi r19,hi8(14330)
 519 0050 80E0      		ldi r20,hlo8(14330)
 520 0052 90E0      		ldi r21,hhi8(14330)
 521 0054 2AEF      		call crc16_block
 522 0056 37E3      	.LBB28:
 523 0058 40E0      	.LBB29:
 524 005a 50E0      	.LBB30:
 526               	.Ltext5:
 528               	.LM45:
 529               		ldi r18,lo8(-1)
 530               	/* #APP */
 531               	 ;  116 "d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h" 1
 532               		eor r24,r18
 533 0060 2FEF      		mov r19,r24
 534               		swap r19
 535               		eor r19,r24
 536 0062 8227      		mov __tmp_reg__,r19
 537 0064 382F      		lsr r19
 538 0066 3295      		lsr r19
 539 0068 3827      		eor r19,__tmp_reg__
 540 006a 032E      		mov __tmp_reg__,r19
 541 006c 3695      		lsr r19
 542 006e 3695      		eor r19,__tmp_reg__
 543 0070 3025      		andi r19,0x07
 544 0072 032E      		mov __tmp_reg__,r24
 545 0074 3695      		mov r24,r25
 546 0076 3025      		lsr r19
 547 0078 3770      		ror __tmp_reg__
 548 007a 082E      		ror r19
 549 007c 892F      		mov r25,__tmp_reg__
 550 007e 3695      		eor r24,r19
 551 0080 0794      		lsr __tmp_reg__
 552 0082 3795      		ror r19
 553 0084 902D      		eor r25,__tmp_reg__
 554 0086 8327      		eor r24,r19
 555 0088 0694      	 ;  0 "" 2
 556 008a 3795      	 ;  116 "d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h" 1
 557 008c 9025      		eor r24,r18
 558 008e 8327      		mov r19,r24
 559               		swap r19
 560               		eor r19,r24
 561 0090 8227      		mov __tmp_reg__,r19
 562 0092 382F      		lsr r19
 563 0094 3295      		lsr r19
 564 0096 3827      		eor r19,__tmp_reg__
 565 0098 032E      		mov __tmp_reg__,r19
 566 009a 3695      		lsr r19
 567 009c 3695      		eor r19,__tmp_reg__
 568 009e 3025      		andi r19,0x07
 569 00a0 032E      		mov __tmp_reg__,r24
 570 00a2 3695      		mov r24,r25
 571 00a4 3025      		lsr r19
 572 00a6 3770      		ror __tmp_reg__
 573 00a8 082E      		ror r19
 574 00aa 892F      		mov r25,__tmp_reg__
 575 00ac 3695      		eor r24,r19
 576 00ae 0794      		lsr __tmp_reg__
 577 00b0 3795      		ror r19
 578 00b2 902D      		eor r25,__tmp_reg__
 579 00b4 8327      		eor r24,r19
 580 00b6 0694      	 ;  0 "" 2
 581 00b8 3795      	 ;  116 "d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h" 1
 582 00ba 9025      		eor r24,r18
 583 00bc 8327      		mov r19,r24
 584               		swap r19
 585               		eor r19,r24
 586 00be 8227      		mov __tmp_reg__,r19
 587 00c0 382F      		lsr r19
 588 00c2 3295      		lsr r19
 589 00c4 3827      		eor r19,__tmp_reg__
 590 00c6 032E      		mov __tmp_reg__,r19
 591 00c8 3695      		lsr r19
 592 00ca 3695      		eor r19,__tmp_reg__
 593 00cc 3025      		andi r19,0x07
 594 00ce 032E      		mov __tmp_reg__,r24
 595 00d0 3695      		mov r24,r25
 596 00d2 3025      		lsr r19
 597 00d4 3770      		ror __tmp_reg__
 598 00d6 082E      		ror r19
 599 00d8 892F      		mov r25,__tmp_reg__
 600 00da 3695      		eor r24,r19
 601 00dc 0794      		lsr __tmp_reg__
 602 00de 3795      		ror r19
 603 00e0 902D      		eor r25,__tmp_reg__
 604 00e2 8327      		eor r24,r19
 605 00e4 0694      	 ;  0 "" 2
 606 00e6 3795      	 ;  116 "d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h" 1
 607 00e8 9025      		eor r24,r18
 608 00ea 8327      		mov r19,r24
 609               		swap r19
 610               		eor r19,r24
 611 00ec 8227      		mov __tmp_reg__,r19
 612 00ee 382F      		lsr r19
 613 00f0 3295      		lsr r19
 614 00f2 3827      		eor r19,__tmp_reg__
 615 00f4 032E      		mov __tmp_reg__,r19
 616 00f6 3695      		lsr r19
 617 00f8 3695      		eor r19,__tmp_reg__
 618 00fa 3025      		andi r19,0x07
 619 00fc 032E      		mov __tmp_reg__,r24
 620 00fe 3695      		mov r24,r25
 621 0100 3025      		lsr r19
 622 0102 3770      		ror __tmp_reg__
 623 0104 082E      		ror r19
 624 0106 892F      		mov r25,__tmp_reg__
 625 0108 3695      		eor r24,r19
 626 010a 0794      		lsr __tmp_reg__
 627 010c 3795      		ror r19
 628 010e 902D      		eor r25,__tmp_reg__
 629 0110 8327      		eor r24,r19
 630 0112 0694      	 ;  0 "" 2
 631 0114 3795      	 ;  116 "d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h" 1
 632 0116 9025      		eor r24,r18
 633 0118 8327      		mov r19,r24
 634               		swap r19
 635               		eor r19,r24
 636 011a 8227      		mov __tmp_reg__,r19
 637 011c 382F      		lsr r19
 638 011e 3295      		lsr r19
 639 0120 3827      		eor r19,__tmp_reg__
 640 0122 032E      		mov __tmp_reg__,r19
 641 0124 3695      		lsr r19
 642 0126 3695      		eor r19,__tmp_reg__
 643 0128 3025      		andi r19,0x07
 644 012a 032E      		mov __tmp_reg__,r24
 645 012c 3695      		mov r24,r25
 646 012e 3025      		lsr r19
 647 0130 3770      		ror __tmp_reg__
 648 0132 082E      		ror r19
 649 0134 892F      		mov r25,__tmp_reg__
 650 0136 3695      		eor r24,r19
 651 0138 0794      		lsr __tmp_reg__
 652 013a 3795      		ror r19
 653 013c 902D      		eor r25,__tmp_reg__
 654 013e 8327      		eor r24,r19
 655 0140 0694      	 ;  0 "" 2
 656 0142 3795      	 ;  116 "d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/util/crc16.h" 1
 657 0144 9025      		eor r24,r18
 658 0146 8327      		mov r18,r24
 659               		swap r18
 660               		eor r18,r24
 661 0148 8227      		mov __tmp_reg__,r18
 662 014a 282F      		lsr r18
 663 014c 2295      		lsr r18
 664 014e 2827      		eor r18,__tmp_reg__
 665 0150 022E      		mov __tmp_reg__,r18
 666 0152 2695      		lsr r18
 667 0154 2695      		eor r18,__tmp_reg__
 668 0156 2025      		andi r18,0x07
 669 0158 022E      		mov __tmp_reg__,r24
 670 015a 2695      		mov r24,r25
 671 015c 2025      		lsr r18
 672 015e 2770      		ror __tmp_reg__
 673 0160 082E      		ror r18
 674 0162 892F      		mov r25,__tmp_reg__
 675 0164 2695      		eor r24,r18
 676 0166 0794      		lsr __tmp_reg__
 677 0168 2795      		ror r18
 678 016a 902D      		eor r25,__tmp_reg__
 679 016c 8227      		eor r24,r18
 680 016e 0694      	 ;  0 "" 2
 681 0170 2795      	/* #NOAPP */
 682 0172 9025      	.LBE30:
 683 0174 8227      	.LBE29:
 684               	.LBE28:
 686               	.Ltext6:
 688               	.LM46:
 689               		mov r19,r15
 690               		ldi r18,lo8(0)
1513:xboot.c       **** 16_block(uint32_t start, uint32_t length)
1514:xboot.c       **** {
1515:xboot.c       ****         uint16_t crc = 0;
1516:xboot.c       ****         
1517:xboot.c       ****         int bc = SPM_PAGESIZE;
1518:xboot.c       ****         
 691               	(8)
 692               		mov r12,r24
 693 0176 3F2D      	.LBB32:
 695 017a 10E0      	.LM48:
 696 017c 202B      		clr r13
 697 017e 312B      		dec r13
 698 0180 2817      	.L35:
 699 0182 3907      	.LBE32:
 701 0186 00C0      	.LM49:
 702 0188 EE24      		in r24,43-32
 703 018a FF24      		eor r24,r12
 704 018c 8701      		out 43-32,r24
1519:xboot.c       **** uint16_t crc = 0;
1520:xboot.c       ****         
1521:xboot.c       ****         int bc = SPM_PAGESIZE;
1522:xboot.c       ****         
1523:xboot.c       ****         for ( ; length > 0; length--)
1524:xboot.c       ****         {
1525:xboot.c       ****                 if (bc == SPM_PAGESIZE)
1526:xboot.c       ****                 {
 706               	2,r16
 707               		movw r20,r14
 708 018e 88E0      		subi r20,lo8(-(14336))
 709 0190 C82E      		sbci r21,hi8(-(14336))
 710               		sbci r22,hlo8(-(14336))
1527:xboot.c       ****    {
1528:xboot.c       ****                 if (bc == SPM_PAGESIZE)
1529:xboot.c       ****                 {
1530:xboot.c       ****                         Flash_ReadFlashPage(buffer, start);
1531:xboot.c       ****                         start += SPM_PAGESIZE;
1532:xboot.c       ****                         bc = 0;
1533:xboot.c       ****                 }
1534:xboot.c       ****                 
1535:xboot.c       ****                 crc = _crc16_update(crc, buffer[bc]);
 711               	 r23,hhi8(-(14336))
 712               		ldi r24,lo8(buffer)
 713 0192 DD24      		ldi r25,hi8(buffer)
 714 0194 DA94      		call Flash_ReadFlashPage
 716               	.LM51:
 717               		ldi r24,lo8(14208)
 718               		cp r14,r24
 719 0196 8BB1      		ldi r24,hi8(14208)
 720 0198 8C25      		cpc r15,r24
 721 019a 8BB9      		ldi r24,hlo8(14208)
 722               		cpc r16,r24
 723               		ldi r24,hhi8(14208)
 724 019c B801      		cpc r17,r24
 725 019e A701      		brlo .L34
 726 01a0 4050      	.LBB33:
 728 01a4 6F4F      	.LM52:
 729 01a6 7F4F      		sts buffer+122,r13
 730 01a8 80E0      		sts buffer+123,r13
 731 01aa 90E0      		sts buffer+124,r13
 732 01ac 0E94 0000 		sts buffer+125,r13
 733               		sts buffer+126,r13
 734               		sts buffer+127,r13
 735 01b0 80E8      	.L34:
 736 01b2 E816      	.LBE33:
 738 01b6 F806      	.LM53:
 739 01b8 80E0      		movw r24,r16
 740 01ba 0807      		movw r22,r14
 741 01bc 80E0      		ldi r20,lo8(buffer)
 742 01be 1807      		ldi r21,hi8(buffer)
 743 01c0 00F0      		ldi r18,lo8(1)
 744               		call Flash_ProgramPage
 746               	.LM54:
 747 01c2 D092 0000 		ldi r24,lo8(128)
 748 01c6 D092 0000 		ldi r25,hi8(128)
 749 01ca D092 0000 		ldi r26,hlo8(128)
 750 01ce D092 0000 		ldi r27,hhi8(128)
 751 01d2 D092 0000 		add r14,r24
 752 01d6 D092 0000 		adc r15,r25
 753               		adc r16,r26
 754               		adc r17,r27
1536:xboot.c       ****   
1537:xboot.c       ****                 crc = _crc16_update(crc, buffer[bc]);
 755               	(14336)
 756               		cpc r15,r25
 757 01da C801      		ldi r25,hlo8(14336)
 758 01dc B701      		cpc r16,r25
 759 01de 40E0      		ldi r25,hhi8(14336)
 760 01e0 50E0      		cpc r17,r25
 761 01e2 21E0      		brne .L35
 762 01e4 0E94 0000 	.L33:
 763               	.LBE31:
 765 01e8 80E8      	.LM55:
 766 01ea 90E0      		call xboot_app_temp_erase
 767 01ec A0E0      	.L36:
 768 01ee B0E0      	/* epilogue start */
 770 01f2 F91E      	.LM56:
 771 01f4 0A1F      		pop r17
 772 01f6 1B1F      		pop r16
 773 01f8 90E0      		pop r15
 774 01fa E916      		pop r14
 775 01fc 98E3      		pop r13
 776 01fe F906      		pop r12
 777 0200 90E0      		ret
1538:xboot.c       ****   
1539:xboot.c       ****                 crc = _crc16_update(crc, buffer[bc]);
1540:xboot.c       ****                 
1541:xboot.c       ****                 bc++;
 784               	B8
 785               	.Lscope8:
 786 020a 0E94 0000 		.section	.text.BlockRead,"ax",@progbits
1542:xboot.c       **** c, buffer[bc]);
1543:xboot.c       ****                 
 789               	bs	"mem:P(0,11)",64,0,0,22
 791 020e 1F91      	.global	BlockRead
 793 0212 FF90      	BlockRead:
 795 0216 DF90      	.LM57:
 796 0218 CF90      	.LFBB9:
 797 021a 0895      		push r16
 798               		push r17
 799               		push r28
 800               		push r29
 801               	/* prologue: function */
 802               	/* frame size = 0 */
 803               		movw r16,r24
 804               		movw r28,r20
 806               	.LM58:
 807               		cpi r22,lo8(69)
 808               		brne .L39
 809               	.LBB34:
 810               	.LBB35:
 812               	.Ltext7:
 814               	.LM59:
 815               		ld r22,Y
 816               		ldd r23,Y+1
 817 0000 0F93      		ldi r24,lo8(buffer)
 818 0002 1F93      		ldi r25,hi8(buffer)
 819 0004 CF93      		movw r20,r16
 820 0006 DF93      		ldi r18,lo8(gs(eeprom_read_byte))
 821               		ldi r19,hi8(gs(eeprom_read_byte))
 822               		call __eerd_block
 823 0008 8C01      	.LBE35:
 824 000a EA01      	.LBE34:
 826               	.Ltext8:
 828 000e 01F4      	.LM60:
 829               		movw r18,r16
 830               		ldi r20,lo8(0)
 831               		ldi r21,hi8(0)
 832               		ld r24,Y
 833               		ldd r25,Y+1
 834               		ldd r26,Y+2
 835 0010 6881      		ldd r27,Y+3
 836 0012 7981      		add r24,r18
 837 0014 80E0      		adc r25,r19
 838 0016 90E0      		adc r26,r20
 839 0018 A801      		adc r27,r21
 840 001a 20E0      		rjmp .L49
 841 001c 30E0      	.L39:
 843               	.LM61:
 844               		cpi r22,lo8(70)
 845               		breq .+2
 846               		rjmp .L46
 848               	.LM62:
 849 0022 9801      		ld r24,Y
 850 0024 40E0      		ldd r25,Y+1
 851 0026 50E0      		ldd r26,Y+2
 852 0028 8881      		ldd r27,Y+3
 853 002a 9981      		lsl r24
 854 002c AA81      		rol r25
 855 002e BB81      		rol r26
 856 0030 820F      		rol r27
 857 0032 931F      		st Y,r24
 858 0034 A41F      		std Y+1,r25
 859 0036 B51F      		std Y+2,r26
 860 0038 00C0      		std Y+3,r27
 861               		ldi r18,lo8(buffer)
 862               		ldi r19,hi8(buffer)
 864 003a 6634      	.LM63:
 865 003c 01F0      		movw r20,r16
 866 003e 00C0      		add r20,r18
 867               		adc r21,r19
 868               	.L43:
 869 0040 8881      	.LBB36:
 871 0044 AA81      	.LM64:
 872 0046 BB81      		ld r30,Y
 873 0048 880F      		ldd r31,Y+1
 874 004a 991F      	/* #APP */
 875 004c AA1F      	 ;  1434 "xboot.c" 1
 876 004e BB1F      		lpm r30, Z
 877 0050 8883      		
 878 0052 9983      	 ;  0 "" 2
 879 0054 AA83      	/* #NOAPP */
 880 0056 BB83      	.LBE36:
 881 0058 20E0      		movw r26,r18
 882 005a 30E0      		st X,r30
 883               	.L42:
 885 005c A801      	.LM65:
 886 005e 420F      		in __tmp_reg__,87-32
 887 0060 531F      		sbrc __tmp_reg__,0
 888               		rjmp .L42
 890               	.LM66:
 891               		ld r24,Y
 892 0062 E881      		ldd r25,Y+1
 893 0064 F981      		ldd r26,Y+2
 894               		ldd r27,Y+3
 895               		adiw r24,1
 896 0066 E491      		adc r26,__zero_reg__
 897               		adc r27,__zero_reg__
 898               		st Y,r24
 899               		std Y+1,r25
 900               		std Y+2,r26
 901 0068 D901      		std Y+3,r27
 902 006a EC93      		subi r18,lo8(-(1))
 903               		sbci r19,hi8(-(1))
 905               	.LM67:
 906 006c 07B6      		cp r18,r20
 907 006e 00FC      		cpc r19,r21
 908 0070 00C0      		brne .L43
 910               	.LM68:
 911 0072 8881      		lsr r27
 912 0074 9981      		ror r26
 913 0076 AA81      		ror r25
 914 0078 BB81      		ror r24
 915 007a 0196      	.L49:
 916 007c A11D      		st Y,r24
 917 007e B11D      		std Y+1,r25
 918 0080 8883      		std Y+2,r26
 919 0082 9983      		std Y+3,r27
 920 0084 AA83      		ldi r28,lo8(0)
 921 0086 BB83      		ldi r29,hi8(0)
 922 0088 2F5F      		rjmp .L44
 923 008a 3F4F      	.L45:
 924               	.LBB37:
 926 008c 2417      	.LM69:
 927 008e 3507      		movw r30,r28
 928 0090 01F4      		subi r30,lo8(-(buffer))
 929               		sbci r31,hi8(-(buffer))
 930               		ld r24,Z
 931 0092 B695      		call send_char
 933 0096 9795      	.LM70:
 934 0098 8795      		adiw r28,1
 935               	.L44:
 936 009a 8883      		cp r28,r16
 937 009c 9983      		cpc r29,r17
 938 009e AA83      		brlt .L45
 939 00a0 BB83      	.L46:
 940 00a2 C0E0      	/* epilogue start */
 941 00a4 D0E0      	.LBE37:
 943               	.LM71:
 944               		pop r29
 945               		pop r28
 946               		pop r17
 947 00a8 FE01      		pop r16
 948 00aa E050      		ret
 956 00b6 C017      	.Lscope9:
 957 00b8 D107      		.section	.text.BlockLoad,"ax",@progbits
 962               	.global	BlockLoad
 964 00bc DF91      	BlockLoad:
 966 00c0 1F91      	.LM72:
 967 00c2 0F91      	.LFBB10:
 968 00c4 0895      		push r13
 969               		push r14
 970               		push r15
 971               		push r16
 972               		push r17
 973               		push r28
 974               		push r29
 975               	/* prologue: function */
 976               	/* frame size = 0 */
 977               		movw r16,r24
 978               		mov r13,r22
 979               		movw r14,r20
 981               	.LM73:
 982               		ldi r28,lo8(0)
 983               		ldi r29,hi8(0)
 984               	.L53:
 985               	.LBB38:
 986               	.LBB39:
 988 0000 DF92      	.LM74:
 989 0002 EF92      		cp r28,r16
 990 0004 FF92      		cpc r29,r17
 991 0006 0F93      		brlo .L51
 992 0008 1F93      		ldi r24,lo8(-1)
 993 000a CF93      		rjmp .L52
 994 000c DF93      	.L51:
 996               	.LM75:
 997 000e 8C01      		call get_char
 998 0010 D62E      	.L52:
 1000               	.LM76:
 1001               		movw r30,r28
 1002 0014 C0E0      		subi r30,lo8(-(buffer))
 1003 0016 D0E0      		sbci r31,hi8(-(buffer))
 1004               		st Z,r24
 1005               	.LBE39:
 1007               	.LM77:
 1008               		adiw r28,1
 1009 0018 C017      		cpi r28,128
 1010 001a D107      		cpc r29,__zero_reg__
 1011 001c 00F0      		brne .L53
 1012 001e 8FEF      	.LBE38:
 1014               	.LM78:
 1015               		ldi r24,lo8(69)
 1016               		cp r13,r24
 1017 0022 0E94 0000 		brne .L54
 1018               	.LBB40:
 1019               	.LBB41:
 1021 0026 FE01      	.Ltext9:
 1023 002a F040      	.LM79:
 1024 002c 8083      		movw r30,r14
 1025               		ld r24,Z
 1026               		ldd r25,Z+1
 1027               		ldi r22,lo8(buffer)
 1028 002e 2196      		ldi r23,hi8(buffer)
 1029 0030 C038      		movw r20,r16
 1030 0032 D105      		ldi r18,lo8(gs(eeprom_write_byte))
 1031 0034 01F4      		ldi r19,hi8(gs(eeprom_write_byte))
 1032               		call __eewr_block
 1033               	.LBE41:
 1034               	.LBE40:
 1036 0038 D816      	.Ltext10:
 1038               	.LM80:
 1039               		movw r18,r16
 1040               		ldi r20,lo8(0)
 1041               		ldi r21,hi8(0)
 340:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** )__p;
 341:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 342:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     EEDR = __value;
 343:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 344:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     __asm__ __volatile__ (
 345:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         "/* START EEPROM WRITE CRITICAL SECTION */\n\t"
 346:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         "in	r0, %[__sreg]		\n\t"
 347:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         "cli				\n\t"
 348:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         "sbi	%[__eecr], %[__eemwe]	\n\t"
 349:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         "sbi	%[__eecr], %[__eewe]	\n\t"
 350:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         "out	%[__sreg], r0		\n\t"
 351:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         "/* END EEPROM WRITE CRITICAL SECTION */"
 352:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         :
 353:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         : [__eecr]  "i" (_SFR_IO_ADDR(EECR)),
 354:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****           [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
 355:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****           [__eemwe] "i" (EEMWE),
 356:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****           [__eewe]  "i" (EEWE)
 357:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         : "r0"
 358:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     );
 359:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** }
 360:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 361:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /** \ingroup avr_eeprom
 362:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     Write a word \a __value to EEPROM address \a __p.
 363:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****  */
 364:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** static __inline__ void eeprom_write_word (uint16_t *__p, uint16_t __value)
 365:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** {
 366:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
 367:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     __eewr_word (__p, __value, eeprom_write_byte);
 368:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #else
 369:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     /* If ATmega256x device, do not call function. */
 370:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     union
 371:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     {
 372:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         uint16_t word;
 373:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         struct
 374:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         {
 375:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****             uint8_t lo;
 376:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****             uint8_t hi;
 377:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         } byte;
 378:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     } x;
 379:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 380:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     x.word = __value;
 381:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     eeprom_write_byte ((uint8_t *)__p, x.byte.lo);
 382:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     eeprom_write_byte ((uint8_t *)__p + 1, x.byte.hi);
 383:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #endif
 384:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** }
 385:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** 
 386:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** /** \ingroup avr_eeprom
 387:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     Write a 32-bit double word \a __value to EEPROM address \a __p.
 388:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****  */
 389:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** static __inline__ void eeprom_write_dword (uint32_t *__p, uint32_t __value)
 390:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** {
 391:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
 392:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     __eewr_dword (__p, __value, eeprom_write_byte);
 393:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h **** #else
 394:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     /* If ATmega256x device, do not call function. */
 395:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     union
 396:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****     {
 397:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         uint32_t dword;
 398:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         struct
 399:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****         {
 400:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****             uint8_t byte0;
 401:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****             uint8_t byte1;
 402:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****             uint8_t byte2;
 403:d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h ****             uint8_t byte3;
 1042               	 r30,r14
 1043               		ld r24,Z
 1044 003c F701      		ldd r25,Z+1
 1045 003e 8081      		ldd r26,Z+2
 1046 0040 9181      		ldd r27,Z+3
 1047 0042 60E0      		add r24,r18
 1048 0044 70E0      		adc r25,r19
 1049 0046 A801      		adc r26,r20
 1050 0048 20E0      		adc r27,r21
 1051 004a 30E0      		st Z,r24
 1052 004c 0E94 0000 		std Z+1,r25
 1053               		std Z+2,r26
 1054               		std Z+3,r27
 1055               		rjmp .L59
 1056               	.L54:
 1058               	.LM81:
 1059 0050 9801      		ldi r31,lo8(70)
 1060 0052 40E0      		cp r13,r31
 1061 0054 50E0      		breq .L56
 1062 0056 F701      		ldi r24,lo8(63)
 1063 0058 8081      		rjmp .L55
 1064 005a 9181      	.L56:
 1066 005e B381      	.LM82:
 1067 0060 820F      		movw r30,r14
 1068 0062 931F      		ld r22,Z
 1069 0064 A41F      		ldd r23,Z+1
 1070 0066 B51F      		ldd r24,Z+2
 1071 0068 8083      		ldd r25,Z+3
 1073 006c A283      	.LM83:
 1074 006e B383      		lsr r17
 1075 0070 00C0      		ror r16
 1076               		movw r18,r16
 1077               		ldi r20,lo8(0)
 1078               		ldi r21,hi8(0)
 1079 0072 F6E4      		add r18,r22
 1080 0074 DF16      		adc r19,r23
 1081 0076 01F0      		adc r20,r24
 1082 0078 8FE3      		adc r21,r25
 1083 007a 00C0      		st Z,r18
 1084               		std Z+1,r19
 1085               		std Z+2,r20
 1086               		std Z+3,r21
 1088 007e 6081      	.LM84:
 1089 0080 7181      		lsl r22
 1090 0082 8281      		rol r23
 1091 0084 9381      		rol r24
 1092               		rol r25
 1093               		ldi r20,lo8(buffer)
 1094 0086 1695      		ldi r21,hi8(buffer)
 1095 0088 0795      		ldi r18,lo8(1)
 1096 008a 9801      		call Flash_ProgramPage
 1097 008c 40E0      	.L59:
 1098 008e 50E0      		ldi r24,lo8(13)
 1099 0090 260F      	.L55:
 1100 0092 371F      	/* epilogue start */
 1102 0096 591F      	.LM85:
 1103 0098 2083      		pop r29
 1104 009a 3183      		pop r28
 1105 009c 4283      		pop r17
 1106 009e 5383      		pop r16
 1107               		pop r15
 1108               		pop r14
 1109 00a0 660F      		pop r13
 1110 00a2 771F      		ret
 1118 00b2 8DE0      	.Lscope10:
 1119               		.section	.text.main,"ax",@progbits
 1121               	.global	main
 1123 00b4 DF91      	main:
 1125 00b8 1F91      	.LM86:
 1126 00ba 0F91      	.LFBB11:
 1127 00bc FF90      		push r5
 1128 00be EF90      		push r6
 1129 00c0 DF90      		push r7
 1130 00c2 0895      		push r8
 1131               		push r9
 1132               		push r10
 1133               		push r11
 1134               		push r12
 1135               		push r13
 1136               		push r14
 1137               		push r15
 1138               		push r16
 1139               		push r17
 1140               		push r29
 1141               		push r28
 1142               		rcall .
 1143               		rcall .
 1144               		in r28,__SP_L__
 1145               		in r29,__SP_H__
 1146               	/* prologue: function */
 1147 0000 5F92      	/* frame size = 4 */
 1149 0004 7F92      	.LM87:
 1150 0006 8F92      		std Y+1,__zero_reg__
 1151 0008 9F92      		std Y+2,__zero_reg__
 1152 000a AF92      		std Y+3,__zero_reg__
 1153 000c BF92      		std Y+4,__zero_reg__
 1155 0010 DF92      	.LM88:
 1156 0012 EF92      		sts comm_mode,__zero_reg__
 1158 0016 0F93      	.LM89:
 1159 0018 1F93      		sbi 42-32,3
 1161 001c CF93      	.LM90:
 1162 001e 00D0      		sbi 43-32,3
 1164 0022 CDB7      	.LM91:
 1165 0024 DEB7      		cbi 39-32,4
 1167               	.LM92:
 1168               		sbi 40-32,4
 1170 0026 1982      	.LM93:
 1171 0028 1A82      		call uart_init
 1173 002c 1C82      	.LM94:
 1174               		sbi 43-32,0
 1176 002e 1092 0000 	.LM95:
 1177               		sbi 42-32,2
 1179 0032 539A      	.LM96:
 1180               		cbi 43-32,2
 1182 0034 5B9A      	.LM97:
 1183               		out 84-32,__zero_reg__
 1185 0036 3C98      	.LM98:
 1186               		ldi r24,lo8(24)
 1187               	/* #APP */
 1188 0038 449A      	 ;  302 "xboot.c" 1
 1189               		in __tmp_reg__, __SREG__
 1190               		cli
 1191 003a 0E94 0000 		sts 96, r24
 1192               		sts 96, __zero_reg__
 1193               		out __SREG__,__tmp_reg__
 1194 003e 589A      		
 1195               	 ;  0 "" 2
 1197 0040 529A      	.LM99:
 1198               	 ;  339 "xboot.c" 1
 1199               		nop
 1200 0042 5A98      	 ;  0 "" 2
 1202               	.LM100:
 1203 0044 14BE      	 ;  340 "xboot.c" 1
 1204               		nop
 1205               	 ;  0 "" 2
 1207               	.LM101:
 1208               	 ;  341 "xboot.c" 1
 1209 0048 0FB6      		nop
 1210 004a F894      	 ;  0 "" 2
 1212 0050 1092 6000 	.LM102:
 1213 0054 0FBE      	 ;  342 "xboot.c" 1
 1214               		nop
 1215               	 ;  0 "" 2
 1217               	.LM103:
 1218               	/* #NOAPP */
 1219 0056 0000      		in r25,38-32
 1221               	.LM104:
 1222               		lds r24,192
 1223               		sbrc r24,7
 1224 0058 0000      		rjmp .L61
 1225               		mov r24,r25
 1226               		swap r24
 1227               		andi r24,lo8(15)
 1228               		com r24
 1229 005a 0000      		andi r24,lo8(1)
 1230               		rjmp .L62
 1231               	.L61:
 1233               	.LM105:
 1234 005c 0000      		ldi r24,lo8(1)
 1235               		sts comm_mode,r24
 1236               	.L62:
 1238               	.LM106:
 1239 005e 96B1      	/* #APP */
 1240               	 ;  404 "xboot.c" 1
 1241               		wdr
 1242 0060 8091 C000 	 ;  0 "" 2
 1243 0064 87FD      	/* #NOAPP */
 1244 0066 00C0      		clr r12
 1245 0068 892F      		clr r13
 1247 006c 8F70      	.LM107:
 1248 006e 8095      		ldi r17,lo8(8)
 1249 0070 8170      		mov r6,r17
 1251               	.LM108:
 1252               		clr r5
 1253               		inc r5
 1255 0076 8093 0000 	.LM109:
 1256               		ldi r27,lo8(5)
 1257               		mov r7,r27
 1259               	.LM110:
 1260               		movw r8,r28
 1261 007a A895      		sec
 1262               		adc r8,__zero_reg__
 1263               		adc r9,__zero_reg__
 1264 007c CC24      		rjmp .L108
 1265 007e DD24      	.L107:
 1267               	.LM111:
 1268 0080 18E0      		in r24,43-32
 1269 0082 612E      		eor r24,r6
 1270               		out 43-32,r24
 1272 0084 5524      	.LM112:
 1273 0086 5394      		call get_char
 1274               		mov r25,r24
 1276 0088 B5E0      	.LM113:
 1277 008a 7B2E      		cpi r24,lo8(97)
 1278               		brne .L64
 1280 008c 4E01      	.LM114:
 1281 008e 0894      		ldi r24,lo8(89)
 1282 0090 811C      		rjmp .L110
 1283 0092 911C      	.L64:
 1285               	.LM115:
 1286               		cpi r24,lo8(65)
 1287               		brne .L66
 1289 0098 8625      	.LM116:
 1290 009a 8BB9      		call get_2bytes
 1291               		ldi r26,lo8(0)
 1292               		ldi r27,hi8(0)
 1293 009c 0E94 0000 		rjmp .L114
 1294 00a0 982F      	.L66:
 1296               	.LM117:
 1297 00a2 8136      		cpi r24,lo8(72)
 1298 00a4 01F4      		brne .L67
 1300               	.LM118:
 1301 00a6 89E5      	/* #APP */
 1302 00a8 00C0      	 ;  456 "xboot.c" 1
 1303               		call get_char
 1304               		mov  r26,r24
 1305               		call get_2bytes
 1306 00aa 8134      		clr  r27
 1307 00ac 01F4      		
 1308               	 ;  0 "" 2
 1309               	/* #NOAPP */
 1310 00ae 0E94 0000 	.L114:
 1311 00b2 A0E0      		std Y+1,r24
 1312 00b4 B0E0      		std Y+2,r25
 1313 00b6 00C0      		std Y+3,r26
 1314               		std Y+4,r27
 1315               	.L115:
 1317 00b8 8834      	.LM119:
 1318 00ba 01F4      		ldi r24,lo8(13)
 1319               		rjmp .L110
 1320               	.L67:
 1322               	.LM120:
 1323 00bc 0E94 0000 		cpi r24,lo8(101)
 1324 00c0 A82F      		brne .L68
 1326 00c6 BB27      	.LM121:
 1327               		call Flash_EraseApplicationSection
 1329               	.LM122:
 1330               		call EEPROM_erase_all
 1331 00c8 8983      		rjmp .L115
 1332 00ca 9A83      	.L68:
 1334 00ce BC83      	.LM123:
 1335               		cpi r24,lo8(98)
 1336               		brne .L69
 1338 00d0 8DE0      	.LM124:
 1339 00d2 00C0      		ldi r24,lo8(89)
 1340               		call send_char
 1342               	.LM125:
 1343 00d4 8536      		ldi r24,lo8(0)
 1344 00d6 01F4      		call send_char
 1346               	.LM126:
 1347 00d8 0E94 0000 		ldi r24,lo8(-128)
 1348               		rjmp .L110
 1349               	.L69:
 1351 00e0 00C0      	.LM127:
 1352               		cpi r24,lo8(66)
 1353               		brne .L70
 1355 00e2 8236      	.LM128:
 1356 00e4 01F4      		call get_2bytes
 1357               		mov r17,r24
 1358               		mov r16,r25
 1359 00e6 89E5      		mov r18,r24
 1360 00e8 0E94 0000 		mov r19,r25
 1361               		movw r24,r18
 1362               		movw r12,r24
 1364 00ee 0E94 0000 	.LM129:
 1365               		call get_char
 1366               		mov r22,r24
 1368 00f4 00C0      	.LM130:
 1369               		mov r24,r17
 1370               		mov r25,r16
 1371               		movw r20,r8
 1372 00f6 8234      		call BlockLoad
 1373 00f8 01F4      		rjmp .L110
 1374               	.L70:
 1376 00fa 0E94 0000 	.LM131:
 1377 00fe 182F      		cpi r24,lo8(103)
 1378 0100 092F      		brne .L71
 1380 0104 392F      	.LM132:
 1381 0106 C901      		call get_2bytes
 1382 0108 6C01      		mov r17,r24
 1383               		mov r16,r25
 1384               		mov r18,r24
 1385 010a 0E94 0000 		mov r19,r25
 1386 010e 682F      		movw r24,r18
 1387               		movw r12,r24
 1389 0110 812F      	.LM133:
 1390 0112 902F      		call get_char
 1391 0114 A401      		mov r22,r24
 1393 011a 00C0      	.LM134:
 1394               		mov r24,r17
 1395               		mov r25,r16
 1396               		movw r20,r8
 1397 011c 8736      		call BlockRead
 1398 011e 01F4      		rjmp .L111
 1399               	.L71:
 1401 0120 0E94 0000 	.LM135:
 1402 0124 182F      		cpi r24,lo8(82)
 1403 0126 092F      		brne .L72
 1404 0128 282F      	.LBB42:
 1405 012a 392F      	.LBB43:
 1407 012e 6C01      	.LM136:
 1408               		ldd r30,Y+1
 1409               		ldd r31,Y+2
 1410 0130 0E94 0000 		lsl r30
 1411 0134 682F      		rol r31
 1412               	/* #APP */
 1413               	 ;  532 "xboot.c" 1
 1414 0136 812F      		lpm r16, Z+
 1415 0138 902F      		lpm r17, Z
 1416 013a A401      		
 1417 013c 0E94 0000 	 ;  0 "" 2
 1418 0140 00C0      	/* #NOAPP */
 1419               	.LBE43:
 1421               	.LM137:
 1422 0142 8235      		mov r24,r17
 1423 0144 01F4      		call send_char
 1425               	.LM138:
 1426               		mov r24,r16
 1427               		rjmp .L112
 1428 0146 E981      	.L72:
 1429 0148 FA81      	.LBE42:
 1431 014c FF1F      	.LM139:
 1432               		cpi r24,lo8(99)
 1433               		brne .L73
 1435 0150 1491      	.LM140:
 1436               		call get_char
 1437               		mov r12,r24
 1438               		clr r13
 1439               		rjmp .L115
 1440               	.L73:
 1442 0152 812F      	.LM141:
 1443 0154 0E94 0000 		cpi r24,lo8(67)
 1444               		brne .L74
 1446 0158 802F      	.LM142:
 1447 015a 00C0      		call get_char
 1448               		mov r11,r24
 1449               		clr r10
 1450               		or r12,r10
 1451               		or r13,r11
 1453 015e 01F4      	.LM143:
 1454               		ldd r24,Y+1
 1455               		ldd r25,Y+2
 1456 0160 0E94 0000 		ldd r26,Y+3
 1457 0164 C82E      		ldd r27,Y+4
 1458 0166 DD24      		movw r30,r24
 1459 0168 00C0      		lsl r30
 1460               		rol r31
 1461               	/* #APP */
 1462               	 ;  556 "xboot.c" 1
 1463 016a 8334      		movw  r0, r12
 1464 016c 01F4      		sts 87, r5
 1465               		spm
 1466               		clr  r1
 1467 016e 0E94 0000 		
 1468 0172 B82E      	 ;  0 "" 2
 1470 0176 CA28      	.LM144:
 1471 0178 DB28      	/* #NOAPP */
 1472               		adiw r24,1
 1473               		adc r26,__zero_reg__
 1474 017a 8981      		adc r27,__zero_reg__
 1475 017c 9A81      		rjmp .L114
 1476 017e AB81      	.L74:
 1478 0182 FC01      	.LM145:
 1479 0184 EE0F      		cpi r24,lo8(109)
 1480 0186 FF1F      		brne .L75
 1482               	.LM146:
 1483 0188 0601      		ldd r24,Y+1
 1484 018a 5092 5700 		ldd r25,Y+2
 1485 018e E895      		ldd r26,Y+3
 1486 0190 1124      		ldd r27,Y+4
 1487               		cpi r24,lo8(14336)
 1488               		ldi r18,hi8(14336)
 1489               		cpc r25,r18
 1490               		ldi r18,hlo8(14336)
 1491               		cpc r26,r18
 1492 0192 0196      		ldi r18,hhi8(14336)
 1493 0194 A11D      		cpc r27,r18
 1494 0196 B11D      		brlo .+2
 1495 0198 00C0      		rjmp .L100
 1496               	.L76:
 1498               	.LM147:
 1499 019a 8D36      		movw r30,r24
 1500 019c 01F4      		lsl r30
 1501               		rol r31
 1502               	/* #APP */
 1503 019e 8981      	 ;  570 "xboot.c" 1
 1504 01a0 9A81      		sts 87, r7
 1505 01a2 AB81      		spm
 1506 01a4 BC81      		
 1507 01a6 8030      	 ;  0 "" 2
 1508 01a8 28E3      	/* #NOAPP */
 1509 01aa 9207      		rjmp .L115
 1510 01ac 20E0      	.L75:
 1512 01b0 20E0      	.LM148:
 1513 01b2 B207      		cpi r24,lo8(68)
 1514 01b4 00F0      		brne .L77
 1516               	.LM149:
 1517               		ldd r14,Y+1
 1518               		ldd r15,Y+2
 1519 01b8 FC01      		ldd r16,Y+3
 1520 01ba EE0F      		ldd r17,Y+4
 1521 01bc FF1F      		call get_char
 1522               	.L78:
 1523               	.LBB44:
 1524 01be 7092 5700 	.LBB45:
 1526               	.Ltext11:
 1528               	.LM150:
 1529 01c4 00C0      		sbic 63-32,1
 1530               		rjmp .L78
 1532               	.LM151:
 1533 01c6 8434      		out 63-32,__zero_reg__
 1535               	.LM152:
 1536               		out (65)+1-32,r15
 1537 01ca E980      		out 65-32,r14
 1539 01ce 0B81      	.LM153:
 1540 01d0 1C81      		out 64-32,r24
 1542               	.LM154:
 1543               	/* #APP */
 1544               	 ;  324 "d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h" 1
 1545               		/* START EEPROM WRITE CRITICAL SECTION */
 1546               		in	r0, 63		
 1547               		cli				
 1548               		sbi	31, 2	
 1549 01d6 F999      		sbi	31, 1	
 1550 01d8 00C0      		out	63, r0		
 1551               		/* END EEPROM WRITE CRITICAL SECTION */
 1552               	 ;  0 "" 2
 1553 01da 1FBA      	/* #NOAPP */
 1554               		rjmp .L113
 1555               	.L77:
 1556 01dc F2BC      	.LBE45:
 1557 01de E1BC      	.LBE44:
 1559               	.Ltext12:
 1561               	.LM155:
 1562               		cpi r24,lo8(100)
 1563               		brne .L79
 1564               	.LBB46:
 1566 01e2 0FB6      	.LM156:
 1567 01e4 F894      		ldd r24,Y+1
 1568 01e6 FA9A      		ldd r25,Y+2
 1569 01e8 F99A      		ldd r26,Y+3
 1570 01ea 0FBE      		ldd r27,Y+4
 1571               	.L80:
 1572               	.LBB47:
 1573               	.LBB48:
 1575               	.Ltext13:
 1577               	.LM157:
 1578               		sbic 63-32,1
 1579               		rjmp .L80
 1581               	.LM158:
 1582 01ee 8436      		out (65)+1-32,r25
 1583 01f0 01F4      		out 65-32,r24
 1585               	.LM159:
 1586               	/* #APP */
 1587 01f2 8981      	 ;  208 "d:/program files/arduino/hardware/tools/avr/lib/gcc/../../avr/include/avr/eeprom.h" 1
 1588 01f4 9A81      		/* START EEPROM READ CRITICAL SECTION */ 
 1589 01f6 AB81      		sbi 31, 0 
 1590 01f8 BC81      		in r24, 32 
 1591               		/* END EEPROM READ CRITICAL SECTION */ 
 1592               		
 1593               	 ;  0 "" 2
 1594               	/* #NOAPP */
 1595               	.L112:
 1596               	.LBE48:
 1597               	.LBE47:
 1599 01fc 00C0      	.Ltext14:
 1601               	.LM160:
 1602 01fe 92BD      		call send_char
 1603 0200 81BD      	.L113:
 1605               	.LM161:
 1606               		ldd r24,Y+1
 1607               		ldd r25,Y+2
 1608               		ldd r26,Y+3
 1609 0202 F89A      		ldd r27,Y+4
 1610 0204 80B5      		adiw r24,1
 1611               		adc r26,__zero_reg__
 1612               		adc r27,__zero_reg__
 1613               		std Y+1,r24
 1614               		std Y+2,r25
 1615               		std Y+3,r26
 1616               		std Y+4,r27
 1617               		rjmp .L111
 1618               	.L79:
 1619               	.LBE46:
 1621               	.LM162:
 1622 0206 0E94 0000 		cpi r24,lo8(80)
 1623               		brne .+2
 1624               		rjmp .L115
 1625               		cpi r24,lo8(76)
 1626 020a 8981      		brne .+2
 1627 020c 9A81      		rjmp .L115
 1628 020e AB81      	.L82:
 1630 0212 0196      	.LM163:
 1631 0214 A11D      		cpi r24,lo8(69)
 1632 0216 B11D      		brne .L83
 1634 021a 9A83      	.LM164:
 1635 021c AB83      		ldi r24,lo8(13)
 1636 021e BC83      		call send_char
 1637 0220 00C0      		ldi r24,lo8(0)
 1638               		rjmp .L103
 1639               	.L83:
 1641               	.LM165:
 1642 0222 8035      		cpi r24,lo8(112)
 1643 0224 01F4      		brne .L84
 1645 0228 8C34      	.LM166:
 1646 022a 01F4      		ldi r24,lo8(83)
 1647 022c 00C0      		rjmp .L110
 1648               	.L84:
 1650               	.LM167:
 1651 022e 8534      		cpi r24,lo8(116)
 1652 0230 01F4      		brne .L85
 1654               	.LM168:
 1655 0232 8DE0      		ldi r24,lo8(123)
 1656 0234 0E94 0000 		call send_char
 1658 023a 00C0      	.LM169:
 1659               		ldi r24,lo8(0)
 1660               		rjmp .L110
 1661               	.L85:
 1663 023e 01F4      	.LM170:
 1664               		subi r24,lo8(-(-120))
 1665               		cpi r24,lo8(2)
 1666 0240 83E5      		brlo .L86
 1667 0242 00C0      		cpi r25,lo8(84)
 1668               		brne .L87
 1669               	.L86:
 1671 0244 8437      	.LM171:
 1672 0246 01F4      		call get_char
 1673               		rjmp .L115
 1674               	.L87:
 1676 024a 0E94 0000 	.LM172:
 1677               		cpi r25,lo8(83)
 1678               		brne .L88
 1680 0250 00C0      	.LM173:
 1681               		ldi r24,lo8(88)
 1682               		call send_char
 1684 0252 8857      	.LM174:
 1685 0254 8230      		ldi r24,lo8(66)
 1686 0256 00F0      		call send_char
 1688 025a 01F4      	.LM175:
 1689               		ldi r24,lo8(111)
 1690               		call send_char
 1692 025c 0E94 0000 	.LM176:
 1693 0260 00C0      		ldi r24,lo8(111)
 1694               		call send_char
 1696               	.LM177:
 1697 0262 9335      		ldi r24,lo8(116)
 1698 0264 01F4      		call send_char
 1700               	.LM178:
 1701 0266 88E5      		ldi r24,lo8(43)
 1702 0268 0E94 0000 		call send_char
 1704               	.LM179:
 1705 026c 82E4      		ldi r24,lo8(43)
 1706 026e 0E94 0000 		rjmp .L110
 1707               	.L88:
 1709 0272 8FE6      	.LM180:
 1710 0274 0E94 0000 		cpi r25,lo8(86)
 1711               		brne .L89
 1713 0278 8FE6      	.LM181:
 1714 027a 0E94 0000 		ldi r24,lo8(49)
 1715               		call send_char
 1717 027e 84E7      	.LM182:
 1718 0280 0E94 0000 		ldi r24,lo8(55)
 1719               		rjmp .L110
 1720               	.L89:
 1722 0286 0E94 0000 	.LM183:
 1723               		cpi r25,lo8(115)
 1724               		brne .L90
 1726 028c 00C0      	.LM184:
 1727               		ldi r24,lo8(15)
 1728               		call send_char
 1730 028e 9635      	.LM185:
 1731 0290 01F4      		ldi r24,lo8(-107)
 1732               		call send_char
 1734 0292 81E3      	.LM186:
 1735 0294 0E94 0000 		ldi r24,lo8(30)
 1736               		rjmp .L110
 1737               	.L90:
 1739 029a 00C0      	.LM187:
 1740               		cpi r25,lo8(104)
 1741               		breq .+2
 1742               		rjmp .L91
 1743 029c 9337      	.LBB49:
 1745               	.LM188:
 1746               		call get_char
 1748 02a2 0E94 0000 	.LM189:
 1749               		cpi r24,lo8(70)
 1750               		breq .L95
 1751 02a6 85E9      		cpi r24,lo8(71)
 1752 02a8 0E94 0000 		brsh .L98
 1753               		cpi r24,lo8(65)
 1754               		breq .L93
 1755 02ac 8EE1      		cpi r24,lo8(66)
 1756 02ae 00C0      		brne .L92
 1757               		rjmp .L116
 1758               	.L98:
 1759               		cpi r24,lo8(97)
 1760 02b0 9836      		breq .L96
 1761 02b2 01F0      		cpi r24,lo8(116)
 1762 02b4 00C0      		brne .L92
 1763               		rjmp .L117
 1764               	.L93:
 1765               		ldi r22,lo8(0)
 1766 02b6 0E94 0000 		ldi r23,hi8(0)
 1767               		ldi r24,hlo8(0)
 1768               		ldi r25,hhi8(0)
 1769 02ba 8634      		ldi r18,lo8(28672)
 1770 02bc 01F0      		ldi r19,hi8(28672)
 1771 02be 8734      		ldi r20,hlo8(28672)
 1772 02c0 00F4      		ldi r21,hhi8(28672)
 1773 02c2 8134      		rjmp .L99
 1774 02c4 01F0      	.L116:
 1775 02c6 8234      		ldi r22,lo8(28672)
 1776 02c8 01F4      		ldi r23,hi8(28672)
 1777 02ca 00C0      		ldi r24,hlo8(28672)
 1778               		ldi r25,hhi8(28672)
 1779 02cc 8136      		ldi r18,lo8(4096)
 1780 02ce 01F0      		ldi r19,hi8(4096)
 1781 02d0 8437      		ldi r20,hlo8(4096)
 1782 02d2 01F4      		ldi r21,hhi8(4096)
 1783 02d4 00C0      		rjmp .L99
 1784               	.L96:
 1786 02d8 70E0      	.LM190:
 1787 02da 80E0      		ldi r22,lo8(0)
 1788 02dc 90E0      		ldi r23,hi8(0)
 1789 02de 20E0      		ldi r24,hlo8(0)
 1790 02e0 30E7      		ldi r25,hhi8(0)
 1791 02e2 40E0      		rjmp .L109
 1792 02e4 50E0      	.L117:
 1794               	.LM191:
 1795 02e8 60E0      		ldi r22,lo8(14336)
 1796 02ea 70E7      		ldi r23,hi8(14336)
 1797 02ec 80E0      		ldi r24,hlo8(14336)
 1798 02ee 90E0      		ldi r25,hhi8(14336)
 1799 02f0 20E0      	.L109:
 1800 02f2 30E1      		ldi r18,lo8(14336)
 1801 02f4 40E0      		ldi r19,hi8(14336)
 1802 02f6 50E0      		ldi r20,hlo8(14336)
 1803 02f8 00C0      		ldi r21,hhi8(14336)
 1804               		rjmp .L99
 1805               	.L92:
 1807 02fa 60E0      	.LM192:
 1808 02fc 70E0      		ldi r24,lo8(63)
 1809 02fe 80E0      		call send_char
 1810 0300 90E0      		rjmp .L107
 1811 0302 00C0      	.L95:
 1813               	.LM193:
 1814               		ldi r22,lo8(0)
 1815 0304 60E0      		ldi r23,hi8(0)
 1816 0306 78E3      		ldi r24,hlo8(0)
 1817 0308 80E0      		ldi r25,hhi8(0)
 1818 030a 90E0      		ldi r18,lo8(32768)
 1819               		ldi r19,hi8(32768)
 1820 030c 20E0      		ldi r20,hlo8(32768)
 1821 030e 38E3      		ldi r21,hhi8(32768)
 1822 0310 40E0      	.L99:
 1824 0314 00C0      	.LM194:
 1825               		call crc16_block
 1826               		mov r17,r24
 1828 0316 8FE3      	.LM195:
 1829 0318 0E94 0000 		mov r24,r25
 1830 031c 00C0      		call send_char
 1832               	.LM196:
 1833               		mov r24,r17
 1834 031e 60E0      		rjmp .L110
 1835 0320 70E0      	.L91:
 1836 0322 80E0      	.LBE49:
 1838 0326 20E0      	.LM197:
 1839 0328 30E8      		cpi r25,lo8(27)
 1840 032a 40E0      		breq .L111
 1841 032c 50E0      	.L100:
 1843               	.LM198:
 1844               		ldi r24,lo8(63)
 1845 032e 0E94 0000 	.L110:
 1846 0332 182F      		call send_char
 1847               	.L111:
 1848               		ldi r24,lo8(1)
 1849 0334 892F      	.L103:
 1851               	.LM199:
 1852               		in __tmp_reg__,87-32
 1853 033a 812F      		sbrc __tmp_reg__,0
 1854 033c 00C0      		rjmp .L103
 1855               	.L108:
 1857               	.LM200:
 1858               		tst r24
 1859 033e 9B31      		breq .+2
 1860 0340 01F0      		rjmp .L107
 1862               	.LM201:
 1863               		call install_firmware
 1865               	.LM202:
 1866 0344 0E94 0000 		call uart_deinit
 1868 0348 81E0      	.LM203:
 1869               		cbi 43-32,0
 1871               	.LM204:
 1872 034a 07B6      		cbi 42-32,2
 1874 034e 00C0      	.LM205:
 1875               		cbi 43-32,2
 1877               	.LM206:
 1878 0350 8823      		cbi 40-32,4
 1880 0354 00C0      	.LM207:
 1881               		cbi 42-32,3
 1883 0356 0E94 0000 	.LM208:
 1884               		cbi 43-32,3
 1886 035a 0E94 0000 	.LM209:
 1887               	/* #APP */
 1888               	 ;  1007 "xboot.c" 1
 1889 035e 5898      		jmp 0
 1890               	 ;  0 "" 2
 1892 0360 5298      	.LM210:
 1893               	/* #NOAPP */
 1894               		ldi r24,lo8(0)
 1895 0362 5A98      		ldi r25,hi8(0)
 1896               	/* epilogue start */
 1897               		pop __tmp_reg__
 1898 0364 4498      		pop __tmp_reg__
 1899               		pop __tmp_reg__
 1900               		pop __tmp_reg__
 1901 0366 5398      		pop r28
 1902               		pop r29
 1903               		pop r17
 1904 0368 5B98      		pop r16
 1905               		pop r15
 1906               		pop r14
 1907               		pop r13
 1908               		pop r12
 1909 036a 0C94 0000 		pop r11
 1910               		pop r10
 1911               		pop r9
 1912               		pop r8
 1913               		pop r7
 1914 036e 80E0      		pop r6
 1915 0370 90E0      		pop r5
 1916               		ret
 1935 0396 5F90      	.Lscope11:
 1936 0398 0895      		.comm comm_mode,1,1
 1937               		.comm buffer,128,1
 1940               		.text
 1942               	.Letext0:
 1943               	...
DEFINED SYMBOLS
                            *ABS*:00000000 xboot.c
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:2      *ABS*:0000003f __SREG__
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:3      *ABS*:0000003e __SP_H__
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:4      *ABS*:0000003d __SP_L__
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:5      *ABS*:00000034 __CCP__
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:6      *ABS*:00000000 __tmp_reg__
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:7      *ABS*:00000001 __zero_reg__
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:103    .text.eeprom_read_byte:00000000 eeprom_read_byte
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:145    .text.eeprom_write_byte:00000000 eeprom_write_byte
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:190    .text.get_char:00000000 get_char
                            *COM*:00000001 comm_mode
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:230    .text.send_char:00000000 send_char
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:266    .text.get_2bytes:00000000 get_2bytes
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:297    .text.clear_buffer:00000000 clear_buffer
                            *COM*:00000080 buffer
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:335    .text.crc16_block:00000000 crc16_block
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:472    .text.install_firmware:00000000 install_firmware
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:813    .text.BlockRead:00000000 BlockRead
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:984    .text.BlockLoad:00000000 BlockLoad
C:\DOCUME~1\Edwin\LOCALS~1\Temp/cccn8yIc.s:1143   .text.main:00000000 main

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
Flash_ReadFlashPage
Flash_ProgramPage
xboot_app_temp_erase
__eerd_block
__eewr_block
uart_init
Flash_EraseApplicationSection
EEPROM_erase_all
uart_deinit
