
xboot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c02  00007000  00007000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000081  00800100  00800100  00000c76  2**0
                  ALLOC
  2 .stab         0000216c  00000000  00000000  00000c78  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      0000108a  00000000  00000000  00002de4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007000 <__vectors>:
    7000:	0c 94 3d 38 	jmp	0x707a	; 0x707a <__ctors_end>
    7004:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7008:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    700c:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7010:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7014:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7018:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    701c:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7020:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7024:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7028:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    702c:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7030:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7034:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7038:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    703c:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7040:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7044:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7048:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    704c:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7050:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7054:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7058:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    705c:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7060:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>
    7064:	0c 94 5a 38 	jmp	0x70b4	; 0x70b4 <__bad_interrupt>

00007068 <api_jump_table>:
    7068:	58 42 6a 01 70 3d 77 3d 79 3d ae 3d 00 00 96 3d     XBj.p=w=y=.=...=
    7078:	c1 3d                                               .=

0000707a <__ctors_end>:
    707a:	11 24       	eor	r1, r1
    707c:	1f be       	out	0x3f, r1	; 63
    707e:	cf ef       	ldi	r28, 0xFF	; 255
    7080:	d8 e0       	ldi	r29, 0x08	; 8
    7082:	de bf       	out	0x3e, r29	; 62
    7084:	cd bf       	out	0x3d, r28	; 61

00007086 <__do_copy_data>:
    7086:	11 e0       	ldi	r17, 0x01	; 1
    7088:	a0 e0       	ldi	r26, 0x00	; 0
    708a:	b1 e0       	ldi	r27, 0x01	; 1
    708c:	e2 e0       	ldi	r30, 0x02	; 2
    708e:	fc e7       	ldi	r31, 0x7C	; 124
    7090:	02 c0       	rjmp	.+4      	; 0x7096 <.do_copy_data_start>

00007092 <.do_copy_data_loop>:
    7092:	05 90       	lpm	r0, Z+
    7094:	0d 92       	st	X+, r0

00007096 <.do_copy_data_start>:
    7096:	a0 30       	cpi	r26, 0x00	; 0
    7098:	b1 07       	cpc	r27, r17
    709a:	d9 f7       	brne	.-10     	; 0x7092 <.do_copy_data_loop>

0000709c <__do_clear_bss>:
    709c:	11 e0       	ldi	r17, 0x01	; 1
    709e:	a0 e0       	ldi	r26, 0x00	; 0
    70a0:	b1 e0       	ldi	r27, 0x01	; 1
    70a2:	01 c0       	rjmp	.+2      	; 0x70a6 <.do_clear_bss_start>

000070a4 <.do_clear_bss_loop>:
    70a4:	1d 92       	st	X+, r1

000070a6 <.do_clear_bss_start>:
    70a6:	a1 38       	cpi	r26, 0x81	; 129
    70a8:	b1 07       	cpc	r27, r17
    70aa:	e1 f7       	brne	.-8      	; 0x70a4 <.do_clear_bss_loop>
    70ac:	0e 94 00 3b 	call	0x7600	; 0x7600 <main>
    70b0:	0c 94 ff 3d 	jmp	0x7bfe	; 0x7bfe <_exit>

000070b4 <__bad_interrupt>:
    70b4:	0c 94 00 38 	jmp	0x7000	; 0x7000 <__vectors>

000070b8 <__eerd_block>:
    70b8:	a0 e0       	ldi	r26, 0x00	; 0
    70ba:	b0 e0       	ldi	r27, 0x00	; 0
    70bc:	e2 e6       	ldi	r30, 0x62	; 98
    70be:	f8 e3       	ldi	r31, 0x38	; 56
    70c0:	0c 94 d2 3d 	jmp	0x7ba4	; 0x7ba4 <__prologue_saves__+0x14>
    70c4:	7c 01       	movw	r14, r24
    70c6:	eb 01       	movw	r28, r22
    70c8:	8a 01       	movw	r16, r20
    70ca:	69 01       	movw	r12, r18
    70cc:	09 c0       	rjmp	.+18     	; 0x70e0 <__eerd_block+0x28>
    70ce:	ce 01       	movw	r24, r28
    70d0:	21 96       	adiw	r28, 0x01	; 1
    70d2:	f6 01       	movw	r30, r12
    70d4:	09 95       	icall
    70d6:	f7 01       	movw	r30, r14
    70d8:	81 93       	st	Z+, r24
    70da:	7f 01       	movw	r14, r30
    70dc:	01 50       	subi	r16, 0x01	; 1
    70de:	10 40       	sbci	r17, 0x00	; 0
    70e0:	01 15       	cp	r16, r1
    70e2:	11 05       	cpc	r17, r1
    70e4:	a1 f7       	brne	.-24     	; 0x70ce <__eerd_block+0x16>
    70e6:	cd b7       	in	r28, 0x3d	; 61
    70e8:	de b7       	in	r29, 0x3e	; 62
    70ea:	e8 e0       	ldi	r30, 0x08	; 8
    70ec:	0c 94 ee 3d 	jmp	0x7bdc	; 0x7bdc <__epilogue_restores__+0x14>

000070f0 <__eewr_block>:
    70f0:	a0 e0       	ldi	r26, 0x00	; 0
    70f2:	b0 e0       	ldi	r27, 0x00	; 0
    70f4:	ee e7       	ldi	r30, 0x7E	; 126
    70f6:	f8 e3       	ldi	r31, 0x38	; 56
    70f8:	0c 94 d2 3d 	jmp	0x7ba4	; 0x7ba4 <__prologue_saves__+0x14>
    70fc:	ec 01       	movw	r28, r24
    70fe:	7b 01       	movw	r14, r22
    7100:	8a 01       	movw	r16, r20
    7102:	69 01       	movw	r12, r18
    7104:	09 c0       	rjmp	.+18     	; 0x7118 <__eewr_block+0x28>
    7106:	ce 01       	movw	r24, r28
    7108:	21 96       	adiw	r28, 0x01	; 1
    710a:	f7 01       	movw	r30, r14
    710c:	61 91       	ld	r22, Z+
    710e:	7f 01       	movw	r14, r30
    7110:	f6 01       	movw	r30, r12
    7112:	09 95       	icall
    7114:	01 50       	subi	r16, 0x01	; 1
    7116:	10 40       	sbci	r17, 0x00	; 0
    7118:	01 15       	cp	r16, r1
    711a:	11 05       	cpc	r17, r1
    711c:	a1 f7       	brne	.-24     	; 0x7106 <__eewr_block+0x16>
    711e:	cd b7       	in	r28, 0x3d	; 61
    7120:	de b7       	in	r29, 0x3e	; 62
    7122:	e8 e0       	ldi	r30, 0x08	; 8
    7124:	0c 94 ee 3d 	jmp	0x7bdc	; 0x7bdc <__epilogue_restores__+0x14>

00007128 <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    7128:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    712a:	f9 99       	sbic	0x1f, 1	; 31
    712c:	fe cf       	rjmp	.-4      	; 0x712a <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    712e:	32 bd       	out	0x22, r19	; 34
    7130:	21 bd       	out	0x21, r18	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7132:	f8 9a       	sbi	0x1f, 0	; 31
    7134:	80 b5       	in	r24, 0x20	; 32
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
    7136:	08 95       	ret

00007138 <eeprom_write_byte>:

/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    7138:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
    713a:	f9 99       	sbic	0x1f, 1	; 31
    713c:	fe cf       	rjmp	.-4      	; 0x713a <eeprom_write_byte+0x2>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    713e:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    7140:	32 bd       	out	0x22, r19	; 34
    7142:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
    7144:	60 bd       	out	0x20, r22	; 32

    __asm__ __volatile__ (
    7146:	0f b6       	in	r0, 0x3f	; 63
    7148:	f8 94       	cli
    714a:	fa 9a       	sbi	0x1f, 2	; 31
    714c:	f9 9a       	sbi	0x1f, 1	; 31
    714e:	0f be       	out	0x3f, r0	; 63
          [__sreg]  "i" (_SFR_IO_ADDR(SREG)),
          [__eemwe] "i" (EEMWE),
          [__eewe]  "i" (EEWE)
        : "r0"
    );
}
    7150:	08 95       	ret

00007152 <get_char>:
        
        while (1)
        {
                #ifdef USE_UART
                // Get next character
                if (comm_mode == MODE_UNDEF || comm_mode == MODE_UART)
    7152:	90 91 00 01 	lds	r25, 0x0100
    7156:	92 30       	cpi	r25, 0x02	; 2
    7158:	50 f4       	brcc	.+20     	; 0x716e <get_char+0x1c>
                {
                        if (uart_char_received())
    715a:	80 91 c0 00 	lds	r24, 0x00C0
    715e:	87 ff       	sbrs	r24, 7
    7160:	fa cf       	rjmp	.-12     	; 0x7156 <get_char+0x4>
                        {
                                comm_mode = MODE_UART;
    7162:	81 e0       	ldi	r24, 0x01	; 1
    7164:	80 93 00 01 	sts	0x0100, r24
                                return uart_cur_char();
    7168:	80 91 c6 00 	lds	r24, 0x00C6
                #endif // USE_FIFO
                
        }
        
        return ret;
}
    716c:	08 95       	ret
    716e:	ff cf       	rjmp	.-2      	; 0x716e <get_char+0x1c>

00007170 <send_char>:

void __attribute__ ((noinline)) send_char(unsigned char c)
{
    7170:	98 2f       	mov	r25, r24
        unsigned char tmp;
        #endif
        
        #ifdef USE_UART
        // Send character
        if (comm_mode == MODE_UNDEF || comm_mode == MODE_UART)
    7172:	80 91 00 01 	lds	r24, 0x0100
    7176:	82 30       	cpi	r24, 0x02	; 2
    7178:	68 f4       	brcc	.+26     	; 0x7194 <send_char+0x24>
#else // __AVR_XMEGA__
                #ifdef USE_UART_EN_PIN
                #if UART_EN_INV
                UART_EN_PORT &= ~(1 << UART_EN_PIN);
                #else // UART_PIN_INV
                UART_EN_PORT |= (1 << UART_EN_PIN);
    717a:	5a 9a       	sbi	0x0b, 2	; 11
                #endif // UART_PIN_INV
                #endif // USE_UART_EN_PIN
#endif // __AVR_XMEGA__
                uart_send_char_blocking(c);
    717c:	90 93 c6 00 	sts	0x00C6, r25
    7180:	80 91 c0 00 	lds	r24, 0x00C0
    7184:	86 ff       	sbrs	r24, 6
    7186:	fc cf       	rjmp	.-8      	; 0x7180 <send_char+0x10>
    7188:	80 91 c0 00 	lds	r24, 0x00C0
    718c:	80 64       	ori	r24, 0x40	; 64
    718e:	80 93 c0 00 	sts	0x00C0, r24
#else // __AVR_XMEGA__
                #ifdef USE_UART_EN_PIN
                #if UART_EN_INV
                UART_EN_PORT |= (1 << UART_EN_PIN);
                #else // UART_PIN_INV
                UART_EN_PORT &= ~(1 << UART_EN_PIN);
    7192:	5a 98       	cbi	0x0b, 2	; 11
    7194:	08 95       	ret

00007196 <get_2bytes>:

unsigned int __attribute__ ((noinline)) get_2bytes()
{
        // return (get_char() << 8) | get_char();
        unsigned int result;
        asm volatile (
    7196:	0e 94 a9 38 	call	0x7152	; 0x7152 <get_char>
    719a:	38 2f       	mov	r19, r24
    719c:	0e 94 a9 38 	call	0x7152	; 0x7152 <get_char>
    71a0:	28 2f       	mov	r18, r24
                "mov  %A0,r24"     "\n\t"
                : "=r" (result)
                :
        );
        return result;
}
    71a2:	c9 01       	movw	r24, r18
    71a4:	08 95       	ret

000071a6 <crc16_block>:
        }
        
}

uint16_t crc16_block(uint32_t start, uint32_t length)
{
    71a6:	af 92       	push	r10
    71a8:	bf 92       	push	r11
    71aa:	cf 92       	push	r12
    71ac:	df 92       	push	r13
    71ae:	ef 92       	push	r14
    71b0:	ff 92       	push	r15
    71b2:	0f 93       	push	r16
    71b4:	1f 93       	push	r17
    71b6:	cf 93       	push	r28
    71b8:	df 93       	push	r29
    71ba:	5b 01       	movw	r10, r22
    71bc:	6c 01       	movw	r12, r24
    71be:	79 01       	movw	r14, r18
    71c0:	8a 01       	movw	r16, r20
    71c2:	c0 e0       	ldi	r28, 0x00	; 0
    71c4:	d0 e0       	ldi	r29, 0x00	; 0
    71c6:	20 e8       	ldi	r18, 0x80	; 128
    71c8:	30 e0       	ldi	r19, 0x00	; 0
    71ca:	35 c0       	rjmp	.+106    	; 0x7236 <crc16_block+0x90>
        
        int bc = SPM_PAGESIZE;
        
        for ( ; length > 0; length--)
        {
                if (bc == SPM_PAGESIZE)
    71cc:	20 38       	cpi	r18, 0x80	; 128
    71ce:	31 05       	cpc	r19, r1
    71d0:	81 f4       	brne	.+32     	; 0x71f2 <crc16_block+0x4c>
                {
                        Flash_ReadFlashPage(buffer, start);
    71d2:	81 e0       	ldi	r24, 0x01	; 1
    71d4:	91 e0       	ldi	r25, 0x01	; 1
    71d6:	b6 01       	movw	r22, r12
    71d8:	a5 01       	movw	r20, r10
    71da:	0e 94 e1 3c 	call	0x79c2	; 0x79c2 <Flash_ReadFlashPage>
                        start += SPM_PAGESIZE;
    71de:	80 e8       	ldi	r24, 0x80	; 128
    71e0:	90 e0       	ldi	r25, 0x00	; 0
    71e2:	a0 e0       	ldi	r26, 0x00	; 0
    71e4:	b0 e0       	ldi	r27, 0x00	; 0
    71e6:	a8 0e       	add	r10, r24
    71e8:	b9 1e       	adc	r11, r25
    71ea:	ca 1e       	adc	r12, r26
    71ec:	db 1e       	adc	r13, r27
    71ee:	20 e0       	ldi	r18, 0x00	; 0
    71f0:	30 e0       	ldi	r19, 0x00	; 0
_crc16_update(uint16_t __crc, uint8_t __data)
{
	uint8_t __tmp;
	uint16_t __ret;

	__asm__ __volatile__ (
    71f2:	f9 01       	movw	r30, r18
    71f4:	ef 5f       	subi	r30, 0xFF	; 255
    71f6:	fe 4f       	sbci	r31, 0xFE	; 254
    71f8:	80 81       	ld	r24, Z
    71fa:	c8 27       	eor	r28, r24
    71fc:	8c 2f       	mov	r24, r28
    71fe:	82 95       	swap	r24
    7200:	8c 27       	eor	r24, r28
    7202:	08 2e       	mov	r0, r24
    7204:	86 95       	lsr	r24
    7206:	86 95       	lsr	r24
    7208:	80 25       	eor	r24, r0
    720a:	08 2e       	mov	r0, r24
    720c:	86 95       	lsr	r24
    720e:	80 25       	eor	r24, r0
    7210:	87 70       	andi	r24, 0x07	; 7
    7212:	0c 2e       	mov	r0, r28
    7214:	cd 2f       	mov	r28, r29
    7216:	86 95       	lsr	r24
    7218:	07 94       	ror	r0
    721a:	87 95       	ror	r24
    721c:	d0 2d       	mov	r29, r0
    721e:	c8 27       	eor	r28, r24
    7220:	06 94       	lsr	r0
    7222:	87 95       	ror	r24
    7224:	d0 25       	eor	r29, r0
    7226:	c8 27       	eor	r28, r24
                        bc = 0;
                }
                
                crc = _crc16_update(crc, buffer[bc]);
                
                bc++;
    7228:	2f 5f       	subi	r18, 0xFF	; 255
    722a:	3f 4f       	sbci	r19, 0xFF	; 255
{
        uint16_t crc = 0;
        
        int bc = SPM_PAGESIZE;
        
        for ( ; length > 0; length--)
    722c:	08 94       	sec
    722e:	e1 08       	sbc	r14, r1
    7230:	f1 08       	sbc	r15, r1
    7232:	01 09       	sbc	r16, r1
    7234:	11 09       	sbc	r17, r1
    7236:	e1 14       	cp	r14, r1
    7238:	f1 04       	cpc	r15, r1
    723a:	01 05       	cpc	r16, r1
    723c:	11 05       	cpc	r17, r1
    723e:	09 f0       	breq	.+2      	; 0x7242 <crc16_block+0x9c>
    7240:	c5 cf       	rjmp	.-118    	; 0x71cc <crc16_block+0x26>
                
                bc++;
        }
        
        return crc;
}
    7242:	ce 01       	movw	r24, r28
    7244:	df 91       	pop	r29
    7246:	cf 91       	pop	r28
    7248:	1f 91       	pop	r17
    724a:	0f 91       	pop	r16
    724c:	ff 90       	pop	r15
    724e:	ef 90       	pop	r14
    7250:	df 90       	pop	r13
    7252:	cf 90       	pop	r12
    7254:	bf 90       	pop	r11
    7256:	af 90       	pop	r10
    7258:	08 95       	ret

0000725a <install_firmware>:

void install_firmware()
{
    725a:	cf 92       	push	r12
    725c:	df 92       	push	r13
    725e:	ef 92       	push	r14
    7260:	ff 92       	push	r15
    7262:	0f 93       	push	r16
    7264:	1f 93       	push	r17
        uint16_t crc;
        uint16_t crc2;
        
        // read last block
        Flash_ReadFlashPage(buffer, XB_APP_TEMP_START + XB_APP_TEMP_SIZE - SPM_PAGESIZE);
    7266:	81 e0       	ldi	r24, 0x01	; 1
    7268:	91 e0       	ldi	r25, 0x01	; 1
    726a:	40 e8       	ldi	r20, 0x80	; 128
    726c:	5f e6       	ldi	r21, 0x6F	; 111
    726e:	60 e0       	ldi	r22, 0x00	; 0
    7270:	70 e0       	ldi	r23, 0x00	; 0
    7272:	0e 94 e1 3c 	call	0x79c2	; 0x79c2 <Flash_ReadFlashPage>
        
        // check for install command
        if (buffer[SPM_PAGESIZE-6] == 'X' && buffer[SPM_PAGESIZE-5] == 'B' &&
    7276:	80 91 7b 01 	lds	r24, 0x017B
    727a:	88 35       	cpi	r24, 0x58	; 88
    727c:	09 f0       	breq	.+2      	; 0x7280 <install_firmware+0x26>
    727e:	f4 c0       	rjmp	.+488    	; 0x7468 <install_firmware+0x20e>
    7280:	80 91 7c 01 	lds	r24, 0x017C
    7284:	82 34       	cpi	r24, 0x42	; 66
    7286:	09 f0       	breq	.+2      	; 0x728a <install_firmware+0x30>
    7288:	ef c0       	rjmp	.+478    	; 0x7468 <install_firmware+0x20e>
    728a:	80 91 7d 01 	lds	r24, 0x017D
    728e:	89 34       	cpi	r24, 0x49	; 73
    7290:	09 f0       	breq	.+2      	; 0x7294 <install_firmware+0x3a>
    7292:	ea c0       	rjmp	.+468    	; 0x7468 <install_firmware+0x20e>
    7294:	80 91 7e 01 	lds	r24, 0x017E
    7298:	86 34       	cpi	r24, 0x46	; 70
    729a:	09 f0       	breq	.+2      	; 0x729e <install_firmware+0x44>
    729c:	e5 c0       	rjmp	.+458    	; 0x7468 <install_firmware+0x20e>
                buffer[SPM_PAGESIZE-4] == 'I' && buffer[SPM_PAGESIZE-3] == 'F')
        {
                crc = (buffer[SPM_PAGESIZE-2] << 8) | buffer[SPM_PAGESIZE-1];
    729e:	f0 90 7f 01 	lds	r15, 0x017F
    72a2:	00 91 80 01 	lds	r16, 0x0180
                
                // skip last 6 bytes as they are the install command
                crc2 = crc16_block(XB_APP_TEMP_START, XB_APP_TEMP_SIZE - 6);
    72a6:	60 e0       	ldi	r22, 0x00	; 0
    72a8:	78 e3       	ldi	r23, 0x38	; 56
    72aa:	80 e0       	ldi	r24, 0x00	; 0
    72ac:	90 e0       	ldi	r25, 0x00	; 0
    72ae:	2a ef       	ldi	r18, 0xFA	; 250
    72b0:	37 e3       	ldi	r19, 0x37	; 55
    72b2:	40 e0       	ldi	r20, 0x00	; 0
    72b4:	50 e0       	ldi	r21, 0x00	; 0
    72b6:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <crc16_block>
    72ba:	2f ef       	ldi	r18, 0xFF	; 255
    72bc:	82 27       	eor	r24, r18
    72be:	38 2f       	mov	r19, r24
    72c0:	32 95       	swap	r19
    72c2:	38 27       	eor	r19, r24
    72c4:	03 2e       	mov	r0, r19
    72c6:	36 95       	lsr	r19
    72c8:	36 95       	lsr	r19
    72ca:	30 25       	eor	r19, r0
    72cc:	03 2e       	mov	r0, r19
    72ce:	36 95       	lsr	r19
    72d0:	30 25       	eor	r19, r0
    72d2:	37 70       	andi	r19, 0x07	; 7
    72d4:	08 2e       	mov	r0, r24
    72d6:	89 2f       	mov	r24, r25
    72d8:	36 95       	lsr	r19
    72da:	07 94       	ror	r0
    72dc:	37 95       	ror	r19
    72de:	90 2d       	mov	r25, r0
    72e0:	83 27       	eor	r24, r19
    72e2:	06 94       	lsr	r0
    72e4:	37 95       	ror	r19
    72e6:	90 25       	eor	r25, r0
    72e8:	83 27       	eor	r24, r19
    72ea:	82 27       	eor	r24, r18
    72ec:	38 2f       	mov	r19, r24
    72ee:	32 95       	swap	r19
    72f0:	38 27       	eor	r19, r24
    72f2:	03 2e       	mov	r0, r19
    72f4:	36 95       	lsr	r19
    72f6:	36 95       	lsr	r19
    72f8:	30 25       	eor	r19, r0
    72fa:	03 2e       	mov	r0, r19
    72fc:	36 95       	lsr	r19
    72fe:	30 25       	eor	r19, r0
    7300:	37 70       	andi	r19, 0x07	; 7
    7302:	08 2e       	mov	r0, r24
    7304:	89 2f       	mov	r24, r25
    7306:	36 95       	lsr	r19
    7308:	07 94       	ror	r0
    730a:	37 95       	ror	r19
    730c:	90 2d       	mov	r25, r0
    730e:	83 27       	eor	r24, r19
    7310:	06 94       	lsr	r0
    7312:	37 95       	ror	r19
    7314:	90 25       	eor	r25, r0
    7316:	83 27       	eor	r24, r19
    7318:	82 27       	eor	r24, r18
    731a:	38 2f       	mov	r19, r24
    731c:	32 95       	swap	r19
    731e:	38 27       	eor	r19, r24
    7320:	03 2e       	mov	r0, r19
    7322:	36 95       	lsr	r19
    7324:	36 95       	lsr	r19
    7326:	30 25       	eor	r19, r0
    7328:	03 2e       	mov	r0, r19
    732a:	36 95       	lsr	r19
    732c:	30 25       	eor	r19, r0
    732e:	37 70       	andi	r19, 0x07	; 7
    7330:	08 2e       	mov	r0, r24
    7332:	89 2f       	mov	r24, r25
    7334:	36 95       	lsr	r19
    7336:	07 94       	ror	r0
    7338:	37 95       	ror	r19
    733a:	90 2d       	mov	r25, r0
    733c:	83 27       	eor	r24, r19
    733e:	06 94       	lsr	r0
    7340:	37 95       	ror	r19
    7342:	90 25       	eor	r25, r0
    7344:	83 27       	eor	r24, r19
    7346:	82 27       	eor	r24, r18
    7348:	38 2f       	mov	r19, r24
    734a:	32 95       	swap	r19
    734c:	38 27       	eor	r19, r24
    734e:	03 2e       	mov	r0, r19
    7350:	36 95       	lsr	r19
    7352:	36 95       	lsr	r19
    7354:	30 25       	eor	r19, r0
    7356:	03 2e       	mov	r0, r19
    7358:	36 95       	lsr	r19
    735a:	30 25       	eor	r19, r0
    735c:	37 70       	andi	r19, 0x07	; 7
    735e:	08 2e       	mov	r0, r24
    7360:	89 2f       	mov	r24, r25
    7362:	36 95       	lsr	r19
    7364:	07 94       	ror	r0
    7366:	37 95       	ror	r19
    7368:	90 2d       	mov	r25, r0
    736a:	83 27       	eor	r24, r19
    736c:	06 94       	lsr	r0
    736e:	37 95       	ror	r19
    7370:	90 25       	eor	r25, r0
    7372:	83 27       	eor	r24, r19
    7374:	82 27       	eor	r24, r18
    7376:	38 2f       	mov	r19, r24
    7378:	32 95       	swap	r19
    737a:	38 27       	eor	r19, r24
    737c:	03 2e       	mov	r0, r19
    737e:	36 95       	lsr	r19
    7380:	36 95       	lsr	r19
    7382:	30 25       	eor	r19, r0
    7384:	03 2e       	mov	r0, r19
    7386:	36 95       	lsr	r19
    7388:	30 25       	eor	r19, r0
    738a:	37 70       	andi	r19, 0x07	; 7
    738c:	08 2e       	mov	r0, r24
    738e:	89 2f       	mov	r24, r25
    7390:	36 95       	lsr	r19
    7392:	07 94       	ror	r0
    7394:	37 95       	ror	r19
    7396:	90 2d       	mov	r25, r0
    7398:	83 27       	eor	r24, r19
    739a:	06 94       	lsr	r0
    739c:	37 95       	ror	r19
    739e:	90 25       	eor	r25, r0
    73a0:	83 27       	eor	r24, r19
    73a2:	82 27       	eor	r24, r18
    73a4:	28 2f       	mov	r18, r24
    73a6:	22 95       	swap	r18
    73a8:	28 27       	eor	r18, r24
    73aa:	02 2e       	mov	r0, r18
    73ac:	26 95       	lsr	r18
    73ae:	26 95       	lsr	r18
    73b0:	20 25       	eor	r18, r0
    73b2:	02 2e       	mov	r0, r18
    73b4:	26 95       	lsr	r18
    73b6:	20 25       	eor	r18, r0
    73b8:	27 70       	andi	r18, 0x07	; 7
    73ba:	08 2e       	mov	r0, r24
    73bc:	89 2f       	mov	r24, r25
    73be:	26 95       	lsr	r18
    73c0:	07 94       	ror	r0
    73c2:	27 95       	ror	r18
    73c4:	90 2d       	mov	r25, r0
    73c6:	82 27       	eor	r24, r18
    73c8:	06 94       	lsr	r0
    73ca:	27 95       	ror	r18
    73cc:	90 25       	eor	r25, r0
    73ce:	82 27       	eor	r24, r18
                
                // crc last 6 bytes as empty
                for (int i = 0; i < 6; i++)
                        crc2 = _crc16_update(crc2, 0xff);
                
                if (crc == crc2)
    73d0:	3f 2d       	mov	r19, r15
    73d2:	20 e0       	ldi	r18, 0x00	; 0
    73d4:	10 e0       	ldi	r17, 0x00	; 0
    73d6:	20 2b       	or	r18, r16
    73d8:	31 2b       	or	r19, r17
    73da:	28 17       	cp	r18, r24
    73dc:	39 07       	cpc	r19, r25
    73de:	09 f0       	breq	.+2      	; 0x73e2 <install_firmware+0x188>
    73e0:	41 c0       	rjmp	.+130    	; 0x7464 <install_firmware+0x20a>
    73e2:	ee 24       	eor	r14, r14
    73e4:	ff 24       	eor	r15, r15
    73e6:	87 01       	movw	r16, r14
                        {
                                #ifdef USE_LED
#ifdef __AVR_XMEGA__
                                LED_PORT.OUTTGL = (1 << LED_PIN);
#else // __AVR_XMEGA__
                                LED_PORT ^= (1 << LED_PIN);
    73e8:	88 e0       	ldi	r24, 0x08	; 8
    73ea:	c8 2e       	mov	r12, r24
                                Flash_ReadFlashPage(buffer, ptr + XB_APP_TEMP_START);
                                // if it's the last page, clear out the last 6 bytes
                                if (ptr >= XB_APP_SIZE - SPM_PAGESIZE)
                                {
                                        for (int i = SPM_PAGESIZE-6; i < SPM_PAGESIZE; i++)
                                                buffer[i] = 0xff;
    73ec:	dd 24       	eor	r13, r13
    73ee:	da 94       	dec	r13
                        {
                                #ifdef USE_LED
#ifdef __AVR_XMEGA__
                                LED_PORT.OUTTGL = (1 << LED_PIN);
#else // __AVR_XMEGA__
                                LED_PORT ^= (1 << LED_PIN);
    73f0:	8b b1       	in	r24, 0x0b	; 11
    73f2:	8c 25       	eor	r24, r12
    73f4:	8b b9       	out	0x0b, r24	; 11
#endif // __AVR_XMEGA__
                                #endif // USE_LED
                                
                                Flash_ReadFlashPage(buffer, ptr + XB_APP_TEMP_START);
    73f6:	b8 01       	movw	r22, r16
    73f8:	a7 01       	movw	r20, r14
    73fa:	40 50       	subi	r20, 0x00	; 0
    73fc:	58 4c       	sbci	r21, 0xC8	; 200
    73fe:	6f 4f       	sbci	r22, 0xFF	; 255
    7400:	7f 4f       	sbci	r23, 0xFF	; 255
    7402:	81 e0       	ldi	r24, 0x01	; 1
    7404:	91 e0       	ldi	r25, 0x01	; 1
    7406:	0e 94 e1 3c 	call	0x79c2	; 0x79c2 <Flash_ReadFlashPage>
                                // if it's the last page, clear out the last 6 bytes
                                if (ptr >= XB_APP_SIZE - SPM_PAGESIZE)
    740a:	80 e8       	ldi	r24, 0x80	; 128
    740c:	e8 16       	cp	r14, r24
    740e:	87 e3       	ldi	r24, 0x37	; 55
    7410:	f8 06       	cpc	r15, r24
    7412:	80 e0       	ldi	r24, 0x00	; 0
    7414:	08 07       	cpc	r16, r24
    7416:	80 e0       	ldi	r24, 0x00	; 0
    7418:	18 07       	cpc	r17, r24
    741a:	60 f0       	brcs	.+24     	; 0x7434 <install_firmware+0x1da>
                                {
                                        for (int i = SPM_PAGESIZE-6; i < SPM_PAGESIZE; i++)
                                                buffer[i] = 0xff;
    741c:	d0 92 7b 01 	sts	0x017B, r13
    7420:	d0 92 7c 01 	sts	0x017C, r13
    7424:	d0 92 7d 01 	sts	0x017D, r13
    7428:	d0 92 7e 01 	sts	0x017E, r13
    742c:	d0 92 7f 01 	sts	0x017F, r13
    7430:	d0 92 80 01 	sts	0x0180, r13
                                }
                                Flash_ProgramPage(ptr, buffer, 1);
    7434:	c8 01       	movw	r24, r16
    7436:	b7 01       	movw	r22, r14
    7438:	41 e0       	ldi	r20, 0x01	; 1
    743a:	51 e0       	ldi	r21, 0x01	; 1
    743c:	21 e0       	ldi	r18, 0x01	; 1
    743e:	0e 94 fe 3c 	call	0x79fc	; 0x79fc <Flash_ProgramPage>
                for (int i = 0; i < 6; i++)
                        crc2 = _crc16_update(crc2, 0xff);
                
                if (crc == crc2)
                {
                        for (uint32_t ptr = 0; ptr < XB_APP_SIZE; ptr += SPM_PAGESIZE)
    7442:	80 e8       	ldi	r24, 0x80	; 128
    7444:	90 e0       	ldi	r25, 0x00	; 0
    7446:	a0 e0       	ldi	r26, 0x00	; 0
    7448:	b0 e0       	ldi	r27, 0x00	; 0
    744a:	e8 0e       	add	r14, r24
    744c:	f9 1e       	adc	r15, r25
    744e:	0a 1f       	adc	r16, r26
    7450:	1b 1f       	adc	r17, r27
    7452:	90 e0       	ldi	r25, 0x00	; 0
    7454:	e9 16       	cp	r14, r25
    7456:	98 e3       	ldi	r25, 0x38	; 56
    7458:	f9 06       	cpc	r15, r25
    745a:	90 e0       	ldi	r25, 0x00	; 0
    745c:	09 07       	cpc	r16, r25
    745e:	90 e0       	ldi	r25, 0x00	; 0
    7460:	19 07       	cpc	r17, r25
    7462:	31 f6       	brne	.-116    	; 0x73f0 <install_firmware+0x196>
                                }
                                Flash_ProgramPage(ptr, buffer, 1);
                        }
                }
                
                xboot_app_temp_erase();
    7464:	0e 94 96 3d 	call	0x7b2c	; 0x7b2c <xboot_app_temp_erase>
        }
}
    7468:	1f 91       	pop	r17
    746a:	0f 91       	pop	r16
    746c:	ff 90       	pop	r15
    746e:	ef 90       	pop	r14
    7470:	df 90       	pop	r13
    7472:	cf 90       	pop	r12
    7474:	08 95       	ret

00007476 <BlockRead>:
}



void BlockRead(unsigned int size, unsigned char mem, ADDR_T *address)
{
    7476:	0f 93       	push	r16
    7478:	1f 93       	push	r17
    747a:	cf 93       	push	r28
    747c:	df 93       	push	r29
    747e:	8c 01       	movw	r16, r24
    7480:	ea 01       	movw	r28, r20
        int offset = 0;
        int size2 = size;
        
        // EEPROM memory type.
        
        if (mem == MEM_EEPROM) // Read EEPROM
    7482:	65 34       	cpi	r22, 0x45	; 69
    7484:	a9 f4       	brne	.+42     	; 0x74b0 <BlockRead+0x3a>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
    7486:	68 81       	ld	r22, Y
    7488:	79 81       	ldd	r23, Y+1	; 0x01
    748a:	81 e0       	ldi	r24, 0x01	; 1
    748c:	91 e0       	ldi	r25, 0x01	; 1
    748e:	a8 01       	movw	r20, r16
    7490:	24 e9       	ldi	r18, 0x94	; 148
    7492:	38 e3       	ldi	r19, 0x38	; 56
    7494:	0e 94 5c 38 	call	0x70b8	; 0x70b8 <__eerd_block>
        {
                EEPROM_read_block(*address, buffer, size);
                (*address) += size;
    7498:	98 01       	movw	r18, r16
    749a:	40 e0       	ldi	r20, 0x00	; 0
    749c:	50 e0       	ldi	r21, 0x00	; 0
    749e:	88 81       	ld	r24, Y
    74a0:	99 81       	ldd	r25, Y+1	; 0x01
    74a2:	aa 81       	ldd	r26, Y+2	; 0x02
    74a4:	bb 81       	ldd	r27, Y+3	; 0x03
    74a6:	82 0f       	add	r24, r18
    74a8:	93 1f       	adc	r25, r19
    74aa:	a4 1f       	adc	r26, r20
    74ac:	b5 1f       	adc	r27, r21
    74ae:	30 c0       	rjmp	.+96     	; 0x7510 <BlockRead+0x9a>
        
        // Flash memory type.
#ifdef __AVR_XMEGA__
        else if (mem == MEM_FLASH || mem == MEM_USERSIG || mem == MEM_PRODSIG)
#else // __AVR_XMEGA__
        else if (mem == MEM_FLASH)
    74b0:	66 34       	cpi	r22, 0x46	; 70
    74b2:	09 f0       	breq	.+2      	; 0x74b6 <BlockRead+0x40>
    74b4:	3e c0       	rjmp	.+124    	; 0x7532 <BlockRead+0xbc>
#endif // __AVR_XMEGA__
        {
                (*address) <<= 1; // Convert address to bytes temporarily.
    74b6:	88 81       	ld	r24, Y
    74b8:	99 81       	ldd	r25, Y+1	; 0x01
    74ba:	aa 81       	ldd	r26, Y+2	; 0x02
    74bc:	bb 81       	ldd	r27, Y+3	; 0x03
    74be:	88 0f       	add	r24, r24
    74c0:	99 1f       	adc	r25, r25
    74c2:	aa 1f       	adc	r26, r26
    74c4:	bb 1f       	adc	r27, r27
    74c6:	88 83       	st	Y, r24
    74c8:	99 83       	std	Y+1, r25	; 0x01
    74ca:	aa 83       	std	Y+2, r26	; 0x02
    74cc:	bb 83       	std	Y+3, r27	; 0x03
    74ce:	21 e0       	ldi	r18, 0x01	; 1
    74d0:	31 e0       	ldi	r19, 0x01	; 1
                        
                        Flash_WaitForSPM();
                        
                        (*address)++;    // Select next word in memory.
                        size--;          // Subtract two bytes from number of bytes to read
                } while (size);         // Repeat until all block has been read
    74d2:	a8 01       	movw	r20, r16
    74d4:	42 0f       	add	r20, r18
    74d6:	53 1f       	adc	r21, r19
                        else if (mem == MEM_PRODSIG)
                        {
                                buffer[offset++] = SP_ReadCalibrationByte(*address);
                        }
#else // __AVR_XMEGA__
                        buffer[offset++] = Flash_ReadByte(*address);
    74d8:	e8 81       	ld	r30, Y
    74da:	f9 81       	ldd	r31, Y+1	; 0x01
    74dc:	e4 91       	lpm	r30, Z+
    74de:	d9 01       	movw	r26, r18
    74e0:	ec 93       	st	X, r30
#endif // __AVR_XMEGA__
                        
                        Flash_WaitForSPM();
    74e2:	07 b6       	in	r0, 0x37	; 55
    74e4:	00 fc       	sbrc	r0, 0
    74e6:	fd cf       	rjmp	.-6      	; 0x74e2 <BlockRead+0x6c>
                        
                        (*address)++;    // Select next word in memory.
    74e8:	88 81       	ld	r24, Y
    74ea:	99 81       	ldd	r25, Y+1	; 0x01
    74ec:	aa 81       	ldd	r26, Y+2	; 0x02
    74ee:	bb 81       	ldd	r27, Y+3	; 0x03
    74f0:	01 96       	adiw	r24, 0x01	; 1
    74f2:	a1 1d       	adc	r26, r1
    74f4:	b1 1d       	adc	r27, r1
    74f6:	88 83       	st	Y, r24
    74f8:	99 83       	std	Y+1, r25	; 0x01
    74fa:	aa 83       	std	Y+2, r26	; 0x02
    74fc:	bb 83       	std	Y+3, r27	; 0x03
    74fe:	2f 5f       	subi	r18, 0xFF	; 255
    7500:	3f 4f       	sbci	r19, 0xFF	; 255
                        size--;          // Subtract two bytes from number of bytes to read
                } while (size);         // Repeat until all block has been read
    7502:	24 17       	cp	r18, r20
    7504:	35 07       	cpc	r19, r21
    7506:	41 f7       	brne	.-48     	; 0x74d8 <BlockRead+0x62>
                
                (*address) >>= 1;       // Convert address back to Flash words again.
    7508:	b6 95       	lsr	r27
    750a:	a7 95       	ror	r26
    750c:	97 95       	ror	r25
    750e:	87 95       	ror	r24
    7510:	88 83       	st	Y, r24
    7512:	99 83       	std	Y+1, r25	; 0x01
    7514:	aa 83       	std	Y+2, r26	; 0x02
    7516:	bb 83       	std	Y+3, r27	; 0x03
    7518:	c0 e0       	ldi	r28, 0x00	; 0
    751a:	d0 e0       	ldi	r29, 0x00	; 0
    751c:	07 c0       	rjmp	.+14     	; 0x752c <BlockRead+0xb6>
                clear_buffer();
        
        // send bytes
        for (int i = 0; i < size2; i++)
        {
                send_char(buffer[i]);
    751e:	fe 01       	movw	r30, r28
    7520:	ef 5f       	subi	r30, 0xFF	; 255
    7522:	fe 4f       	sbci	r31, 0xFE	; 254
    7524:	80 81       	ld	r24, Z
    7526:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                0
        )
                clear_buffer();
        
        // send bytes
        for (int i = 0; i < size2; i++)
    752a:	21 96       	adiw	r28, 0x01	; 1
    752c:	c0 17       	cp	r28, r16
    752e:	d1 07       	cpc	r29, r17
    7530:	b4 f3       	brlt	.-20     	; 0x751e <BlockRead+0xa8>
        {
                send_char(buffer[i]);
        }
        
}
    7532:	df 91       	pop	r29
    7534:	cf 91       	pop	r28
    7536:	1f 91       	pop	r17
    7538:	0f 91       	pop	r16
    753a:	08 95       	ret

0000753c <BlockLoad>:
                *(ptr++) = 0xff;
        }
}

unsigned char BlockLoad(unsigned int size, unsigned char mem, ADDR_T *address)
{
    753c:	df 92       	push	r13
    753e:	ef 92       	push	r14
    7540:	ff 92       	push	r15
    7542:	0f 93       	push	r16
    7544:	1f 93       	push	r17
    7546:	cf 93       	push	r28
    7548:	df 93       	push	r29
    754a:	8c 01       	movw	r16, r24
    754c:	d6 2e       	mov	r13, r22
    754e:	7a 01       	movw	r14, r20
    7550:	c0 e0       	ldi	r28, 0x00	; 0
    7552:	d0 e0       	ldi	r29, 0x00	; 0
        // fill up buffer
        for (int i = 0; i < SPM_PAGESIZE; i++)
        {
                char c = 0xff;
                
                if (i < size)
    7554:	c0 17       	cp	r28, r16
    7556:	d1 07       	cpc	r29, r17
    7558:	10 f0       	brcs	.+4      	; 0x755e <BlockLoad+0x22>
    755a:	8f ef       	ldi	r24, 0xFF	; 255
    755c:	02 c0       	rjmp	.+4      	; 0x7562 <BlockLoad+0x26>
                        c = get_char();
    755e:	0e 94 a9 38 	call	0x7152	; 0x7152 <get_char>
                
                buffer[i] = c;
    7562:	fe 01       	movw	r30, r28
    7564:	ef 5f       	subi	r30, 0xFF	; 255
    7566:	fe 4f       	sbci	r31, 0xFE	; 254
    7568:	80 83       	st	Z, r24
        #ifdef USE_WATCHDOG
        WDT_Reset();
        #endif // USE_WATCHDOG
        
        // fill up buffer
        for (int i = 0; i < SPM_PAGESIZE; i++)
    756a:	21 96       	adiw	r28, 0x01	; 1
    756c:	c0 38       	cpi	r28, 0x80	; 128
    756e:	d1 05       	cpc	r29, r1
    7570:	89 f7       	brne	.-30     	; 0x7554 <BlockLoad+0x18>
                
                buffer[i] = c;
        }
        
        // EEPROM memory type.
        if(mem == MEM_EEPROM)
    7572:	85 e4       	ldi	r24, 0x45	; 69
    7574:	d8 16       	cp	r13, r24
    7576:	d9 f4       	brne	.+54     	; 0x75ae <BlockLoad+0x72>
 */
static __inline__ void
eeprom_write_block (const void *__src, void *__dst, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eewr_block (__dst, __src, __n, eeprom_write_byte);
    7578:	f7 01       	movw	r30, r14
    757a:	80 81       	ld	r24, Z
    757c:	91 81       	ldd	r25, Z+1	; 0x01
    757e:	61 e0       	ldi	r22, 0x01	; 1
    7580:	71 e0       	ldi	r23, 0x01	; 1
    7582:	a8 01       	movw	r20, r16
    7584:	2c e9       	ldi	r18, 0x9C	; 156
    7586:	38 e3       	ldi	r19, 0x38	; 56
    7588:	0e 94 78 38 	call	0x70f0	; 0x70f0 <__eewr_block>
        {
                EEPROM_write_block(*address, buffer, size);
                (*address) += size;
    758c:	98 01       	movw	r18, r16
    758e:	40 e0       	ldi	r20, 0x00	; 0
    7590:	50 e0       	ldi	r21, 0x00	; 0
    7592:	f7 01       	movw	r30, r14
    7594:	80 81       	ld	r24, Z
    7596:	91 81       	ldd	r25, Z+1	; 0x01
    7598:	a2 81       	ldd	r26, Z+2	; 0x02
    759a:	b3 81       	ldd	r27, Z+3	; 0x03
    759c:	82 0f       	add	r24, r18
    759e:	93 1f       	adc	r25, r19
    75a0:	a4 1f       	adc	r26, r20
    75a2:	b5 1f       	adc	r27, r21
    75a4:	80 83       	st	Z, r24
    75a6:	91 83       	std	Z+1, r25	; 0x01
    75a8:	a2 83       	std	Z+2, r26	; 0x02
    75aa:	b3 83       	std	Z+3, r27	; 0x03
    75ac:	20 c0       	rjmp	.+64     	; 0x75ee <BlockLoad+0xb2>
        
        // Flash memory type
#ifdef __AVR_XMEGA__
        else if (mem == MEM_FLASH || mem == MEM_USERSIG)
#else // __AVR_XMEGA__
        else if (mem == MEM_FLASH)
    75ae:	f6 e4       	ldi	r31, 0x46	; 70
    75b0:	df 16       	cp	r13, r31
    75b2:	11 f0       	breq	.+4      	; 0x75b8 <BlockLoad+0x7c>
    75b4:	8f e3       	ldi	r24, 0x3F	; 63
    75b6:	1c c0       	rjmp	.+56     	; 0x75f0 <BlockLoad+0xb4>
#endif // __AVR_XMEGA__
        {
                // NOTE: For flash programming, 'address' is given in words.
                tempaddress = (*address) << 1;  // Store address in page.
    75b8:	f7 01       	movw	r30, r14
    75ba:	60 81       	ld	r22, Z
    75bc:	71 81       	ldd	r23, Z+1	; 0x01
    75be:	82 81       	ldd	r24, Z+2	; 0x02
    75c0:	93 81       	ldd	r25, Z+3	; 0x03
                
                (*address) += size >> 1;
    75c2:	16 95       	lsr	r17
    75c4:	07 95       	ror	r16
    75c6:	98 01       	movw	r18, r16
    75c8:	40 e0       	ldi	r20, 0x00	; 0
    75ca:	50 e0       	ldi	r21, 0x00	; 0
    75cc:	26 0f       	add	r18, r22
    75ce:	37 1f       	adc	r19, r23
    75d0:	48 1f       	adc	r20, r24
    75d2:	59 1f       	adc	r21, r25
    75d4:	20 83       	st	Z, r18
    75d6:	31 83       	std	Z+1, r19	; 0x01
    75d8:	42 83       	std	Z+2, r20	; 0x02
    75da:	53 83       	std	Z+3, r21	; 0x03
                        Flash_WaitForSPM();
                }
                
#else // __AVR_XMEGA__
                #ifdef ENABLE_FLASH_ERASE_WRITE
                Flash_ProgramPage(tempaddress, buffer, 1);
    75dc:	66 0f       	add	r22, r22
    75de:	77 1f       	adc	r23, r23
    75e0:	88 1f       	adc	r24, r24
    75e2:	99 1f       	adc	r25, r25
    75e4:	41 e0       	ldi	r20, 0x01	; 1
    75e6:	51 e0       	ldi	r21, 0x01	; 1
    75e8:	21 e0       	ldi	r18, 0x01	; 1
    75ea:	0e 94 fe 3c 	call	0x79fc	; 0x79fc <Flash_ProgramPage>
    75ee:	8d e0       	ldi	r24, 0x0D	; 13
        // Invalid memory type?
        else
        {
                return REPLY_ERROR;
        }
}
    75f0:	df 91       	pop	r29
    75f2:	cf 91       	pop	r28
    75f4:	1f 91       	pop	r17
    75f6:	0f 91       	pop	r16
    75f8:	ff 90       	pop	r15
    75fa:	ef 90       	pop	r14
    75fc:	df 90       	pop	r13
    75fe:	08 95       	ret

00007600 <main>:
unsigned char protected;
#endif // NEED_CODE_PROTECTION

// Main code
int main(void)
{
    7600:	5f 92       	push	r5
    7602:	6f 92       	push	r6
    7604:	7f 92       	push	r7
    7606:	8f 92       	push	r8
    7608:	9f 92       	push	r9
    760a:	af 92       	push	r10
    760c:	bf 92       	push	r11
    760e:	cf 92       	push	r12
    7610:	df 92       	push	r13
    7612:	ef 92       	push	r14
    7614:	ff 92       	push	r15
    7616:	0f 93       	push	r16
    7618:	1f 93       	push	r17
    761a:	df 93       	push	r29
    761c:	cf 93       	push	r28
    761e:	00 d0       	rcall	.+0      	; 0x7620 <main+0x20>
    7620:	00 d0       	rcall	.+0      	; 0x7622 <main+0x22>
    7622:	cd b7       	in	r28, 0x3d	; 61
    7624:	de b7       	in	r29, 0x3e	; 62
        ADDR_T address = 0;
    7626:	19 82       	std	Y+1, r1	; 0x01
    7628:	1a 82       	std	Y+2, r1	; 0x02
    762a:	1b 82       	std	Y+3, r1	; 0x03
    762c:	1c 82       	std	Y+4, r1	; 0x04
        
        #ifdef USE_I2C_ADDRESS_NEGOTIATION
        unsigned short devid_bit;
        #endif // USE_I2C_ADDRESS_NEGOTIATION
        
        comm_mode = MODE_UNDEF;
    762e:	10 92 00 01 	sts	0x0100, r1
        
#else // __AVR_XMEGA__
        
        #ifdef USE_LED
        // Initialize LED pin
        LED_PORT_DDR |= (1 << LED_PIN);
    7632:	53 9a       	sbi	0x0a, 3	; 10
        #if LED_PIN_INV
        LED_PORT &= ~(1 << LED_PIN);
        #else
        LED_PORT |= (1 << LED_PIN);
    7634:	5b 9a       	sbi	0x0b, 3	; 11
        
#else // __AVR_XMEGA__
        
        #ifdef USE_ENTER_PIN
        // Make sure it's an input
        ENTER_PORT_DDR &= ~(1 << ENTER_PIN);
    7636:	3c 98       	cbi	0x07, 4	; 7
        #if ENTER_PIN_PUEN
        // Enable bootloader entry pin pullup
        ENTER_PORT |= (1 << ENTER_PIN);
    7638:	44 9a       	sbi	0x08, 4	; 8
        
#endif // __AVR_XMEGA__
        
        #ifdef USE_UART
        // Initialize UART
        uart_init();
    763a:	0e 94 54 3d 	call	0x7aa8	; 0x7aa8 <uart_init>
        
#else // __AVR_XMEGA__
        
        #ifdef UART_RX_PUEN
        // Enable RX pin pullup
        UART_PORT |= (1 << UART_RX_PIN);
    763e:	58 9a       	sbi	0x0b, 0	; 11
        #endif // USE_UART_EN_PIN
        
#else // __AVR_XMEGA__
        
        #ifdef USE_UART_EN_PIN
        UART_EN_PORT_DDR |= (1 << UART_EN_PIN);
    7640:	52 9a       	sbi	0x0a, 2	; 10
        #if UART_EN_INV
        UART_EN_PORT |= (1 << UART_EN_PIN);
        #else // UART_PIN_INV
        UART_EN_PORT &= ~(1 << UART_EN_PIN);
    7642:	5a 98       	cbi	0x0b, 2	; 11
        fifo_init();
        #endif // USE_FIFO
        
#ifndef __AVR_XMEGA__
        // ATMEGA must reset via watchdog, so turn it off
        MCUSR = 0;
    7644:	14 be       	out	0x34, r1	; 52
        wdt_disable();
    7646:	88 e1       	ldi	r24, 0x18	; 24
    7648:	0f b6       	in	r0, 0x3f	; 63
    764a:	f8 94       	cli
    764c:	80 93 60 00 	sts	0x0060, r24
    7650:	10 92 60 00 	sts	0x0060, r1
    7654:	0f be       	out	0x3f, r0	; 63
	...
                // Check entry pin state
#ifdef __AVR_XMEGA__
                if ((ENTER_PORT.IN & (1 << ENTER_PIN)) == (ENTER_PIN_STATE ? (1 << ENTER_PIN) : 0))
                        in_bootloader = 1;
#else // __AVR_XMEGA__
                if ((ENTER_PORT_PIN & (1 << ENTER_PIN)) == (ENTER_PIN_STATE ? (1 << ENTER_PIN) : 0))
    765e:	96 b1       	in	r25, 0x06	; 6
                #ifdef USE_ENTER_UART
                // Check for received character
                #ifdef ENTER_UART_NEED_SYNC
                if (uart_char_received() && (uart_cur_char() == CMD_SYNC))
                #else // ENTER_UART_NEED_SYNC
                if (uart_char_received())
    7660:	80 91 c0 00 	lds	r24, 0x00C0
    7664:	87 fd       	sbrc	r24, 7
    7666:	06 c0       	rjmp	.+12     	; 0x7674 <main+0x74>
    7668:	89 2f       	mov	r24, r25
    766a:	82 95       	swap	r24
    766c:	8f 70       	andi	r24, 0x0F	; 15
    766e:	80 95       	com	r24
    7670:	81 70       	andi	r24, 0x01	; 1
    7672:	03 c0       	rjmp	.+6      	; 0x767a <main+0x7a>
                #endif // ENTER_UART_NEED_SYNC
                {
                        in_bootloader = 1;
                        comm_mode = MODE_UART;
    7674:	81 e0       	ldi	r24, 0x01	; 1
    7676:	80 93 00 01 	sts	0x0100, r24
                // End main trigger section
                
#ifdef __AVR_XMEGA__
                WDT_Reset();
#else // __AVR_XMEGA__
                wdt_reset();
    767a:	a8 95       	wdr
    767c:	cc 24       	eor	r12, r12
    767e:	dd 24       	eor	r13, r13
        while (in_bootloader) {
                #ifdef USE_LED
#ifdef __AVR_XMEGA__
                LED_PORT.OUTTGL = (1 << LED_PIN);
#else // __AVR_XMEGA__
                LED_PORT ^= (1 << LED_PIN);
    7680:	18 e0       	ldi	r17, 0x08	; 8
    7682:	61 2e       	mov	r6, r17
                // Main bootloader parser
                // check autoincrement status
                if (val == CMD_CHECK_AUTOINCREMENT)
                {
                        // yes, it is supported
                        send_char(REPLY_YES);
    7684:	55 24       	eor	r5, r5
    7686:	53 94       	inc	r5
                                // don't allow bootloader overwrite
                                send_char(REPLY_ERROR);
                        }
                        else
                        {
                                Flash_WriteApplicationPage( address << 1);
    7688:	b5 e0       	ldi	r27, 0x05	; 5
    768a:	7b 2e       	mov	r7, r27
                        // Block size
                        i = get_2bytes();
                        // Memory type
                        val = get_char();
                        // Read it
                        BlockRead(i, val, &address);
    768c:	4e 01       	movw	r8, r28
    768e:	08 94       	sec
    7690:	81 1c       	adc	r8, r1
    7692:	91 1c       	adc	r9, r1
    7694:	5d c1       	rjmp	.+698    	; 0x7950 <main+0x350>
        while (in_bootloader) {
                #ifdef USE_LED
#ifdef __AVR_XMEGA__
                LED_PORT.OUTTGL = (1 << LED_PIN);
#else // __AVR_XMEGA__
                LED_PORT ^= (1 << LED_PIN);
    7696:	8b b1       	in	r24, 0x0b	; 11
    7698:	86 25       	eor	r24, r6
    769a:	8b b9       	out	0x0b, r24	; 11
#endif // __AVR_XMEGA__
                #endif // USE_LED
                
                val = get_char();
    769c:	0e 94 a9 38 	call	0x7152	; 0x7152 <get_char>
    76a0:	98 2f       	mov	r25, r24
                WDT_Reset();
                #endif // USE_WATCHDOG
                
                // Main bootloader parser
                // check autoincrement status
                if (val == CMD_CHECK_AUTOINCREMENT)
    76a2:	81 36       	cpi	r24, 0x61	; 97
    76a4:	11 f4       	brne	.+4      	; 0x76aa <main+0xaa>
                {
                        // yes, it is supported
                        send_char(REPLY_YES);
    76a6:	89 e5       	ldi	r24, 0x59	; 89
    76a8:	4d c1       	rjmp	.+666    	; 0x7944 <main+0x344>
                }
                // Set address
                else if (val == CMD_SET_ADDRESS)
    76aa:	81 34       	cpi	r24, 0x41	; 65
    76ac:	29 f4       	brne	.+10     	; 0x76b8 <main+0xb8>
                {
                        // Read address high then low
                        address = get_2bytes();
    76ae:	0e 94 cb 38 	call	0x7196	; 0x7196 <get_2bytes>
    76b2:	a0 e0       	ldi	r26, 0x00	; 0
    76b4:	b0 e0       	ldi	r27, 0x00	; 0
    76b6:	08 c0       	rjmp	.+16     	; 0x76c8 <main+0xc8>
                        // acknowledge
                        send_char(REPLY_ACK);
                }
                // Extended address
                else if (val == CMD_SET_EXT_ADDRESS)
    76b8:	88 34       	cpi	r24, 0x48	; 72
    76ba:	61 f4       	brne	.+24     	; 0x76d4 <main+0xd4>
                {
                        // Read address high then low
                        //address = ((ADDR_T)get_char() << 16) | get_2bytes();
                        asm volatile (
    76bc:	0e 94 a9 38 	call	0x7152	; 0x7152 <get_char>
    76c0:	a8 2f       	mov	r26, r24
    76c2:	0e 94 cb 38 	call	0x7196	; 0x7196 <get_2bytes>
    76c6:	bb 27       	eor	r27, r27
    76c8:	89 83       	std	Y+1, r24	; 0x01
    76ca:	9a 83       	std	Y+2, r25	; 0x02
    76cc:	ab 83       	std	Y+3, r26	; 0x03
    76ce:	bc 83       	std	Y+4, r27	; 0x04
                                : "=r" (address)
                                :
                        );
                        
                        // acknowledge
                        send_char(REPLY_ACK);
    76d0:	8d e0       	ldi	r24, 0x0D	; 13
    76d2:	38 c1       	rjmp	.+624    	; 0x7944 <main+0x344>
                }
                // Chip erase
                else if (val == CMD_CHIP_ERASE)
    76d4:	85 36       	cpi	r24, 0x65	; 101
    76d6:	29 f4       	brne	.+10     	; 0x76e2 <main+0xe2>
                {
                        // Erase the application section
                        Flash_EraseApplicationSection();
    76d8:	0e 94 cd 3c 	call	0x799a	; 0x799a <Flash_EraseApplicationSection>
                        SP_WaitForSPM();
                        #endif // USE_WATCHDOG
#endif // __AVR_XMEGA__
                        
                        // Erase EEPROM
                        EEPROM_erase_all();
    76dc:	0e 94 40 3d 	call	0x7a80	; 0x7a80 <EEPROM_erase_all>
    76e0:	f7 cf       	rjmp	.-18     	; 0x76d0 <main+0xd0>
                        // acknowledge
                        send_char(REPLY_ACK);
                }
                #ifdef ENABLE_BLOCK_SUPPORT
                // Check block load support
                else if (val == CMD_CHECK_BLOCK_SUPPORT )
    76e2:	82 36       	cpi	r24, 0x62	; 98
    76e4:	41 f4       	brne	.+16     	; 0x76f6 <main+0xf6>
                {
                        // yes, it is supported
                        send_char(REPLY_YES);
    76e6:	89 e5       	ldi	r24, 0x59	; 89
    76e8:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        // Send block size (page size)
                        send_char((SPM_PAGESIZE >> 8) & 0xFF);
    76ec:	80 e0       	ldi	r24, 0x00	; 0
    76ee:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        send_char(SPM_PAGESIZE & 0xFF);
    76f2:	80 e8       	ldi	r24, 0x80	; 128
    76f4:	27 c1       	rjmp	.+590    	; 0x7944 <main+0x344>
                }
                // Block load
                else if (val == CMD_BLOCK_LOAD)
    76f6:	82 34       	cpi	r24, 0x42	; 66
    76f8:	89 f4       	brne	.+34     	; 0x771c <main+0x11c>
                {
                        // Block size
                        i = get_2bytes();
    76fa:	0e 94 cb 38 	call	0x7196	; 0x7196 <get_2bytes>
    76fe:	18 2f       	mov	r17, r24
    7700:	09 2f       	mov	r16, r25
    7702:	28 2f       	mov	r18, r24
    7704:	39 2f       	mov	r19, r25
    7706:	c9 01       	movw	r24, r18
    7708:	6c 01       	movw	r12, r24
                        // Memory type
                        val = get_char();
    770a:	0e 94 a9 38 	call	0x7152	; 0x7152 <get_char>
    770e:	68 2f       	mov	r22, r24
                        // Load it
                        send_char(BlockLoad(i, val, &address));
    7710:	81 2f       	mov	r24, r17
    7712:	90 2f       	mov	r25, r16
    7714:	a4 01       	movw	r20, r8
    7716:	0e 94 9e 3a 	call	0x753c	; 0x753c <BlockLoad>
    771a:	14 c1       	rjmp	.+552    	; 0x7944 <main+0x344>
                }
                // Block read
                else if (val == CMD_BLOCK_READ)
    771c:	87 36       	cpi	r24, 0x67	; 103
    771e:	89 f4       	brne	.+34     	; 0x7742 <main+0x142>
                {
                        // Block size
                        i = get_2bytes();
    7720:	0e 94 cb 38 	call	0x7196	; 0x7196 <get_2bytes>
    7724:	18 2f       	mov	r17, r24
    7726:	09 2f       	mov	r16, r25
    7728:	28 2f       	mov	r18, r24
    772a:	39 2f       	mov	r19, r25
    772c:	c9 01       	movw	r24, r18
    772e:	6c 01       	movw	r12, r24
                        // Memory type
                        val = get_char();
    7730:	0e 94 a9 38 	call	0x7152	; 0x7152 <get_char>
    7734:	68 2f       	mov	r22, r24
                        // Read it
                        BlockRead(i, val, &address);
    7736:	81 2f       	mov	r24, r17
    7738:	90 2f       	mov	r25, r16
    773a:	a4 01       	movw	r20, r8
    773c:	0e 94 3b 3a 	call	0x7476	; 0x7476 <BlockRead>
    7740:	03 c1       	rjmp	.+518    	; 0x7948 <main+0x348>
                }
                #endif // ENABLE_BLOCK_SUPPORT
                #ifdef ENABLE_FLASH_BYTE_SUPPORT
                // Read program memory byte
                else if (val == CMD_READ_BYTE)
    7742:	82 35       	cpi	r24, 0x52	; 82
    7744:	59 f4       	brne	.+22     	; 0x775c <main+0x15c>
                {
                        unsigned int w = Flash_ReadWord((address << 1));
    7746:	e9 81       	ldd	r30, Y+1	; 0x01
    7748:	fa 81       	ldd	r31, Y+2	; 0x02
    774a:	ee 0f       	add	r30, r30
    774c:	ff 1f       	adc	r31, r31
    774e:	05 91       	lpm	r16, Z+
    7750:	14 91       	lpm	r17, Z+
                        #ifdef ENABLE_CODE_PROTECTION
                        if (protected)
                                w = 0xffff;
                        #endif // ENABLE_CODE_PROTECTION
                        
                        send_char(w >> 8);
    7752:	81 2f       	mov	r24, r17
    7754:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        send_char(w);
    7758:	80 2f       	mov	r24, r16
    775a:	55 c0       	rjmp	.+170    	; 0x7806 <main+0x206>
                        
                        address++;
                }
                // Write program memory low byte
                else if (val == CMD_WRITE_LOW_BYTE)
    775c:	83 36       	cpi	r24, 0x63	; 99
    775e:	29 f4       	brne	.+10     	; 0x776a <main+0x16a>
                {
                        // get low byte
                        i = get_char();
    7760:	0e 94 a9 38 	call	0x7152	; 0x7152 <get_char>
    7764:	c8 2e       	mov	r12, r24
    7766:	dd 24       	eor	r13, r13
    7768:	b3 cf       	rjmp	.-154    	; 0x76d0 <main+0xd0>
                        send_char(REPLY_ACK);
                }
                // Write program memory high byte
                else if (val == CMD_WRITE_HIGH_BYTE)
    776a:	83 34       	cpi	r24, 0x43	; 67
    776c:	b1 f4       	brne	.+44     	; 0x779a <main+0x19a>
                {
                        // get high byte; combine
                        i |= (get_char() << 8);
    776e:	0e 94 a9 38 	call	0x7152	; 0x7152 <get_char>
    7772:	b8 2e       	mov	r11, r24
    7774:	aa 24       	eor	r10, r10
    7776:	ca 28       	or	r12, r10
    7778:	db 28       	or	r13, r11
                        Flash_LoadFlashWord((address << 1), i);
    777a:	89 81       	ldd	r24, Y+1	; 0x01
    777c:	9a 81       	ldd	r25, Y+2	; 0x02
    777e:	ab 81       	ldd	r26, Y+3	; 0x03
    7780:	bc 81       	ldd	r27, Y+4	; 0x04
    7782:	fc 01       	movw	r30, r24
    7784:	ee 0f       	add	r30, r30
    7786:	ff 1f       	adc	r31, r31
    7788:	06 01       	movw	r0, r12
    778a:	50 92 57 00 	sts	0x0057, r5
    778e:	e8 95       	spm
    7790:	11 24       	eor	r1, r1
                        address++;
    7792:	01 96       	adiw	r24, 0x01	; 1
    7794:	a1 1d       	adc	r26, r1
    7796:	b1 1d       	adc	r27, r1
    7798:	97 cf       	rjmp	.-210    	; 0x76c8 <main+0xc8>
                        send_char(REPLY_ACK);
                }
                // Write page
                else if (val == CMD_WRITE_PAGE)
    779a:	8d 36       	cpi	r24, 0x6D	; 109
    779c:	a1 f4       	brne	.+40     	; 0x77c6 <main+0x1c6>
                {
                        if (address >= (APP_SECTION_SIZE>>1))
    779e:	89 81       	ldd	r24, Y+1	; 0x01
    77a0:	9a 81       	ldd	r25, Y+2	; 0x02
    77a2:	ab 81       	ldd	r26, Y+3	; 0x03
    77a4:	bc 81       	ldd	r27, Y+4	; 0x04
    77a6:	80 30       	cpi	r24, 0x00	; 0
    77a8:	28 e3       	ldi	r18, 0x38	; 56
    77aa:	92 07       	cpc	r25, r18
    77ac:	20 e0       	ldi	r18, 0x00	; 0
    77ae:	a2 07       	cpc	r26, r18
    77b0:	20 e0       	ldi	r18, 0x00	; 0
    77b2:	b2 07       	cpc	r27, r18
    77b4:	08 f0       	brcs	.+2      	; 0x77b8 <main+0x1b8>
    77b6:	c5 c0       	rjmp	.+394    	; 0x7942 <main+0x342>
                                // don't allow bootloader overwrite
                                send_char(REPLY_ERROR);
                        }
                        else
                        {
                                Flash_WriteApplicationPage( address << 1);
    77b8:	fc 01       	movw	r30, r24
    77ba:	ee 0f       	add	r30, r30
    77bc:	ff 1f       	adc	r31, r31
    77be:	70 92 57 00 	sts	0x0057, r7
    77c2:	e8 95       	spm
    77c4:	85 cf       	rjmp	.-246    	; 0x76d0 <main+0xd0>
                        }
                }
                #endif // ENABLE_FLASH_BYTE_SUPPORT
                #ifdef ENABLE_EEPROM_BYTE_SUPPORT
                // Write EEPROM memory
                else if (val == CMD_WRITE_EEPROM_BYTE)
    77c6:	84 34       	cpi	r24, 0x44	; 68
    77c8:	91 f4       	brne	.+36     	; 0x77ee <main+0x1ee>
                {
                        EEPROM_write_byte(address, get_char());
    77ca:	e9 80       	ldd	r14, Y+1	; 0x01
    77cc:	fa 80       	ldd	r15, Y+2	; 0x02
    77ce:	0b 81       	ldd	r16, Y+3	; 0x03
    77d0:	1c 81       	ldd	r17, Y+4	; 0x04
    77d2:	0e 94 a9 38 	call	0x7152	; 0x7152 <get_char>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    77d6:	f9 99       	sbic	0x1f, 1	; 31
    77d8:	fe cf       	rjmp	.-4      	; 0x77d6 <main+0x1d6>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    77da:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    77dc:	f2 bc       	out	0x22, r15	; 34
    77de:	e1 bc       	out	0x21, r14	; 33
#endif
    EEDR = __value;
    77e0:	80 bd       	out	0x20, r24	; 32

    __asm__ __volatile__ (
    77e2:	0f b6       	in	r0, 0x3f	; 63
    77e4:	f8 94       	cli
    77e6:	fa 9a       	sbi	0x1f, 2	; 31
    77e8:	f9 9a       	sbi	0x1f, 1	; 31
    77ea:	0f be       	out	0x3f, r0	; 63
    77ec:	0e c0       	rjmp	.+28     	; 0x780a <main+0x20a>
                        address++;
                }
                // Read EEPROM memory
                else if (val == CMD_READ_EEPROM_BYTE)
    77ee:	84 36       	cpi	r24, 0x64	; 100
    77f0:	c1 f4       	brne	.+48     	; 0x7822 <main+0x222>
                {
                        char c = EEPROM_read_byte(address);
    77f2:	89 81       	ldd	r24, Y+1	; 0x01
    77f4:	9a 81       	ldd	r25, Y+2	; 0x02
    77f6:	ab 81       	ldd	r26, Y+3	; 0x03
    77f8:	bc 81       	ldd	r27, Y+4	; 0x04
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    77fa:	f9 99       	sbic	0x1f, 1	; 31
    77fc:	fe cf       	rjmp	.-4      	; 0x77fa <main+0x1fa>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    77fe:	92 bd       	out	0x22, r25	; 34
    7800:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    7802:	f8 9a       	sbi	0x1f, 0	; 31
    7804:	80 b5       	in	r24, 0x20	; 32
                        #ifdef ENABLE_EEPROM_PROTECTION
                        if (protected)
                                c = 0xff;
                        #endif // ENABLE_EEPROM_PROTECTION
                        
                        send_char(c);
    7806:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        address++;
    780a:	89 81       	ldd	r24, Y+1	; 0x01
    780c:	9a 81       	ldd	r25, Y+2	; 0x02
    780e:	ab 81       	ldd	r26, Y+3	; 0x03
    7810:	bc 81       	ldd	r27, Y+4	; 0x04
    7812:	01 96       	adiw	r24, 0x01	; 1
    7814:	a1 1d       	adc	r26, r1
    7816:	b1 1d       	adc	r27, r1
    7818:	89 83       	std	Y+1, r24	; 0x01
    781a:	9a 83       	std	Y+2, r25	; 0x02
    781c:	ab 83       	std	Y+3, r26	; 0x03
    781e:	bc 83       	std	Y+4, r27	; 0x04
    7820:	93 c0       	rjmp	.+294    	; 0x7948 <main+0x348>
                        send_char(SP_ReadFuseByte(2));
                }
#endif // __AVR_XMEGA__
                #endif // ENABLE_FUSE_BITS
                // Enter and leave programming mode
                else if ((val == CMD_ENTER_PROG_MODE) || (val == CMD_LEAVE_PROG_MODE))
    7822:	80 35       	cpi	r24, 0x50	; 80
    7824:	09 f4       	brne	.+2      	; 0x7828 <main+0x228>
    7826:	54 cf       	rjmp	.-344    	; 0x76d0 <main+0xd0>
    7828:	8c 34       	cpi	r24, 0x4C	; 76
    782a:	09 f4       	brne	.+2      	; 0x782e <main+0x22e>
    782c:	51 cf       	rjmp	.-350    	; 0x76d0 <main+0xd0>
                {
                        // just acknowledge
                        send_char(REPLY_ACK);
                }
                // Exit bootloader
                else if (val == CMD_EXIT_BOOTLOADER)
    782e:	85 34       	cpi	r24, 0x45	; 69
    7830:	29 f4       	brne	.+10     	; 0x783c <main+0x23c>
                {
                        in_bootloader = 0;
                        send_char(REPLY_ACK);
    7832:	8d e0       	ldi	r24, 0x0D	; 13
    7834:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
    7838:	80 e0       	ldi	r24, 0x00	; 0
    783a:	87 c0       	rjmp	.+270    	; 0x794a <main+0x34a>
                }
                // Get programmer type
                else if (val == CMD_PROGRAMMER_TYPE)
    783c:	80 37       	cpi	r24, 0x70	; 112
    783e:	11 f4       	brne	.+4      	; 0x7844 <main+0x244>
                {
                        // serial
                        send_char('S');
    7840:	83 e5       	ldi	r24, 0x53	; 83
    7842:	80 c0       	rjmp	.+256    	; 0x7944 <main+0x344>
                }
                // Return supported device codes
                else if (val == CMD_DEVICE_CODE)
    7844:	84 37       	cpi	r24, 0x74	; 116
    7846:	29 f4       	brne	.+10     	; 0x7852 <main+0x252>
                {
                        // send only this device
                        send_char(123); // TODO
    7848:	8b e7       	ldi	r24, 0x7B	; 123
    784a:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        // terminator
                        send_char(0);
    784e:	80 e0       	ldi	r24, 0x00	; 0
    7850:	79 c0       	rjmp	.+242    	; 0x7944 <main+0x344>
                }
                // Set LED, clear LED, and set device type
                else if ((val == CMD_SET_LED) || (val == CMD_CLEAR_LED) || (val == CMD_SET_TYPE))
    7852:	88 57       	subi	r24, 0x78	; 120
    7854:	82 30       	cpi	r24, 0x02	; 2
    7856:	10 f0       	brcs	.+4      	; 0x785c <main+0x25c>
    7858:	94 35       	cpi	r25, 0x54	; 84
    785a:	19 f4       	brne	.+6      	; 0x7862 <main+0x262>
                {
                        // discard parameter
                        get_char();
    785c:	0e 94 a9 38 	call	0x7152	; 0x7152 <get_char>
    7860:	37 cf       	rjmp	.-402    	; 0x76d0 <main+0xd0>
                        send_char(REPLY_ACK);
                }
                // Return program identifier
                else if (val == CMD_PROGRAM_ID)
    7862:	93 35       	cpi	r25, 0x53	; 83
    7864:	a1 f4       	brne	.+40     	; 0x788e <main+0x28e>
                {
                        send_char('X');
    7866:	88 e5       	ldi	r24, 0x58	; 88
    7868:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        send_char('B');
    786c:	82 e4       	ldi	r24, 0x42	; 66
    786e:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        send_char('o');
    7872:	8f e6       	ldi	r24, 0x6F	; 111
    7874:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        send_char('o');
    7878:	8f e6       	ldi	r24, 0x6F	; 111
    787a:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        send_char('t');
    787e:	84 e7       	ldi	r24, 0x74	; 116
    7880:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        send_char('+');
    7884:	8b e2       	ldi	r24, 0x2B	; 43
    7886:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        send_char('+');
    788a:	8b e2       	ldi	r24, 0x2B	; 43
    788c:	5b c0       	rjmp	.+182    	; 0x7944 <main+0x344>
                }
                // Read software version
                else if (val == CMD_VERSION)
    788e:	96 35       	cpi	r25, 0x56	; 86
    7890:	29 f4       	brne	.+10     	; 0x789c <main+0x29c>
                {
                        send_char('0' + XBOOT_VERSION_MAJOR);
    7892:	81 e3       	ldi	r24, 0x31	; 49
    7894:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        send_char('0' + XBOOT_VERSION_MINOR);
    7898:	87 e3       	ldi	r24, 0x37	; 55
    789a:	54 c0       	rjmp	.+168    	; 0x7944 <main+0x344>
                }
                // Read signature bytes
                else if (val == CMD_READ_SIGNATURE)
    789c:	93 37       	cpi	r25, 0x73	; 115
    789e:	41 f4       	brne	.+16     	; 0x78b0 <main+0x2b0>
                {
                        send_char(SIGNATURE_2);
    78a0:	8f e0       	ldi	r24, 0x0F	; 15
    78a2:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        send_char(SIGNATURE_1);
    78a6:	85 e9       	ldi	r24, 0x95	; 149
    78a8:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        send_char(SIGNATURE_0);
    78ac:	8e e1       	ldi	r24, 0x1E	; 30
    78ae:	4a c0       	rjmp	.+148    	; 0x7944 <main+0x344>
                }
                #ifdef ENABLE_CRC_SUPPORT
                else if (val == CMD_CRC)
    78b0:	98 36       	cpi	r25, 0x68	; 104
    78b2:	09 f0       	breq	.+2      	; 0x78b6 <main+0x2b6>
    78b4:	44 c0       	rjmp	.+136    	; 0x793e <main+0x33e>
                {
                        uint32_t start = 0;
                        uint32_t length = 0;
                        uint16_t crc;
                        
                        val = get_char();
    78b6:	0e 94 a9 38 	call	0x7152	; 0x7152 <get_char>
                        
                        switch (val)
    78ba:	86 34       	cpi	r24, 0x46	; 70
    78bc:	81 f1       	breq	.+96     	; 0x791e <main+0x31e>
    78be:	87 34       	cpi	r24, 0x47	; 71
    78c0:	28 f4       	brcc	.+10     	; 0x78cc <main+0x2cc>
    78c2:	81 34       	cpi	r24, 0x41	; 65
    78c4:	41 f0       	breq	.+16     	; 0x78d6 <main+0x2d6>
    78c6:	82 34       	cpi	r24, 0x42	; 66
    78c8:	31 f5       	brne	.+76     	; 0x7916 <main+0x316>
    78ca:	0e c0       	rjmp	.+28     	; 0x78e8 <main+0x2e8>
    78cc:	81 36       	cpi	r24, 0x61	; 97
    78ce:	a9 f0       	breq	.+42     	; 0x78fa <main+0x2fa>
    78d0:	84 37       	cpi	r24, 0x74	; 116
    78d2:	09 f5       	brne	.+66     	; 0x7916 <main+0x316>
    78d4:	17 c0       	rjmp	.+46     	; 0x7904 <main+0x304>
    78d6:	60 e0       	ldi	r22, 0x00	; 0
    78d8:	70 e0       	ldi	r23, 0x00	; 0
    78da:	80 e0       	ldi	r24, 0x00	; 0
    78dc:	90 e0       	ldi	r25, 0x00	; 0
    78de:	20 e0       	ldi	r18, 0x00	; 0
    78e0:	30 e7       	ldi	r19, 0x70	; 112
    78e2:	40 e0       	ldi	r20, 0x00	; 0
    78e4:	50 e0       	ldi	r21, 0x00	; 0
    78e6:	23 c0       	rjmp	.+70     	; 0x792e <main+0x32e>
    78e8:	60 e0       	ldi	r22, 0x00	; 0
    78ea:	70 e7       	ldi	r23, 0x70	; 112
    78ec:	80 e0       	ldi	r24, 0x00	; 0
    78ee:	90 e0       	ldi	r25, 0x00	; 0
    78f0:	20 e0       	ldi	r18, 0x00	; 0
    78f2:	30 e1       	ldi	r19, 0x10	; 16
    78f4:	40 e0       	ldi	r20, 0x00	; 0
    78f6:	50 e0       	ldi	r21, 0x00	; 0
    78f8:	1a c0       	rjmp	.+52     	; 0x792e <main+0x32e>
                                        length = APP_SECTION_SIZE;
                                        break;
                                case SECTION_BOOT:
                                        start = BOOT_SECTION_START;
                                        length = BOOT_SECTION_SIZE;
                                        break;
    78fa:	60 e0       	ldi	r22, 0x00	; 0
    78fc:	70 e0       	ldi	r23, 0x00	; 0
    78fe:	80 e0       	ldi	r24, 0x00	; 0
    7900:	90 e0       	ldi	r25, 0x00	; 0
    7902:	04 c0       	rjmp	.+8      	; 0x790c <main+0x30c>
                                #ifdef ENABLE_API
                                case SECTION_APP:
                                        length = XB_APP_SIZE;
                                        break;
    7904:	60 e0       	ldi	r22, 0x00	; 0
    7906:	78 e3       	ldi	r23, 0x38	; 56
    7908:	80 e0       	ldi	r24, 0x00	; 0
    790a:	90 e0       	ldi	r25, 0x00	; 0
    790c:	20 e0       	ldi	r18, 0x00	; 0
    790e:	38 e3       	ldi	r19, 0x38	; 56
    7910:	40 e0       	ldi	r20, 0x00	; 0
    7912:	50 e0       	ldi	r21, 0x00	; 0
    7914:	0c c0       	rjmp	.+24     	; 0x792e <main+0x32e>
                                        start = XB_APP_TEMP_START;
                                        length = XB_APP_TEMP_SIZE;
                                        break;
                                #endif // ENABLE_API
                                default:
                                        send_char(REPLY_ERROR);
    7916:	8f e3       	ldi	r24, 0x3F	; 63
    7918:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
    791c:	bc ce       	rjmp	.-648    	; 0x7696 <main+0x96>
                                        continue;
    791e:	60 e0       	ldi	r22, 0x00	; 0
    7920:	70 e0       	ldi	r23, 0x00	; 0
    7922:	80 e0       	ldi	r24, 0x00	; 0
    7924:	90 e0       	ldi	r25, 0x00	; 0
    7926:	20 e0       	ldi	r18, 0x00	; 0
    7928:	30 e8       	ldi	r19, 0x80	; 128
    792a:	40 e0       	ldi	r20, 0x00	; 0
    792c:	50 e0       	ldi	r21, 0x00	; 0
                        }
                        
                        crc = crc16_block(start, length);
    792e:	0e 94 d3 38 	call	0x71a6	; 0x71a6 <crc16_block>
    7932:	18 2f       	mov	r17, r24
                        
                        send_char((crc >> 8) & 0xff);
    7934:	89 2f       	mov	r24, r25
    7936:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
                        send_char(crc & 0xff);
    793a:	81 2f       	mov	r24, r17
    793c:	03 c0       	rjmp	.+6      	; 0x7944 <main+0x344>
                }
                #endif // USE_I2C_ADDRESS_NEGOTIATION
                #endif // USE_I2C
                // ESC (0x1b) to sync
                // otherwise, error
                else if (val != CMD_SYNC)
    793e:	9b 31       	cpi	r25, 0x1B	; 27
    7940:	19 f0       	breq	.+6      	; 0x7948 <main+0x348>
                {
                        send_char(REPLY_ERROR);
    7942:	8f e3       	ldi	r24, 0x3F	; 63
    7944:	0e 94 b8 38 	call	0x7170	; 0x7170 <send_char>
    7948:	81 e0       	ldi	r24, 0x01	; 1
                }
                
                // Wait for any lingering SPM instructions to finish
                Flash_WaitForSPM();
    794a:	07 b6       	in	r0, 0x37	; 55
    794c:	00 fc       	sbrc	r0, 0
    794e:	fd cf       	rjmp	.-6      	; 0x794a <main+0x34a>
        #ifdef USE_WATCHDOG
        WDT_EnableAndSetTimeout();
        #endif // USE_WATCHDOG
        
        // Main bootloader        
        while (in_bootloader) {
    7950:	88 23       	and	r24, r24
    7952:	09 f0       	breq	.+2      	; 0x7956 <main+0x356>
    7954:	a0 ce       	rjmp	.-704    	; 0x7696 <main+0x96>
        // --------------------------------------------------
        
        #ifdef ENABLE_API
        #ifdef ENABLE_API_FIRMWARE_UPDATE
        // Update firmware if needed
        install_firmware();
    7956:	0e 94 2d 39 	call	0x725a	; 0x725a <install_firmware>
        i2c_deinit();
        #endif // USE_I2C
        
        #ifdef USE_UART
        // Shut down UART
        uart_deinit();
    795a:	0e 94 64 3d 	call	0x7ac8	; 0x7ac8 <uart_deinit>
        UART_RX_PIN_CTRL = 0;
        #endif // UART_RX_PUEN
#else // __AVR_XMEGA__
        #ifdef UART_RX_PUEN
        // Disable RX pin pullup
        UART_PORT &= ~(1 << UART_RX_PIN);
    795e:	58 98       	cbi	0x0b, 0	; 11
        #ifdef USE_UART_EN_PIN
#ifdef __AVR_XMEGA__
        UART_EN_PORT.DIRCLR = (1 << UART_EN_PIN);
        UART_EN_PORT.OUTCLR = (1 << UART_EN_PIN);
#else // __AVR_XMEGA__
        UART_EN_PORT_DDR &= ~(1 << UART_EN_PIN);
    7960:	52 98       	cbi	0x0a, 2	; 10
        UART_EN_PORT &= ~(1 << UART_EN_PIN);
    7962:	5a 98       	cbi	0x0b, 2	; 11
        #endif // USE_ENTER_PIN
#else // __AVR_XMEGA__
        #ifdef USE_ENTER_PIN
        #if ENTER_PIN_PUEN
        // Disable bootloader entry pin pullup
        ENTER_PORT &= ~(1 << ENTER_PIN);
    7964:	44 98       	cbi	0x08, 4	; 8
        LED_PORT.OUTCLR = (1 << LED_PIN);
        #endif // USE_LED
#else // __AVR_XMEGA__
        #ifdef USE_LED
        // Turn off LED on exit
        LED_PORT_DDR &= ~(1 << LED_PIN);
    7966:	53 98       	cbi	0x0a, 3	; 10
        LED_PORT &= ~(1 << LED_PIN);
    7968:	5b 98       	cbi	0x0b, 3	; 11
        
        // --------------------------------------------------
        // End bootloader exit section
        
        // Jump into main code
        asm("jmp 0");
    796a:	0c 94 00 00 	jmp	0	; 0x0 <__heap_end>
        #ifdef __builtin_unreachable
        // Size optimization as the asm jmp will not return
        // However, it seems it is not available on older versions of gcc
        __builtin_unreachable();
        #endif
}
    796e:	80 e0       	ldi	r24, 0x00	; 0
    7970:	90 e0       	ldi	r25, 0x00	; 0
    7972:	0f 90       	pop	r0
    7974:	0f 90       	pop	r0
    7976:	0f 90       	pop	r0
    7978:	0f 90       	pop	r0
    797a:	cf 91       	pop	r28
    797c:	df 91       	pop	r29
    797e:	1f 91       	pop	r17
    7980:	0f 91       	pop	r16
    7982:	ff 90       	pop	r15
    7984:	ef 90       	pop	r14
    7986:	df 90       	pop	r13
    7988:	cf 90       	pop	r12
    798a:	bf 90       	pop	r11
    798c:	af 90       	pop	r10
    798e:	9f 90       	pop	r9
    7990:	8f 90       	pop	r8
    7992:	7f 90       	pop	r7
    7994:	6f 90       	pop	r6
    7996:	5f 90       	pop	r5
    7998:	08 95       	ret

0000799a <Flash_EraseApplicationSection>:
#else

// ATMega Functions

void Flash_EraseApplicationSection(void)
{
    799a:	e0 e0       	ldi	r30, 0x00	; 0
    799c:	f0 e0       	ldi	r31, 0x00	; 0
        for (uint32_t addr = 0; addr < APP_SECTION_END; addr += SPM_PAGESIZE) 
        {
                boot_page_erase(addr);
    799e:	83 e0       	ldi	r24, 0x03	; 3
    79a0:	80 93 57 00 	sts	0x0057, r24
    79a4:	e8 95       	spm
                boot_spm_busy_wait();
    79a6:	07 b6       	in	r0, 0x37	; 55
    79a8:	00 fc       	sbrc	r0, 0
    79aa:	fd cf       	rjmp	.-6      	; 0x79a6 <Flash_EraseApplicationSection+0xc>
    79ac:	e0 58       	subi	r30, 0x80	; 128
    79ae:	ff 4f       	sbci	r31, 0xFF	; 255

// ATMega Functions

void Flash_EraseApplicationSection(void)
{
        for (uint32_t addr = 0; addr < APP_SECTION_END; addr += SPM_PAGESIZE) 
    79b0:	90 e7       	ldi	r25, 0x70	; 112
    79b2:	e0 30       	cpi	r30, 0x00	; 0
    79b4:	f9 07       	cpc	r31, r25
    79b6:	a1 f7       	brne	.-24     	; 0x79a0 <Flash_EraseApplicationSection+0x6>
        {
                boot_page_erase(addr);
                boot_spm_busy_wait();
        }
        boot_rww_enable();
    79b8:	81 e1       	ldi	r24, 0x11	; 17
    79ba:	80 93 57 00 	sts	0x0057, r24
    79be:	e8 95       	spm
}
    79c0:	08 95       	ret

000079c2 <Flash_ReadFlashPage>:
                boot_page_fill(i, w);
        }
}

void Flash_ReadFlashPage(uint8_t *data, uint32_t addr)
{
    79c2:	cf 93       	push	r28
    79c4:	df 93       	push	r29
    79c6:	ec 01       	movw	r28, r24
    79c8:	cb 01       	movw	r24, r22
    79ca:	ba 01       	movw	r22, r20
    79cc:	20 e0       	ldi	r18, 0x00	; 0
    79ce:	30 e0       	ldi	r19, 0x00	; 0
    79d0:	40 e0       	ldi	r20, 0x00	; 0
    79d2:	50 e0       	ldi	r21, 0x00	; 0
    79d4:	d9 01       	movw	r26, r18
        for (uint16_t i = 0; i < SPM_PAGESIZE; i++)
        {
                data[i] = PGM_READ_BYTE(addr++);
    79d6:	f9 01       	movw	r30, r18
    79d8:	e6 0f       	add	r30, r22
    79da:	f7 1f       	adc	r31, r23
    79dc:	e4 91       	lpm	r30, Z+
    79de:	ac 0f       	add	r26, r28
    79e0:	bd 1f       	adc	r27, r29
    79e2:	ec 93       	st	X, r30
    79e4:	2f 5f       	subi	r18, 0xFF	; 255
    79e6:	3f 4f       	sbci	r19, 0xFF	; 255
    79e8:	4f 4f       	sbci	r20, 0xFF	; 255
    79ea:	5f 4f       	sbci	r21, 0xFF	; 255
        }
}

void Flash_ReadFlashPage(uint8_t *data, uint32_t addr)
{
        for (uint16_t i = 0; i < SPM_PAGESIZE; i++)
    79ec:	20 38       	cpi	r18, 0x80	; 128
    79ee:	31 05       	cpc	r19, r1
    79f0:	41 05       	cpc	r20, r1
    79f2:	51 05       	cpc	r21, r1
    79f4:	79 f7       	brne	.-34     	; 0x79d4 <Flash_ReadFlashPage+0x12>
        {
                data[i] = PGM_READ_BYTE(addr++);
        }
}
    79f6:	df 91       	pop	r29
    79f8:	cf 91       	pop	r28
    79fa:	08 95       	ret

000079fc <Flash_ProgramPage>:

void Flash_ProgramPage(uint32_t page, uint8_t *buf, uint8_t erase)
{
    79fc:	ef 92       	push	r14
    79fe:	ff 92       	push	r15
    7a00:	0f 93       	push	r16
    7a02:	1f 93       	push	r17
    7a04:	cf 93       	push	r28
    7a06:	df 93       	push	r29
    7a08:	7b 01       	movw	r14, r22
    7a0a:	8c 01       	movw	r16, r24
    7a0c:	da 01       	movw	r26, r20
        uint16_t i;
        
        eeprom_busy_wait ();
    7a0e:	f9 99       	sbic	0x1f, 1	; 31
    7a10:	fe cf       	rjmp	.-4      	; 0x7a0e <Flash_ProgramPage+0x12>
        
        if (erase)
    7a12:	22 23       	and	r18, r18
    7a14:	39 f4       	brne	.+14     	; 0x7a24 <Flash_ProgramPage+0x28>
    7a16:	a7 01       	movw	r20, r14
    7a18:	f7 01       	movw	r30, r14
        
        for (i=0; i<SPM_PAGESIZE; i+=2)
        {
                uint16_t w = *buf++;
                w += (*buf++) << 8;
                boot_page_fill (page + i, w);
    7a1a:	11 e0       	ldi	r17, 0x01	; 1
        {
                boot_page_erase (page);
                boot_spm_busy_wait ();
        }
        
        for (i=0; i<SPM_PAGESIZE; i+=2)
    7a1c:	b7 01       	movw	r22, r14
    7a1e:	60 58       	subi	r22, 0x80	; 128
    7a20:	7f 4f       	sbci	r23, 0xFF	; 255
    7a22:	09 c0       	rjmp	.+18     	; 0x7a36 <Flash_ProgramPage+0x3a>
        
        eeprom_busy_wait ();
        
        if (erase)
        {
                boot_page_erase (page);
    7a24:	83 e0       	ldi	r24, 0x03	; 3
    7a26:	f7 01       	movw	r30, r14
    7a28:	80 93 57 00 	sts	0x0057, r24
    7a2c:	e8 95       	spm
                boot_spm_busy_wait ();
    7a2e:	07 b6       	in	r0, 0x37	; 55
    7a30:	00 fc       	sbrc	r0, 0
    7a32:	fd cf       	rjmp	.-6      	; 0x7a2e <Flash_ProgramPage+0x32>
    7a34:	f0 cf       	rjmp	.-32     	; 0x7a16 <Flash_ProgramPage+0x1a>
        }
        
        for (i=0; i<SPM_PAGESIZE; i+=2)
        {
                uint16_t w = *buf++;
    7a36:	8c 91       	ld	r24, X
                w += (*buf++) << 8;
    7a38:	11 96       	adiw	r26, 0x01	; 1
    7a3a:	3c 91       	ld	r19, X
    7a3c:	11 97       	sbiw	r26, 0x01	; 1
    7a3e:	20 e0       	ldi	r18, 0x00	; 0
    7a40:	e9 01       	movw	r28, r18
    7a42:	c8 0f       	add	r28, r24
    7a44:	d1 1d       	adc	r29, r1
                data[i] = PGM_READ_BYTE(addr++);
        }
}

void Flash_ProgramPage(uint32_t page, uint8_t *buf, uint8_t erase)
{
    7a46:	12 96       	adiw	r26, 0x02	; 2
        
        for (i=0; i<SPM_PAGESIZE; i+=2)
        {
                uint16_t w = *buf++;
                w += (*buf++) << 8;
                boot_page_fill (page + i, w);
    7a48:	0e 01       	movw	r0, r28
    7a4a:	10 93 57 00 	sts	0x0057, r17
    7a4e:	e8 95       	spm
    7a50:	11 24       	eor	r1, r1
    7a52:	32 96       	adiw	r30, 0x02	; 2
        {
                boot_page_erase (page);
                boot_spm_busy_wait ();
        }
        
        for (i=0; i<SPM_PAGESIZE; i+=2)
    7a54:	e6 17       	cp	r30, r22
    7a56:	f7 07       	cpc	r31, r23
    7a58:	71 f7       	brne	.-36     	; 0x7a36 <Flash_ProgramPage+0x3a>
                uint16_t w = *buf++;
                w += (*buf++) << 8;
                boot_page_fill (page + i, w);
        }
        
        boot_page_write(page);
    7a5a:	85 e0       	ldi	r24, 0x05	; 5
    7a5c:	fa 01       	movw	r30, r20
    7a5e:	80 93 57 00 	sts	0x0057, r24
    7a62:	e8 95       	spm
        boot_spm_busy_wait();
    7a64:	07 b6       	in	r0, 0x37	; 55
    7a66:	00 fc       	sbrc	r0, 0
    7a68:	fd cf       	rjmp	.-6      	; 0x7a64 <Flash_ProgramPage+0x68>
        boot_rww_enable();
    7a6a:	81 e1       	ldi	r24, 0x11	; 17
    7a6c:	80 93 57 00 	sts	0x0057, r24
    7a70:	e8 95       	spm
}
    7a72:	df 91       	pop	r29
    7a74:	cf 91       	pop	r28
    7a76:	1f 91       	pop	r17
    7a78:	0f 91       	pop	r16
    7a7a:	ff 90       	pop	r15
    7a7c:	ef 90       	pop	r14
    7a7e:	08 95       	ret

00007a80 <EEPROM_erase_all>:
}

#else // __AVR_XMEGA__

void EEPROM_erase_all(void)
{
    7a80:	80 e0       	ldi	r24, 0x00	; 0
    7a82:	90 e0       	ldi	r25, 0x00	; 0
#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
#endif
    EEDR = __value;
    7a84:	2f ef       	ldi	r18, 0xFF	; 255
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    7a86:	f9 99       	sbic	0x1f, 1	; 31
    7a88:	fe cf       	rjmp	.-4      	; 0x7a86 <EEPROM_erase_all+0x6>

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    7a8a:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    7a8c:	92 bd       	out	0x22, r25	; 34
    7a8e:	81 bd       	out	0x21, r24	; 33
#endif
    EEDR = __value;
    7a90:	20 bd       	out	0x20, r18	; 32

    __asm__ __volatile__ (
    7a92:	0f b6       	in	r0, 0x3f	; 63
    7a94:	f8 94       	cli
    7a96:	fa 9a       	sbi	0x1f, 2	; 31
    7a98:	f9 9a       	sbi	0x1f, 1	; 31
    7a9a:	0f be       	out	0x3f, r0	; 63
        for (uint16_t i = 0; i < E2END; i++)
    7a9c:	01 96       	adiw	r24, 0x01	; 1
    7a9e:	33 e0       	ldi	r19, 0x03	; 3
    7aa0:	8f 3f       	cpi	r24, 0xFF	; 255
    7aa2:	93 07       	cpc	r25, r19
    7aa4:	81 f7       	brne	.-32     	; 0x7a86 <EEPROM_erase_all+0x6>
        {
                eeprom_write_byte((uint8_t *)i, 0xff);
        }
}
    7aa6:	08 95       	ret

00007aa8 <uart_init>:
        #endif // UART_CLK2X
        #ifdef USE_INTERRUPTS
        UART_DEVICE.CTRLA = USART_RXCINTLVL0_bm | USART_TXCINTLVL0_bm;
        #endif // USE_INTERRUPTS
#else // __AVR_XMEGA__
        UART_UBRR = UART_BRV;
    7aa8:	82 e2       	ldi	r24, 0x22	; 34
    7aaa:	90 e0       	ldi	r25, 0x00	; 0
    7aac:	90 93 c5 00 	sts	0x00C5, r25
    7ab0:	80 93 c4 00 	sts	0x00C4, r24
        #ifdef UART_U2X
        UART_UCSRA = _BV(U2X0);
    7ab4:	82 e0       	ldi	r24, 0x02	; 2
    7ab6:	80 93 c0 00 	sts	0x00C0, r24
        #else
        UART_UCSRA = 0;
        #endif
        UART_UCSRB = _BV(RXEN0) | _BV(TXEN0);
    7aba:	88 e1       	ldi	r24, 0x18	; 24
    7abc:	80 93 c1 00 	sts	0x00C1, r24
        UART_UCSRC = _BV(UCSZ01) | _BV(UCSZ00);
    7ac0:	86 e0       	ldi	r24, 0x06	; 6
    7ac2:	80 93 c2 00 	sts	0x00C2, r24
#endif // __AVR_XMEGA__
}
    7ac6:	08 95       	ret

00007ac8 <uart_deinit>:
        #endif // USE_INTERRUPTS
        UART_DEVICE.BAUDCTRLA = 0;
        UART_DEVICE.BAUDCTRLB = 0;
        UART_PORT.DIRCLR = (1 << UART_TX_PIN);
#else // __AVR_XMEGA__
        UART_UCSRA = 0;
    7ac8:	10 92 c0 00 	sts	0x00C0, r1
        UART_UCSRB = 0;
    7acc:	10 92 c1 00 	sts	0x00C1, r1
        UART_UCSRC = _BV(UCSZ01) | _BV(UCSZ00);
    7ad0:	86 e0       	ldi	r24, 0x06	; 6
    7ad2:	80 93 c2 00 	sts	0x00C2, r24
        UART_UBRR = 0;
    7ad6:	10 92 c5 00 	sts	0x00C5, r1
    7ada:	10 92 c4 00 	sts	0x00C4, r1
#endif // __AVR_XMEGA__
}
    7ade:	08 95       	ret

00007ae0 <xboot_get_version>:

#endif // ENABLE_API

// General Functions
uint8_t xboot_get_version(uint16_t *ver)
{
    7ae0:	fc 01       	movw	r30, r24
        *ver = (XBOOT_VERSION_MAJOR << 8) | (XBOOT_VERSION_MINOR);
    7ae2:	87 e0       	ldi	r24, 0x07	; 7
    7ae4:	91 e0       	ldi	r25, 0x01	; 1
    7ae6:	91 83       	std	Z+1, r25	; 0x01
    7ae8:	80 83       	st	Z, r24
        return XB_SUCCESS;
}
    7aea:	80 e0       	ldi	r24, 0x00	; 0
    7aec:	08 95       	ret

00007aee <xboot_spm_wrapper>:

// Low level flash access
uint8_t xboot_spm_wrapper(void)
{
        return XB_ERR_NOT_FOUND;
}
    7aee:	82 e0       	ldi	r24, 0x02	; 2
    7af0:	08 95       	ret

00007af2 <xboot_erase_application_page>:

uint8_t xboot_erase_application_page(uint32_t address)
{
    7af2:	9b 01       	movw	r18, r22
    7af4:	ac 01       	movw	r20, r24
        uint8_t saved_status = SREG;
    7af6:	9f b7       	in	r25, 0x3f	; 63
        
        if (address > BOOT_SECTION_START)
    7af8:	21 30       	cpi	r18, 0x01	; 1
    7afa:	80 e7       	ldi	r24, 0x70	; 112
    7afc:	38 07       	cpc	r19, r24
    7afe:	80 e0       	ldi	r24, 0x00	; 0
    7b00:	48 07       	cpc	r20, r24
    7b02:	80 e0       	ldi	r24, 0x00	; 0
    7b04:	58 07       	cpc	r21, r24
    7b06:	10 f0       	brcs	.+4      	; 0x7b0c <xboot_erase_application_page+0x1a>
    7b08:	83 e0       	ldi	r24, 0x03	; 3
    7b0a:	08 95       	ret
                return XB_INVALID_ADDRESS;
        
        cli();
    7b0c:	f8 94       	cli
        
        Flash_EraseApplicationPage(address);
    7b0e:	83 e0       	ldi	r24, 0x03	; 3
    7b10:	f9 01       	movw	r30, r18
    7b12:	80 93 57 00 	sts	0x0057, r24
    7b16:	e8 95       	spm
        Flash_WaitForSPM();
    7b18:	07 b6       	in	r0, 0x37	; 55
    7b1a:	00 fc       	sbrc	r0, 0
    7b1c:	fd cf       	rjmp	.-6      	; 0x7b18 <xboot_erase_application_page+0x26>
        
#ifndef __AVR_XMEGA__
        boot_rww_enable();
    7b1e:	81 e1       	ldi	r24, 0x11	; 17
    7b20:	80 93 57 00 	sts	0x0057, r24
    7b24:	e8 95       	spm
        
#ifdef __AVR_XMEGA__
        NVM_CMD = NVM_CMD_NO_OPERATION_gc;
#endif // __AVR_XMEGA__
        
        SREG = saved_status;
    7b26:	9f bf       	out	0x3f, r25	; 63
    7b28:	80 e0       	ldi	r24, 0x00	; 0
        return XB_SUCCESS;
}
    7b2a:	08 95       	ret

00007b2c <xboot_app_temp_erase>:
#endif // __AVR_XMEGA__

// Higher level firmware update functions
uint8_t xboot_app_temp_erase(void)
{
        uint8_t saved_status = SREG;
    7b2c:	9f b7       	in	r25, 0x3f	; 63
        cli();
    7b2e:	f8 94       	cli
    7b30:	e0 e0       	ldi	r30, 0x00	; 0
    7b32:	f8 e3       	ldi	r31, 0x38	; 56
        
        for (uint32_t addr = XB_APP_TEMP_START; addr < XB_APP_TEMP_END; addr += SPM_PAGESIZE)
        {
                Flash_EraseApplicationPage(addr);
    7b34:	83 e0       	ldi	r24, 0x03	; 3
    7b36:	80 93 57 00 	sts	0x0057, r24
    7b3a:	e8 95       	spm
                Flash_WaitForSPM();
    7b3c:	07 b6       	in	r0, 0x37	; 55
    7b3e:	00 fc       	sbrc	r0, 0
    7b40:	fd cf       	rjmp	.-6      	; 0x7b3c <xboot_app_temp_erase+0x10>
    7b42:	e0 58       	subi	r30, 0x80	; 128
    7b44:	ff 4f       	sbci	r31, 0xFF	; 255
uint8_t xboot_app_temp_erase(void)
{
        uint8_t saved_status = SREG;
        cli();
        
        for (uint32_t addr = XB_APP_TEMP_START; addr < XB_APP_TEMP_END; addr += SPM_PAGESIZE)
    7b46:	20 e7       	ldi	r18, 0x70	; 112
    7b48:	e0 30       	cpi	r30, 0x00	; 0
    7b4a:	f2 07       	cpc	r31, r18
    7b4c:	a1 f7       	brne	.-24     	; 0x7b36 <xboot_app_temp_erase+0xa>
                Flash_EraseApplicationPage(addr);
                Flash_WaitForSPM();
        }
        
#ifndef __AVR_XMEGA__
        boot_rww_enable();
    7b4e:	81 e1       	ldi	r24, 0x11	; 17
    7b50:	80 93 57 00 	sts	0x0057, r24
    7b54:	e8 95       	spm
        
#ifdef __AVR_XMEGA__
        NVM_CMD = NVM_CMD_NO_OPERATION_gc;
#endif // __AVR_XMEGA__
        
        SREG = saved_status;
    7b56:	9f bf       	out	0x3f, r25	; 63
        return XB_SUCCESS;
}
    7b58:	80 e0       	ldi	r24, 0x00	; 0
    7b5a:	08 95       	ret

00007b5c <xboot_write_application_page>:
        SREG = saved_status;
        return XB_SUCCESS;
}

uint8_t xboot_write_application_page(uint32_t address, uint8_t *data, uint8_t erase)
{
    7b5c:	1f 93       	push	r17
        uint8_t saved_status = SREG;
    7b5e:	1f b7       	in	r17, 0x3f	; 63
        
        if (address > BOOT_SECTION_START)
    7b60:	61 30       	cpi	r22, 0x01	; 1
    7b62:	30 e7       	ldi	r19, 0x70	; 112
    7b64:	73 07       	cpc	r23, r19
    7b66:	30 e0       	ldi	r19, 0x00	; 0
    7b68:	83 07       	cpc	r24, r19
    7b6a:	30 e0       	ldi	r19, 0x00	; 0
    7b6c:	93 07       	cpc	r25, r19
    7b6e:	10 f0       	brcs	.+4      	; 0x7b74 <xboot_write_application_page+0x18>
    7b70:	83 e0       	ldi	r24, 0x03	; 3
    7b72:	05 c0       	rjmp	.+10     	; 0x7b7e <xboot_write_application_page+0x22>
                return XB_INVALID_ADDRESS;
        
        cli();
    7b74:	f8 94       	cli
        
        Flash_ProgramPage(address, data, erase);
    7b76:	0e 94 fe 3c 	call	0x79fc	; 0x79fc <Flash_ProgramPage>
        
#ifdef __AVR_XMEGA__
        NVM_CMD = NVM_CMD_NO_OPERATION_gc;
#endif // __AVR_XMEGA__
        
        SREG = saved_status;
    7b7a:	1f bf       	out	0x3f, r17	; 63
    7b7c:	80 e0       	ldi	r24, 0x00	; 0
        return XB_SUCCESS;
}
    7b7e:	1f 91       	pop	r17
    7b80:	08 95       	ret

00007b82 <xboot_app_temp_write_page>:
        return XB_SUCCESS;
}

uint8_t xboot_app_temp_write_page(uint32_t addr, uint8_t *data, uint8_t erase)
{
        return xboot_write_application_page(addr + XB_APP_TEMP_START, data, erase);
    7b82:	60 50       	subi	r22, 0x00	; 0
    7b84:	78 4c       	sbci	r23, 0xC8	; 200
    7b86:	8f 4f       	sbci	r24, 0xFF	; 255
    7b88:	9f 4f       	sbci	r25, 0xFF	; 255
    7b8a:	0e 94 ae 3d 	call	0x7b5c	; 0x7b5c <xboot_write_application_page>
}
    7b8e:	08 95       	ret

00007b90 <__prologue_saves__>:
    7b90:	2f 92       	push	r2
    7b92:	3f 92       	push	r3
    7b94:	4f 92       	push	r4
    7b96:	5f 92       	push	r5
    7b98:	6f 92       	push	r6
    7b9a:	7f 92       	push	r7
    7b9c:	8f 92       	push	r8
    7b9e:	9f 92       	push	r9
    7ba0:	af 92       	push	r10
    7ba2:	bf 92       	push	r11
    7ba4:	cf 92       	push	r12
    7ba6:	df 92       	push	r13
    7ba8:	ef 92       	push	r14
    7baa:	ff 92       	push	r15
    7bac:	0f 93       	push	r16
    7bae:	1f 93       	push	r17
    7bb0:	cf 93       	push	r28
    7bb2:	df 93       	push	r29
    7bb4:	cd b7       	in	r28, 0x3d	; 61
    7bb6:	de b7       	in	r29, 0x3e	; 62
    7bb8:	ca 1b       	sub	r28, r26
    7bba:	db 0b       	sbc	r29, r27
    7bbc:	0f b6       	in	r0, 0x3f	; 63
    7bbe:	f8 94       	cli
    7bc0:	de bf       	out	0x3e, r29	; 62
    7bc2:	0f be       	out	0x3f, r0	; 63
    7bc4:	cd bf       	out	0x3d, r28	; 61
    7bc6:	09 94       	ijmp

00007bc8 <__epilogue_restores__>:
    7bc8:	2a 88       	ldd	r2, Y+18	; 0x12
    7bca:	39 88       	ldd	r3, Y+17	; 0x11
    7bcc:	48 88       	ldd	r4, Y+16	; 0x10
    7bce:	5f 84       	ldd	r5, Y+15	; 0x0f
    7bd0:	6e 84       	ldd	r6, Y+14	; 0x0e
    7bd2:	7d 84       	ldd	r7, Y+13	; 0x0d
    7bd4:	8c 84       	ldd	r8, Y+12	; 0x0c
    7bd6:	9b 84       	ldd	r9, Y+11	; 0x0b
    7bd8:	aa 84       	ldd	r10, Y+10	; 0x0a
    7bda:	b9 84       	ldd	r11, Y+9	; 0x09
    7bdc:	c8 84       	ldd	r12, Y+8	; 0x08
    7bde:	df 80       	ldd	r13, Y+7	; 0x07
    7be0:	ee 80       	ldd	r14, Y+6	; 0x06
    7be2:	fd 80       	ldd	r15, Y+5	; 0x05
    7be4:	0c 81       	ldd	r16, Y+4	; 0x04
    7be6:	1b 81       	ldd	r17, Y+3	; 0x03
    7be8:	aa 81       	ldd	r26, Y+2	; 0x02
    7bea:	b9 81       	ldd	r27, Y+1	; 0x01
    7bec:	ce 0f       	add	r28, r30
    7bee:	d1 1d       	adc	r29, r1
    7bf0:	0f b6       	in	r0, 0x3f	; 63
    7bf2:	f8 94       	cli
    7bf4:	de bf       	out	0x3e, r29	; 62
    7bf6:	0f be       	out	0x3f, r0	; 63
    7bf8:	cd bf       	out	0x3d, r28	; 61
    7bfa:	ed 01       	movw	r28, r26
    7bfc:	08 95       	ret

00007bfe <_exit>:
    7bfe:	f8 94       	cli

00007c00 <__stop_program>:
    7c00:	ff cf       	rjmp	.-2      	; 0x7c00 <__stop_program>
